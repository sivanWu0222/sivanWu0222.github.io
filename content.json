{"meta":{"title":"逸如风的个人博客","subtitle":"","description":"","author":"yirufeng","url":"http://www.sivan.tech","root":"/"},"pages":[{"title":"","date":"2021-05-30T02:42:45.756Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"about/index.html","permalink":"http://www.sivan.tech/about/index.html","excerpt":"","text":"🐶浪开发者，坐标武汉 广埠屯断水停电大学在读研究生 关于我 最美好的一瞬间 实践经历 2019.09 - now 教育大数据应用技术国家工程实验室 - 认知计算实验室 2017.09 - 2019.06 Let’s try 社团技术指导委员会成员 2017.07 - 2018.07 湖南青创客网络科技有限公司项目经理 2017.09 - 2017.11 软件新技术研究组副组长(机器学习方向) 2015.10 - 2017.09 计算机学院创新创业实验室项目组(校内ACM竞赛选拔) 博客经历 2020.09（更换现有主题） 更换博客主题 2019.08（博客挂掉，改用hexo） 使用hexo + travis CI 自动集成部署博客 2016.09（使用WordPress） 使用WordPress搭建自己的第一个博客 那些鼓励我的话吃学习的苦，不吃生活的苦。 有一句话是“遍地都是六便士，他却抬头看月亮”。这句话的意思是，人要克制对唾手可得的实际利益的诱惑，要有一种超越性的、更宽阔的眼界。有时候，抬头看月亮，是多么奢侈的一件事啊，因为利益的羁绊，不是那么容易破掉的，尤其是生活在承受重负之时。另一句话是：“我用尽了毕生的力气，只是抵达了生活的平凡”。这句话中包含的力量，正好与前一句形成互补。 将有必死之心，士无偷生之念。 只有杀敌的军人，没有屈膝的将军。 故今日责任，不在他人，就在少年，少年强则国强，少年富则国富 我欲望着他人的欲望 种一棵树最好的时间是十年前，其次是现在 唯有自强不息，我们才会有日后的无限可能。” 一个成器的孩子，不仅仅带给父母喜悦，甚至还寄托着他们的尊严。 没有什么通过努力做不到的，如果有那就是不够努力 世上所有的奇迹，都源于努力 岂能尽如人意，但求无愧于心 专注 年轻人可以把多余的时间和精力，专注到自己喜欢做的事情上。 当一个人自律到极致的时候，即便你起点不高，即便你受尽嘲讽，全世界依旧会为你让路。 人生没有寒暑假，不是成功来得不够快，而是对自己不够狠 成功从来没有捷径，努力的人从来不会被辜负 世上所有的牛逼，闻起来，其实都是加班的味道！有人问美国“篮球天才”科比为何如此成功？他反问道：“你知道洛杉矶每天早上4点钟是什么样子吗？”这个世界上最可怕的事：那些比你聪明的人，比你更努力 世上只有一种投资只赚不赔，那就是学习。莫言曾经说过：当你的才华还撑不起你的野心的时候，你就应该静下心来学习，当你的能力还驾驭不了你的目标时，就应该沉下心来历练；从来没有人因为学习而倾家荡产，但一定有人因为不学习而一贫如洗；从来没有人因为学习而越学越贫穷，但一定有人因为学习而走向成功。 计算机科学也不能保证让你一辈子没有遗憾，但是它有可能，帮助你实现贝佐斯（亚马逊CEO）追求的目标：把认识当中的遗憾降到最少 为了避免平庸，要拒绝拉着你走向平庸的那些压力、诱惑，大多数人无法做到，但张一鸣做到了。 主动选择的时候，用排列组合，做出最优解；被动的放弃的时刻，用算法设计，选择最好的结果。 如果世界上真的有奇迹，那只是努力的另一个名字。愿披星戴月的你，终将凯旋。 人若有志，万事可为如果你年轻的时候学不会思考，那就永远不会 心能拘束，身何拘束 唯努力不负人。 要么死的安然，要么活的絢烂 我，有个职业病，看到美的东西就想拍下来。 这个世界上没有天才，只有不努力的笨蛋 做自己觉得有意义且正确的事情，不浪费时间在不相关的人和事情身上，这大概就是快乐的开关吧。 那些挥舞的泪水永远不会白流 别让别人告诉你，你也成不了才，如果你有梦想的话，就要去捍卫它，那些一事无成的人，想告诉你，你也成不了才。 每一个不曾起舞的日子，都是对生命的辜负。 你可以一无所有，但不可以一无是处 人生处处是缘分，无论你去了哪里，都是冥冥中自有天意，所以不要太在意自己去了哪里，现在生活怎么样，无论你去了国际大厂，还是去了国内中小企业，这都是你的缘分，就像你出生在什么样的家庭，拥有着什么样的智商，都是自己和家人和企业和这个世界的缘分，当你以为与某个企业应该有缘分，但是最终却没有收获到对应的缘分，不必叹息，又或当你与哪个女孩子，男孩子错过，也不要感叹，这都是我们的缘分，我们只需做好自己，打好手中已有的牌。不过如果你心中有个情节，你想和哪个姑娘发生缘分..哦对不起我帮不了你。但是如果你想跟字节发生一些缘分，我可以助力你一把。快来吧! 最后希望你与我也可以发生缘分（投递）。 你会经历一段难以置信、跌宕起伏的旅程。你会遇到很多志同道合的好友，以及你十分尊敬的师长。虽然你也会走很多弯路，碰到很多困难与挫折，但是不要担心，你一直兢兢业业、勤勉刻苦，你的努力最终都会得到回报 愿你历尽千帆，终能得偿所愿。 如果我走到人生十字路口，我知道哪条路是对的， 毫无例外，我就知道，但我从不走，为什么？因为妈的太苦了。 别让别人告诉你，你成不了才。如果你有梦想的话，就要去捍卫它。 把手握紧，厚积薄发，你，只有付出，付出你的时间，赌上你的尊严，拿出你的全部，当别人打游戏时你在学习，当别人睡懒觉时你在学习，你含着泪在深夜里舞蹈，在回忆里奔跑，没有人在年少时想成为一个普通人。尽管生活，它会剥夺你的所爱践踏你的尊严，把你踩在脚下遍体鳞伤，但你怎能倒下？但你身后是你的挚爱，那些曾受过的伤，都是你送给未来自己最好的礼物。 正如巴尔扎克在人间喜剧中所言，革新者全靠了不起的信心支持，才有勇气在不可知的天地中前进。（But as Balzac said in The Human Comedy: The innovator is supported by great confidence. To have the courage to move forward in the unknown.）"},{"title":"archives","date":"2020-09-19T15:23:53.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"archives/index.html","permalink":"http://www.sivan.tech/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-09-19T15:19:19.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"categories/index.html","permalink":"http://www.sivan.tech/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-05-30T02:42:45.756Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"friends/index.html","permalink":"http://www.sivan.tech/friends/index.html","excerpt":"","text":"一些技术大牛或团队飞雪无情Go各种框架教程等 极客兔兔golang从零实现系列教程 致力于分享Go语言编程致力于分享Go语言编程 美团技术团队美团技术团队 阿里云RDS-数据库内核组阿里云RDS-数据库内核组 Golang鸟窝大佬(rpcx作者)原百度现微博Golang技术大牛 潘建锋Golang技术大牛 曹春晖(Go作者)Go夜读中的滴滴大佬 柴树杉晖(《Go语言高级编程》《Go语法树入门》《WebAssembly标准入门》作者)蚂蚁杭州（云原生工程系统） 无闻老师无闻老师 欧神博客Golang committers 欧神开源书《Go 语言原本》Golang committers 饶全成公众号：\"码农桃花源\" 面向信仰编程draveness（给 kubernetes 提交 pr 的大神）的博客 煎鱼的迷之博客知其然，知其所以然 jiajun的编程思想 云原生实验室 CloudNative 架构 mohuishou 泫(深圳腾讯音乐)本科地大硕士华科大佬 一些课程推荐 极客时间的《Go进阶训练营》 一些技术团队博客汇总 wego 公众号 码农桃花源 码洞 开发内功修炼 TechPaper(曹大的微信公众号，曹大的博客：https://xargin.com/) Golang Contributor Club bilibili_up主推荐 go夜读 Go杂志 A journel with go Go101 书籍 go高级编程 go语言设计与实现 go学习笔记 曹大的go从源码到应用 《Go入门指南》 无闻老师的课程：https://study.163.com/course/courseLearn.htm?courseId=306002#/learn/video?lessonId=421024&amp;courseId=306002 Go101 go进阶 曹大的源码分析 Go语言设计与实现 Go语言原本 深度阅读之&lt;&gt; Mastering Go Go101 （饶神 + 曹大 + 鸟窝 + Golang Contributor Club）的文章"},{"title":"","date":"2021-05-30T02:42:45.756Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"list/index.html","permalink":"http://www.sivan.tech/list/index.html","excerpt":"","text":""},{"title":"开源项目","date":"2020-09-19T18:04:18.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"projects/index.html","permalink":"http://www.sivan.tech/projects/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-05-30T02:42:45.756Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"tags/index.html","permalink":"http://www.sivan.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Demo","slug":"demo","date":"2099-09-15T19:43:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2099/09/15/demo/","link":"","permalink":"http://www.sivan.tech/2099/09/15/demo/","excerpt":"","text":"文章头部frot-matter编写参考 所有样式来源于：https://volantis.js.org/v5/tag-plugins/ text带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码 span各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字： Volantis A Wonderful Theme for Hexo p红色 黄色 绿色 青色 蓝色 灰色 Volantis A Wonderful Theme for Hexo note文本内容 issue标签参考 相册一行一图 一行多图 多行多图 github卡片标签 分栏标签栏目1栏目2。。。！！！ 引用标签可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 note quote 适合引用一段话 note info 默认主题色，适合中性的信息 note warning 默认黄色，适合警告性的信息 note error/danger 默认红色，适合危险性的信息 note done/success 默认绿色，适合正确操作的信息 note radiation 默认样式 note radiation yellow 可以加上颜色 note bug red 说明还存在的一些故障 note link green 可以放置一些链接 note paperclip blue 放置一些附件链接 note todo 待办事项 note guide clear 可以加上一段向导 note download 可以放置下载链接 note message gray 一段消息 note up 可以说明如何进行更新 note undo light 可以说明如何撤销或者回退 引用块标签标题（可选）Windows 10不是為所有人設計,而是為每個人設計嵌套测试： 请坐和放宽，我正在帮你搞定一切… Folding 测试： 点击查看更多 不要说我们没有警告过你我们都有不顺利的时候 单选列表 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 多选列表 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 时间线时间线标题（可选） 时间节点（标题） 正文内容 时间节点（标题） 正文内容 网站卡片标签xaoxuu简约风格 inkss这是一段关于这个网站的描述文字 MHuiG这是一段关于这个网站的描述文字 Colsrch这是一段关于这个网站的描述文字 Linhk1606这是一段关于这个网站的描述文字 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 查看列表测试 hahahehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha","categories":[{"name":"demo","slug":"demo","permalink":"http://www.sivan.tech/categories/demo/"}],"tags":[{"name":"demo","slug":"demo","permalink":"http://www.sivan.tech/tags/demo/"}],"author":"yirufeng"},{"title":"(LeetCode系列)刷题记","slug":"LeetCode系列-刷题记","date":"2099-06-06T11:08:18.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2099/06/06/LeetCode系列-刷题记/","link":"","permalink":"http://www.sivan.tech/2099/06/06/LeetCode%E7%B3%BB%E5%88%97-%E5%88%B7%E9%A2%98%E8%AE%B0/","excerpt":"在线阅读 查看对应源码","text":"在线阅读 查看对应源码","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"}],"author":"yirufeng"},{"title":"go微服务环境搭建","slug":"go微服务环境搭建","date":"2021-05-12T16:22:25.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/05/12/go微服务环境搭建/","link":"","permalink":"http://www.sivan.tech/2021/05/12/go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"本环境基于Macos搭建，运行的go版本是1.14.11，由于原先使用的1.15.5依赖包对应版本不存在或冲突修改后无法解决，所以只能修改go版本 沈逸老师go-micro搭建环境搭建成功使用命令: go get github.com/micro/go-micro/v2 go get github.com/micro/go-plugins/registry/consul/v2 参考：https://segmentfault.com/a/1190000023529475 搭建过程中遇到的问题：123456789# github.com/coreos/etcd/clientv3/balancer/resolver/endpoint../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption# github.com/coreos/etcd/clientv3/balancer/picker../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions# github.com/micro/go-micro/transport/quic../../../../../go/pkg/mod/github.com/micro/go-micro@v1.18.0/transport/quic/quic.go:54:12: q.s.Close undefined (type quic.Session has no field or method Close)../../../../../go/pkg/mod/github.com/micro/go-micro@v1.18.0/transport/quic/quic.go:121:3: unknown field &#x27;IdleTimeout&#x27; in struct literal of type quic.Config 解决办法：go.mod文件夹中加上下面两句话 12replace google.golang.org&#x2F;grpc &#x3D;&gt; google.golang.org&#x2F;grpc v1.26.0replace github.com&#x2F;lucas-clemente&#x2F;quic-go &#x3D;&gt; github.com&#x2F;lucas-clemente&#x2F;quic-go v0.14.1 参考： https://github.com/etcd-io/etcd/issues/12124#issuecomment-674368288 https://github.com/etcd-io/etcd/issues/11931 https://www.codenong.com/cs109250534/ 推荐：https://studygolang.com/articles/32791 遇到的问题2：panic: qtls.ConnectionState not compatible with tls.ConnectionState 最后以上的问题都采用一种策略，删除原有go版本并且下载go1.14.11版本得到了解决，之后执行命令go get -u github.com/micro/go-micro就是go的版本不要使用go1.15 租房网搭建环境：前言 如果网速很慢，经常io timeout，可以执行如下两条命令： 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 安装protoc 下载可执行文件 下载完成后，解压到~/Library，并修改文件夹名字为proto，并进入终端配置系统环境变量：export PATH=$PATH:$GOPATH/bin:$HOME/Library/protoc/bin 采用命令protoc --verison进行验证。配置成功，会有类似输出：libprotoc 3.11.2 安装protoc-gen-go go get -u github.com/golang/protobuf/protoc-gen-go 进入到目录：cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go 执行go build，生成可执行文件protoc-gen-go 将我们的可执行文件复制到$GOPATH/bin下：cp protoc-gen-go $GOPATH/bin 安装protoc-gen-micro 如果实在get不下来我们可以直接clone代码下来，然后go build go get github.com/micro/protoc-gen-micro 进入到$GOPATH/src/github.com/micro/protoc-gen-micro目录下，进行go build，生成可执行文件protoc-gen-micro 将我们的可执行文件复制到$GOPATH/bin下：cp protoc-gen-micro $GOPATH/bin 测试：在goland中新建一个项目，并且编写一个proto文件夹，编写demo.proto文件并填入如下内容 123456789101112131415161718192021222324252627282930313233343536373839syntax = &quot;proto3&quot;;package myproto;option go_package = &quot;./&quot;;//客户端发送给服务端的message HelloRequest &#123; string name = 1;&#125;//服务端返回给客户端的message HelloResponse &#123; string msg = 1;&#125;//客户端向服务端发送的请求message NameRequest &#123; string name = 1;&#125;//服务端返回给客户端的响应message NameResponse &#123; string msg = 1;&#125;//定义服务service HelloService &#123; //函数的传入和传出就是我们自己要定义的消息类型 //一个打招呼的函数 rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125; //一个说名字的函数 rpc SayName (NameRequest) returns (NameResponse) &#123;&#125;&#125; 进入到proto文件所在的目录，执行protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. *.proto当前目录下生成两个文件：demo.pb.go和demo.pb.micro.go 安装go-micro执行命令：go get github.com/micro/go-micro/v2@latest 安装micro方式一：执行命令：go get github.com/micro/micro/v2@latest 通过该方法安装的micro默认使用的服务发现组件是mdns，没有集成Consul、Etcd等第三方的组件。我们后面需要使用Consul，所以此时需要自己手动编译安装。 方式二： git clone https://github.com/micro/micro.git 进入到clone后的文件夹，新建plugins.go文件，键入如下内容：12345package mainimport ( _ &quot;github.com/micro/go-plugins/registry/consul/v2&quot;) 最后，重新编译安装：go install 完成后，执行如下命令检查micro是否安装成功：micro --version。如果有类似输出说明安装成功：1micro version 2.0.0 方法三：直接下载二进制文件 点击下载地址进行下载 将我们的micro可执行程序移动到/usr/local/bin/","text":"本环境基于Macos搭建，运行的go版本是1.14.11，由于原先使用的1.15.5依赖包对应版本不存在或冲突修改后无法解决，所以只能修改go版本 沈逸老师go-micro搭建环境搭建成功使用命令: go get github.com/micro/go-micro/v2 go get github.com/micro/go-plugins/registry/consul/v2 参考：https://segmentfault.com/a/1190000023529475 搭建过程中遇到的问题：123456789# github.com/coreos/etcd/clientv3/balancer/resolver/endpoint../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption# github.com/coreos/etcd/clientv3/balancer/picker../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions../../../../../go/pkg/mod/github.com/coreos/etcd@v3.3.25+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions# github.com/micro/go-micro/transport/quic../../../../../go/pkg/mod/github.com/micro/go-micro@v1.18.0/transport/quic/quic.go:54:12: q.s.Close undefined (type quic.Session has no field or method Close)../../../../../go/pkg/mod/github.com/micro/go-micro@v1.18.0/transport/quic/quic.go:121:3: unknown field &#x27;IdleTimeout&#x27; in struct literal of type quic.Config 解决办法：go.mod文件夹中加上下面两句话 12replace google.golang.org&#x2F;grpc &#x3D;&gt; google.golang.org&#x2F;grpc v1.26.0replace github.com&#x2F;lucas-clemente&#x2F;quic-go &#x3D;&gt; github.com&#x2F;lucas-clemente&#x2F;quic-go v0.14.1 参考： https://github.com/etcd-io/etcd/issues/12124#issuecomment-674368288 https://github.com/etcd-io/etcd/issues/11931 https://www.codenong.com/cs109250534/ 推荐：https://studygolang.com/articles/32791 遇到的问题2：panic: qtls.ConnectionState not compatible with tls.ConnectionState 最后以上的问题都采用一种策略，删除原有go版本并且下载go1.14.11版本得到了解决，之后执行命令go get -u github.com/micro/go-micro就是go的版本不要使用go1.15 租房网搭建环境：前言 如果网速很慢，经常io timeout，可以执行如下两条命令： 12go env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct 安装protoc 下载可执行文件 下载完成后，解压到~/Library，并修改文件夹名字为proto，并进入终端配置系统环境变量：export PATH=$PATH:$GOPATH/bin:$HOME/Library/protoc/bin 采用命令protoc --verison进行验证。配置成功，会有类似输出：libprotoc 3.11.2 安装protoc-gen-go go get -u github.com/golang/protobuf/protoc-gen-go 进入到目录：cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go 执行go build，生成可执行文件protoc-gen-go 将我们的可执行文件复制到$GOPATH/bin下：cp protoc-gen-go $GOPATH/bin 安装protoc-gen-micro 如果实在get不下来我们可以直接clone代码下来，然后go build go get github.com/micro/protoc-gen-micro 进入到$GOPATH/src/github.com/micro/protoc-gen-micro目录下，进行go build，生成可执行文件protoc-gen-micro 将我们的可执行文件复制到$GOPATH/bin下：cp protoc-gen-micro $GOPATH/bin 测试：在goland中新建一个项目，并且编写一个proto文件夹，编写demo.proto文件并填入如下内容 123456789101112131415161718192021222324252627282930313233343536373839syntax = &quot;proto3&quot;;package myproto;option go_package = &quot;./&quot;;//客户端发送给服务端的message HelloRequest &#123; string name = 1;&#125;//服务端返回给客户端的message HelloResponse &#123; string msg = 1;&#125;//客户端向服务端发送的请求message NameRequest &#123; string name = 1;&#125;//服务端返回给客户端的响应message NameResponse &#123; string msg = 1;&#125;//定义服务service HelloService &#123; //函数的传入和传出就是我们自己要定义的消息类型 //一个打招呼的函数 rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125; //一个说名字的函数 rpc SayName (NameRequest) returns (NameResponse) &#123;&#125;&#125; 进入到proto文件所在的目录，执行protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. *.proto当前目录下生成两个文件：demo.pb.go和demo.pb.micro.go 安装go-micro执行命令：go get github.com/micro/go-micro/v2@latest 安装micro方式一：执行命令：go get github.com/micro/micro/v2@latest 通过该方法安装的micro默认使用的服务发现组件是mdns，没有集成Consul、Etcd等第三方的组件。我们后面需要使用Consul，所以此时需要自己手动编译安装。 方式二： git clone https://github.com/micro/micro.git 进入到clone后的文件夹，新建plugins.go文件，键入如下内容：12345package mainimport ( _ &quot;github.com/micro/go-plugins/registry/consul/v2&quot;) 最后，重新编译安装：go install 完成后，执行如下命令检查micro是否安装成功：micro --version。如果有类似输出说明安装成功：1micro version 2.0.0 方法三：直接下载二进制文件 点击下载地址进行下载 将我们的micro可执行程序移动到/usr/local/bin/ consul环境搭建docker安装consul集群 自己动手采用docker搭建一个consul集群 123456789101112# 下载最新的consul镜像docker pull consul# 启动我们的第一个consul节点docker run --name consul1 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 2 -ui -bind=0.0.0.0 -client=0.0.0.0# 获取我们第一个启动节点的ip地址：会输出一个ip地址docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; consul1# 启动第二个consul节点docker run --name consul2 -d -p 8501:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 启动第三个consul节点docker run --name consul3 -d -p 8502:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 这里是第一个节点的ip地址# 查看运行的容器docker ps之后访问localhost:8050就可以进入到我们的consul可视化界面 本机(mac)安装consul： 直接进入consul官网，下载可执行文件，然后解压到$HOME/Library/consul/ 同时将路径加入到我们的系统环境变量~/.bash_profile中12# add consulexport PATH=$PATH:$GOPATH/bin:$HOME/Library/consul 然后刷新我们的配置，此时使用consul执行命令consul members来查看我们docker搭建的consul集群 consul相关命令补充： consul参考资料： 参考1 参考2 docker安装consul集群 遇到的问题 ：参考解决方案自己是在goland中新建一个Proto文件夹并编写了一个新的proto文件测试发现可以通过 References macOS配置Go Micro开发环境 “””画图： 打平的图 横坐标的每一个值都是一个三元组， 三元组的第1个值代表第1个通道的bin的内容， 一个是整体的图，所有图片的像素三元组都在这个线上 bin=4：画出四条线：HSV,HLS,YUV,YCrCb bin=8：画出四条线：HSV,HLS,YUV,YCrCb bin=16：画出四条线：HSV,HLS,YUV,YCrCb bin=32：画出四条线：HSV,HLS,YUV,YCrCb bin=64：画出四条线：HSV,HLS,YUV,YCrCb 另外几个是有bin分组的图: bin=4：画一个图，三条线的内容如下 好图： 普通： 效果不好： bin=8：画一个图，三条线的内容如下 好图： 普通： 效果不好： bin=16：画一个图，三条线的内容如下 好图： 普通： 效果不好： bin=32：画一个图，三条线的内容如下 好图： 普通： 效果不好 bin=64：画一个图，三条线的内容如下 好图： 普通： 效果不好 一共画10个图“””","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"环境搭建","slug":"微服务/环境搭建","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.sivan.tech/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"author":"yirufeng"},{"title":"微服务项目实战","slug":"微服务项目实战","date":"2021-05-10T09:23:10.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/05/10/微服务项目实战/","link":"","permalink":"http://www.sivan.tech/2021/05/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","excerpt":"","text":"微服务基础 微服务，微服务架构，微服务框架 微服务：应该使用这种方法而设计的一个应用，也就是设计出来的一个应用微服务架构：一种设计方法微服务框架（比如我们后面用到的micro）：将复杂的系统使用组件化的方式进行拆分，并且使用轻量级通讯方式进行整合的一种设计方法。微服务是通过这种架构设计方法拆分出来的一个独立的组件化的小应用。注意：这3个概念不一样 微服务架构与整体式架构的区别 单体式开发的缺点：复杂性逐渐变高技术债务逐渐上升维护成本大持续交付周期长可扩展性差 微服务架构的特点 ：这张图将我们的服务都拆分出来了，想使用哪个直接访问就可以了，不需要使用集中式的，每一个业务单独配置。单一职责：微服务架构中的每个服务，都是具有业务逻辑的，复合高内聚，低耦合的原则以及单一职责原则的单元，不同的服务通过管道的方式灵活组合，从而构建出庞大的系统轻量级通信：服务之间通过轻量级的通信机制实现互通互联，所谓的轻量级，通常是指语言无关、平台无关的交互方式。 ：restful是一种风格，满足了我们的rest这个规则 -&gt; ： 微服务架构的缺点 分布式微服务与传统的区别：为什么使用微服务架构：扩充业务：去掉影响的服务：![kR1L1D](https://cdn.jsdeliv r.net/gh/sivanWu0222/ImageHosting@master/uPic/kR1L1D.png)升级服务： 微服务课程的几个重要组件 跨语言，跨平台的通信：protobuf通信协议：gRPC服务的调度服务发现：consul微服务的框架：micro微服务部署：docker protobuf 了解 介绍：对比：protobuf的优点：protobuf的缺点：我们写一个.proto的文件，然后生成到不同语言对应的文件，比如go会生成.go的文件 protobuf安装 首先使用protoc -h测试是否安装获取proto包：go get -v -u github.com/golang/protobuf/proto 如果是离线安装，我们需要将下载的代码放置到src下面的github.com目录下，然后执行go build生成protoc-gen-go，将这个protoc-gen-go移动到/bin目录下安装protoc-gen-go插件：知识点：go get中-v与-u的作用-v :显示操作流程的日志及信息，方便检查错误-u 如果需要依赖的时候会下载依赖,也就是下载丢失的包，但不会更新已经存在的包 protobuf的基本语法 要使用protobuf必须得先定义proto文件，所以得先熟悉protobuf的消息定义的相关语法定义一个消息类型：1234567891011syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F;表明现在使用的是proto3的语法，如果不指定这个编译器将会使用proto2。这个指定的与发行必须是文件的非空非注释的第一行。option go_package &#x3D; &quot;.&#x2F;Message&quot;; &#x2F;&#x2F;指定将我们的go文件生成到哪个目录&#x2F;&#x2F;定义一个消息类型：消息定义中，每一个子弹都有唯一的一个标识符，也就是对应的序号message PandaRequest &#123; &#x2F;&#x2F;数据类型 变量名 &#x3D; 序号; string name &#x3D; 1; int32 height &#x3D; 2; &#x2F;&#x2F;repeated表示重复的，相当于golang里面的切片， &#x2F;&#x2F;repeated后面跟一个数据类型表示切片中元素的数据类型 repeated int32 weight &#x3D; 3;&#125;向proto文件中添加注释：可以使用//的语法格式。生成对应的语言的代码： + protoc --go_out指定生成的go的目录 proto文件所在的目录/生成go文件的proto文件 例如: protoc --go_out=./ ./proto/*.proto由于我们自己的环境与老师的不一样，我们还得在proto文件中加上这么一句话option go_package = &quot;./Message&quot;; //指定将我们的go文件生成到哪个目录，这个目录是相对于我们命令protoc中的参数go_out而言的相对目录数据类型： + + 如果有一些格式文件比较复杂，我们都建议用go语言的[]byte然后对应protobuf的bytes类型进行传输，相当好使，因为是二进制传输。 ，比如： 嵌套类型：定义服务(grpc的时候用到, grpc是rpc的一个升级版本)： , 传入的参数以及返回的参数都是我们的message +测试文件：将我们编写的proto编译成go文件编码并解码： + 一般流程：编写消息和服务 -&gt; 生成对应的go的代码 -&gt; 通过grpc来进行远程调用快捷键：command + b 快速进入到代码内部的实现中 rpc rpc的客户端与服务端 远程过程调用流程图： + 过程： go内部也是有一个rpc库的，我们可以直接使用， + + 注册： + 连接到网络： + 编写客户端： rpc的调用流程讲解 过程图：对着代码进行讲解：左边的建立连接返回一个cli句柄我们通过cli.call调用远程函数，并且带了传参和接收返回服务端注册完之后就会作为服务暴露出来，随之函数也就会被暴露出来，之后我们就可以通过rpc进行调用 rpc客户端代码 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;net/rpc&quot;)/** * @Author: yirufeng * @Date: 2021/5/10 10:05 上午 * @Desc: **/func main() &#123; cli, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:10086&quot;) defer cli.Close() if err != nil &#123; panic(err) &#125; var pd int err = cli.Call(&quot;Panda.GetInfo&quot;, 100, &amp;pd) if err != nil &#123; panic(err) &#125; fmt.Println(pd)&#125; rpc服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;net/http&quot; &quot;net/rpc&quot;)/** * @Author: yirufeng * @Date: 2021/5/10 10:05 上午 * @Desc: **/type Panda int//只有满足如下3个标准的方法才可以用于远程访问//1. 方法是可以导出的//2. 方法的第二个参数是指针//3. 方法只有一个error接口类型的返回值//方法的第一个参数表示调用者提供的参数，第二个参数代表返回给调用者的参数//方法的返回值如果不是nil，将会被作为字符串回传，在客户端看来与errors.New()创建的一样//如果返回了错误，回复的参数不会发送给客户端func (p *Panda) GetInfo(argType int, replyType *int) error &#123; fmt.Println(&quot;方法调用者传递过来的参数：&quot;, argType) //修改内容值 *replyType = argType + 100 return nil&#125;func main() &#123; //编写一个处理请求的handler http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, req *http.Request) &#123; io.WriteString(w, &quot;hello world!&quot;) &#125;) //实例化一个结构体的对象 pd := new(Panda) //服务端注册一个对象 rpc.Register(pd) rpc.HandleHTTP() ln, err := net.Listen(&quot;tcp&quot;, &quot;:10086&quot;) if err != nil &#123; panic(err) &#125; http.Serve(ln, nil)&#125; grpc grpc基本概念 grpc环境搭建 对于采用mod工具管理的项目：直接使用命令：go get google.golang.org/grpc来下载我们的grpc 客户端代码与服务端代码介绍 编写我们的protobuf协议的内容：1234567891011121314151617181920212223242526272829303132333435363738syntax = &quot;proto3&quot;;package myproto;option go_package = &quot;./myproto&quot;;//客户端发送给服务端的message HelloRequest &#123; string name = 1;&#125;//服务端返回给客户端的message HelloResponse &#123; string msg = 1;&#125;//客户端向服务端发送的请求message NameRequest &#123; string name = 1;&#125;//服务端返回给客户端的响应message NameResponse &#123; string msg = 1;&#125;//定义服务service HelloService &#123; //函数的传入和传出就是我们自己要定义的消息类型 //一个打招呼的函数 rpc SayHello (HelloRequest) returns (HelloResponse) &#123;&#125; //一个说名字的函数 rpc SayName (NameRequest) returns (NameResponse) &#123;&#125;&#125;我们使用protoc --go_out=. ./myproto/*.proto生成之后发现没有rpc对应的方法。我们需要插件进行生成：protoc --go_out=plugins=grpc:. ./myproto/*.proto。编写grpc服务端：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package main/** * @Author: yirufeng * @Date: 2021/5/10 4:34 下午 * @Desc: 手动写一个grpc_server **/import ( &quot;context&quot; &quot;fmt&quot; &quot;go-project/myproto&quot; &quot;google.golang.org/grpc&quot; &quot;net&quot;)type server struct &#123;&#125;func (this *server) SayHello(ctx context.Context, request *myproto.HelloRequest) (out *myproto.HelloResponse, err error) &#123; return &amp;myproto.HelloResponse&#123; Msg: &quot;你好,&quot; + request.Name, &#125;, nil&#125;func (this *server) SayName(ctx context.Context, request *myproto.NameRequest) (out *myproto.NameResponse, err error) &#123; return &amp;myproto.NameResponse&#123; Msg: &quot;你的名字是：&quot; + request.Name, &#125;, nil&#125;func main() &#123; //创建网络 ln, err := net.Listen(&quot;tcp&quot;, &quot;:10086&quot;) if err != nil &#123; fmt.Println(&quot;网络错误,&quot;, err) &#125; //创建grpc的服务 srv := grpc.NewServer() //注册服务 myproto.RegisterHelloServiceServer(srv, &amp;server&#123;&#125;) //监听网络并等待网络连接 err = srv.Serve(ln) if err != nil &#123; fmt.Println(&quot;网络错误：&quot;, err) &#125;&#125;编写grpc客户端：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;go-project/myproto&quot; &quot;google.golang.org/grpc&quot;)/** * @Author: yirufeng * @Date: 2021/5/10 4:53 下午 * @Desc: **/func main() &#123; //客户端连接服务器 conn, err := grpc.Dial(&quot;127.0.0.1:10086&quot;, grpc.WithInsecure()) if err != nil &#123; fmt.Println(&quot;网络异常：&quot;, err) &#125; //延迟关闭连接 defer conn.Close() //获得grpc的句柄 client := myproto.NewHelloServiceClient(conn) //通过句柄调用函数 //第一个参数是context，我们传一个默认的context就可以的 ret, err := client.SayHello(context.Background(), &amp;myproto.HelloRequest&#123; Name: &quot;yirufneg&quot;, &#125;) if err != nil &#123; fmt.Println(&quot;调用SayHello失败：&quot;, err) &#125; fmt.Println(&quot;调用SayHello的返回值：&quot;, ret) ret2, err := client.SayName(context.Background(), &amp;myproto.NameRequest&#123; Name: &quot;yirufneg&quot;, &#125;) if err != nil &#123; fmt.Println(&quot;调用SayName失败：&quot;, err) &#125; fmt.Println(&quot;调用SayName的返回值：&quot;, ret2)&#125;引申出的两个问题：客户端如果不写网路的话，肯定会找不到对应地址的服务端。如果服务端不启动的时候，客户端建立对话的时候肯定找不到。 了解服务发现之consul 背景 上节课的时候我们服务经常会遇到如下的问题：客户端连接服务器的时候，IP去掉将无法连接服务器：conn, err := grpc.Dial(&quot;127.0.0.1:10086&quot;, grpc.WithInsecure()如果先运行客户端再运行服务端，客户端将会报错。这些问题都需要解决，因此我们需要通过服务发现来解决这些问题 consul中的基本概念 通过服务发现来管理服务：consul的代码并没有开源故障检测使得如果有服务挂掉，之后请求的时候将会停止访问我们的服务一个简单的案例： 服务注册：就是服务主动去consul那里登记，服务发现就是指请求过来之后去consul那里查询对应的服务，此时就是服务发现 consul安装 命令：consul中的角色：client接收请求，然后将我们的请求转发给对应的server。server做配置保存以及高可用的集群，并在局域网内与我们的client进行通信，并且负责通过广域网与其他数据中心通讯。agent不是client就是server consul集群搭建 环境：3个虚拟机192.168.110.123192.168.110.148192.168.110.124步骤：192.168.110.123 主机执行命令：consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n1 -bind=192.168.110.123 -ui -config-dir /etc/consul.d -rejoin -join 192.168.110.123 -client 0.0.0.0 + 192.168.110.148 主机执行命令：consul agent -server -bootstrap-expect 2 -data-dir /tmp/consul -node=n2 -bind=192.168.110.148 -ui -rejoin -join 192.168.110.123 + ： + 访问：148机器访问：192.168.110.124主机执行命令： consul agent -data-dir /tmp/consul -node=n3 -bind=192.168.110.124 -config-dir /etc/consuld.d -rejoin -join 192.168.110.123 + 148机器访问：其他命令:查看集群成员： + 查看consul版本：consul version停止Agent：consul leave 用于退出集群 consul 服务注册 测试程序：在micro中我们不需要手动写consul的配置文件 consul扩展 consul架构图： 如果要跨域（图中的黑色）：通过网络进行连接。client不做信息持久化保存。 consul参考资料： 参考1 参考2 micro micro介绍 micro是一个分布式工具也是一个内部的组件 micro安装 补充：官方网站：自己下去可以看一下micro中文的文档go-micro默认是rpc，我们要用grpc进行一下升级 micro自己安装 micro环境搭建以及基本演示 + ![4elFlk](https://cdn.jsdelivr .net/gh/sivanWu0222/ImageHosting@master/uPic/4elFlk.png) ：我们可以用DOCKERFILE将我们的单个服务升级成对应的镜像 两个命令生成srv文件以及web文件 micro new --type &quot;srv&quot; day2/micro/rpc.webmicro new --type &quot;web&quot; day2/micro/rpc.web","categories":[],"tags":[],"author":"yirufeng"},{"title":"排序算法总结","slug":"排序算法总结","date":"2021-04-13T22:07:07.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/04/13/排序算法总结/","link":"","permalink":"http://www.sivan.tech/2021/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"基础排序算法选择排序冒泡排序直接插入排序 点击查看代码 1234567891011121314151617181920212223242526272829303132333435package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc: 选择排序时间复杂度：假设数组中有n个数字 大循环需要遍历n-2趟，然后每一个大循环中， 我们都需要从开始的数字一直到最后选出最小的数字(时间复杂度：O(n))，然后填充到当期那还没有排好序的起始位置最后总的时间复杂度：O(n^2)，空间复杂度：O(1)。稳定的排序算法（因为两个相等的数字前面那个一定是排序的时候第一个会被放置到前面的） **/func SelectedSort(nums []int) &#123; selectedSort(nums)&#125;func selectedSort(nums []int) &#123; var min int for i := 0; i &lt; len(nums)-1; i++ &#123; //每次从nums[i]开始起 min = i //依次与后面比对来选择最小的 for j := i + 1; j &lt; len(nums); j++ &#123; if nums[min] &gt; nums[j] &#123; min = j &#125; &#125; //交换nums[min]与nums[i] nums[i], nums[min] = nums[min], nums[i] &#125;&#125; 选择排序选择排序总结：时间复杂度：O(n^2)空间复杂度：O(1)。不稳定的排序算法（比如A 80 B 80 C 70 这三个卷子从小到大排序，最后将会变成CBA，但是稳定的应该是CAB）三个版本的冒泡排序： 最基本的 如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出 在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc:有好几个版本：1. 最基本的2. 如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出3. 在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了 **/func BubbleSort(nums []int) &#123; bubbleSortV2(nums)&#125;//最基本的func bubbleSortV1(nums []int) &#123; for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 for j := 0; j &lt; len(nums)-i; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125;//如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出func bubbleSortV2(nums []int) &#123; //表示某一趟是否有元素交换 flag := true for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 flag = true for j := 0; j &lt; len(nums)-i; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; flag, nums[j], nums[j+1] = false, nums[j+1], nums[j] &#125; &#125; //如果没有元素交换，说明已经有序，直接退出即可 if flag &#123; break &#125; &#125;&#125;//在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了//使用一个变量记录最后发生交换的位置，说明该位置之后都是有序的func bubbleSortV3(nums []int) &#123; //表示某一趟是否有元素交换 flag := true //表示最后发生交换的位置 //注意点1:这里必须再额外使用临时变量，因为如果只是用一个变量lastSwapPos的话， //lastSwapPos的值会一直改变，因此如果一旦变小，我们的for循环就会推出 lastSwapPos := len(nums) - 1 //注意点2：初始值赋值是len(nums) - 1 for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 lastSwapPosTemp := len(nums) - i //注意点3：初始值赋值是len(nums) - i flag = true //下次遍历的时候遍历到我们上次最后发生交换的位置就可以了 for j := 0; j &lt; lastSwapPos; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; flag, nums[j], nums[j+1], lastSwapPosTemp = false, nums[j+1], nums[j], j //注意点4：这里lastSwapPosTemp应该赋值j，因为j与j+1比较过了，所以就认为j之后是已经有序的了 &#125; &#125; //如果没有元素交换，说明已经有序，直接退出即可 if flag &#123; break &#125; lastSwapPos = lastSwapPosTemp &#125;&#125; 冒泡排序冒泡排序总结：时间复杂度：O(n^2)，最好是O(n)空间复杂度：O(1)。稳定 点击查看代码 12345678910111213141516171819202122232425262728293031package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc:时间复杂度：O(n^2)空间复杂度：O(1)稳定的：因为是到前面找到一个小于等于自己的后面那个位置 **/func InsertSort(nums []int) &#123; insertSort(nums)&#125;func insertSort(nums []int) &#123; var j int //第一个元素已经有序，只需要插入后面的元素即可 for i := 1; i &lt; len(nums); i++ &#123; //当前要插入的元素目前位于i位置 cur := nums[i] //从后往前找，直到前面元素小于当前元素就停，并且遍历的过程中不断将前面的元素移动到后面 for j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; cur; j-- &#123; nums[j+1] = nums[j] &#125; //此时j指向的元素就是前面那个小于或者等于当前元素的位置 //但是我们应该在j+1位置插入 nums[j+1] = cur &#125;&#125; 直接插入排序总结直接插入排序总结：时间复杂度：O(n^2)，空间复杂度：O(1)。稳定的：因为是到前面找到一个小于等于自己的后面那个位置 进阶排序算法归并排序从小到大的堆排序从大到小的堆排序快速排序希尔排序 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package advanced_sortimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:31 下午 * @Desc: 归并排序 **/func MergeSort(nums []int) &#123; mergeSort(nums, 0, len(nums)-1)&#125;func mergeSort(nums []int, l, r int) &#123; if l == r &#123; return &#125; //找到中间点，一分为二 mid := l + (r-l)&gt;&gt;1 //划分成左右两个有序的空间 mergeSort(nums, l, mid) mergeSort(nums, mid+1, r) //将左右两部分以mid为划分轴进行合并 merge(nums, l, mid, r)&#125;//合并nums[l:mid+1] 与 nums[mid+1:r+1]两部分内容func merge(nums []int, l, mid, r int) &#123; i, j := l, mid+1 cur := 0 //注意点1：这里必须借助一个数组，否则我们前面可能还没有被排序的结果会被我们后半部分的内容覆盖掉，导致前面就没有内容 help := make([]int, r-l+1) for i &lt;= mid &amp;&amp; j &lt;= r &#123; if nums[i] &lt; nums[j] &#123; help[cur], cur, i = nums[i], cur+1, i+1 &#125; else &#123; help[cur], cur, j = nums[j], cur+1, j+1 &#125; &#125; for i &lt;= mid &#123; help[cur], cur, i = nums[i], cur+1, i+1 &#125; for j &lt;= r &#123; help[cur], cur, j = nums[j], cur+1, j+1 &#125; //最后记得我们的help数组中的内容要放回到我们的原来的数组中 for i := 0; i &lt; len(help); i++ &#123; nums[l+i] = help[i] &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 30) fmt.Println(nums) temp := make([]int, 30) copy(temp, nums) sort.Ints(temp) MergeSort(nums) fmt.Println(temp) fmt.Println(nums)&#125; 归并排序时间复杂度：O(nlogN) 最好最坏都是O(NlogN)空间复杂度：O(n)。需要一个辅助空间是否稳定：稳定的（因为一旦两个数相等我们就不比较，并且每次都是前半部分与后半部分进行比较，所以前面同样的内容与后面同样的内容的相对位置不会改变） 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;log&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:29 下午 * @Desc: 从小到大的堆排序(需要建立一个大顶堆)从小到大排序需要建立一个大顶堆，因为我们建立好大顶堆之后，每次从堆头开始排除元素，然后都会将堆头放到目前数组的最后位置，最后位置会不断缩小，因此我们最后的位置就是一个不断往前移动的过程，从而就是说我们得到的整个数组是从小到大的 **/func HeapSort(nums []int) &#123; heapSort(nums)&#125;func heapSort(nums []int) &#123; if nums == nil || len(nums) &lt; 2 &#123; return &#125; for i := 0; i &lt; len(nums); i++ &#123; heapPush(nums, i) &#125; log.Println(&quot;建堆完成---------------&gt;&quot;, nums) heapSize := len(nums) //之后不断吐出元素 for heapSize &gt; 0 &#123; nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] heapSize-- heapify(nums, heapSize) &#125;&#125;//表示当前要加入的是nums中的索引为index的元素func heapPush(nums []int, index int) &#123; for (index-1)&gt;&gt;1 &gt;= 0 &amp;&amp; nums[index] &gt; nums[(index-1)&gt;&gt;1] &#123; nums[index], nums[(index-1)&gt;&gt;1], index = nums[(index-1)&gt;&gt;1], nums[index], (index-1)&gt;&gt;1 &#125;&#125;//length 表示堆的元素个数func heapify(nums []int, length int) &#123; index := 0 // (index &lt;&lt; 1 + 1) &lt; length 说明是有左子树的 for (index&lt;&lt;1 + 1) &lt; length &#123; //思路：每次找到左右孩子中更大的与父进行交换 left := index&lt;&lt;1 + 1 //如果有右子树并且右子树比左子树大 if left+1 &lt; length &amp;&amp; nums[left+1] &gt; nums[left] &#123; left++ &#125; //如果当前节点比左右孩子中大的大，就不交换 if nums[left] &lt;= nums[index] &#123; break &#125; //如果当前节点比左右孩子中大的小，交换当前节点与左右孩子中较大的 //同时让index变为left nums[left], nums[index], index = nums[index], nums[left], left &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 50) temp := make([]int, 50) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) HeapSort(nums) fmt.Println(nums)&#125; 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/15 2:20 下午 * @Desc: 从大到小的排序，需要建立一个小顶堆 **/func HeapSort(nums []int) &#123; heapSort(nums)&#125;func heapSort(nums []int) &#123; //如果nums为空或者元素个数小于两个，可以直接退出 if nums == nil || len(nums) &lt; 2 &#123; return &#125; //此时我们需要不断将元素加入我们的堆中 for i := 1; i &lt; len(nums); i++ &#123; heapInsert(nums, i) &#125; //获取堆的大小 heapSize := len(nums) //此时我们不断将堆里面的元素弹出放到应该放置的位置 for heapSize &gt; 0 &#123; //将堆的最后一个元素与堆顶交换 nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] //堆的元素个数减去1 heapSize-- //开始从堆顶从上往下开始调整堆 heapAdjustFromTopToBottom(nums, heapSize-1) // 从下到上的堆调整 &#125;&#125;//第二个参数表示插入的元素位于nums的位置func heapInsert(nums []int, index int) &#123; //不断比较当前插入的位置的元素与父节点的大小，如果比父节点小就交换 for (index-1)&gt;&gt;1 &gt;= 0 &amp;&amp; nums[(index-1)&gt;&gt;1] &gt; nums[index] &#123; nums[index], nums[(index-1)&gt;&gt;1], index = nums[(index-1)&gt;&gt;1], nums[index], (index-1)&gt;&gt;1 &#125;&#125;//第二个参数表示当前堆的元素个数func heapAdjustFromTopToBottom(nums []int, length int) &#123; index := 0 for index&lt;&lt;1+1 &lt; length &#123; left := index&lt;&lt;1 + 1 //如果有右孩子并且右比左小 if left+1 &lt; length &amp;&amp; nums[left+1] &lt; nums[left] &#123; left++ &#125; //当前节点小于等于两个孩子较小的 if nums[index] &lt;= nums[left] &#123; break &#125; nums[index], nums[left], index = nums[left], nums[index], left &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 50) temp := make([]int, 50) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) HeapSort(nums) fmt.Println(nums)&#125; 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:31 下午 * @Desc: 从小到大的快速排序 **/func QuickSort(nums []int) &#123; quickSort(nums, 0, len(nums)-1)&#125;//表示对[l,r]的元素进行快排func quickSort(nums []int, l, r int) &#123; if l &lt; r &#123; //在[l,r]区间内生成一个随机数作为划分 index := rand.Intn(r-l+1) + l //每次都把我们随机选择的元素交换到最后 nums[index], nums[r] = nums[r], nums[index] //进行划分，得到两个相等的区间 less, more := partition(nums, l, r) //继续对小于和大于的两个区间进行快速排序 quickSort(nums, l, less-1) quickSort(nums, more+1, r) &#125;&#125;//返回两个结果是等于我们随机数的区间的左端点和右端点func partition(nums []int, l, r int) (int, int) &#123; //使用nums[r]作为一个划分 less, more := l-1, r num := nums[r] cur := l for cur &lt; more &#123; if nums[cur] &lt; num &#123; nums[less+1], nums[cur], less, cur = nums[cur], nums[less+1], less+1, cur+1 &#125; else if nums[cur] &gt; num &#123; nums[more-1], nums[cur], more = nums[less+1], nums[more-1], more-1 &#125; else if nums[cur] == num &#123; more++ &#125; &#125; nums[more], nums[r] = nums[r], nums[more] //每次随机择一个划分点 return less + 1, more - 1&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 10) fmt.Println(nums) temp := make([]int, 10) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) QuickSort(nums) fmt.Println(nums)&#125; 快速排序思路：采用荷兰国旗的问题进行划分，每次可以划分为3个区间，分别是小于，等于以及大于的区间。时间复杂度：O(nlogN) 最好是O(nlogN) 最坏是O(n^2)空间复杂度：O(n)。是否稳定：不稳定！！！","text":"基础排序算法选择排序冒泡排序直接插入排序 点击查看代码 1234567891011121314151617181920212223242526272829303132333435package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc: 选择排序时间复杂度：假设数组中有n个数字 大循环需要遍历n-2趟，然后每一个大循环中， 我们都需要从开始的数字一直到最后选出最小的数字(时间复杂度：O(n))，然后填充到当期那还没有排好序的起始位置最后总的时间复杂度：O(n^2)，空间复杂度：O(1)。稳定的排序算法（因为两个相等的数字前面那个一定是排序的时候第一个会被放置到前面的） **/func SelectedSort(nums []int) &#123; selectedSort(nums)&#125;func selectedSort(nums []int) &#123; var min int for i := 0; i &lt; len(nums)-1; i++ &#123; //每次从nums[i]开始起 min = i //依次与后面比对来选择最小的 for j := i + 1; j &lt; len(nums); j++ &#123; if nums[min] &gt; nums[j] &#123; min = j &#125; &#125; //交换nums[min]与nums[i] nums[i], nums[min] = nums[min], nums[i] &#125;&#125; 选择排序选择排序总结：时间复杂度：O(n^2)空间复杂度：O(1)。不稳定的排序算法（比如A 80 B 80 C 70 这三个卷子从小到大排序，最后将会变成CBA，但是稳定的应该是CAB）三个版本的冒泡排序： 最基本的 如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出 在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc:有好几个版本：1. 最基本的2. 如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出3. 在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了 **/func BubbleSort(nums []int) &#123; bubbleSortV2(nums)&#125;//最基本的func bubbleSortV1(nums []int) &#123; for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 for j := 0; j &lt; len(nums)-i; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125;//如果某次冒泡的时候没有交换元素，那么说明这一趟以及后面的元素都是有序的，之后后面我们就不再需要进行冒泡，可以直接退出func bubbleSortV2(nums []int) &#123; //表示某一趟是否有元素交换 flag := true for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 flag = true for j := 0; j &lt; len(nums)-i; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; flag, nums[j], nums[j+1] = false, nums[j+1], nums[j] &#125; &#125; //如果没有元素交换，说明已经有序，直接退出即可 if flag &#123; break &#125; &#125;&#125;//在第二种改进的基础上再使用一个变量，表示我们最后交换的位置，下次遍历到这个位置就可以了//使用一个变量记录最后发生交换的位置，说明该位置之后都是有序的func bubbleSortV3(nums []int) &#123; //表示某一趟是否有元素交换 flag := true //表示最后发生交换的位置 //注意点1:这里必须再额外使用临时变量，因为如果只是用一个变量lastSwapPos的话， //lastSwapPos的值会一直改变，因此如果一旦变小，我们的for循环就会推出 lastSwapPos := len(nums) - 1 //注意点2：初始值赋值是len(nums) - 1 for i := 1; i &lt; len(nums); i++ &#123; //冒泡的次数 lastSwapPosTemp := len(nums) - i //注意点3：初始值赋值是len(nums) - i flag = true //下次遍历的时候遍历到我们上次最后发生交换的位置就可以了 for j := 0; j &lt; lastSwapPos; j++ &#123; //如果前面比后面大就交换 if nums[j] &gt; nums[j+1] &#123; flag, nums[j], nums[j+1], lastSwapPosTemp = false, nums[j+1], nums[j], j //注意点4：这里lastSwapPosTemp应该赋值j，因为j与j+1比较过了，所以就认为j之后是已经有序的了 &#125; &#125; //如果没有元素交换，说明已经有序，直接退出即可 if flag &#123; break &#125; lastSwapPos = lastSwapPosTemp &#125;&#125; 冒泡排序冒泡排序总结：时间复杂度：O(n^2)，最好是O(n)空间复杂度：O(1)。稳定 点击查看代码 12345678910111213141516171819202122232425262728293031package basic_sort/** * @Author: yirufeng * @Date: 2021/4/13 8:28 下午 * @Desc:时间复杂度：O(n^2)空间复杂度：O(1)稳定的：因为是到前面找到一个小于等于自己的后面那个位置 **/func InsertSort(nums []int) &#123; insertSort(nums)&#125;func insertSort(nums []int) &#123; var j int //第一个元素已经有序，只需要插入后面的元素即可 for i := 1; i &lt; len(nums); i++ &#123; //当前要插入的元素目前位于i位置 cur := nums[i] //从后往前找，直到前面元素小于当前元素就停，并且遍历的过程中不断将前面的元素移动到后面 for j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; cur; j-- &#123; nums[j+1] = nums[j] &#125; //此时j指向的元素就是前面那个小于或者等于当前元素的位置 //但是我们应该在j+1位置插入 nums[j+1] = cur &#125;&#125; 直接插入排序总结直接插入排序总结：时间复杂度：O(n^2)，空间复杂度：O(1)。稳定的：因为是到前面找到一个小于等于自己的后面那个位置 进阶排序算法归并排序从小到大的堆排序从大到小的堆排序快速排序希尔排序 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package advanced_sortimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:31 下午 * @Desc: 归并排序 **/func MergeSort(nums []int) &#123; mergeSort(nums, 0, len(nums)-1)&#125;func mergeSort(nums []int, l, r int) &#123; if l == r &#123; return &#125; //找到中间点，一分为二 mid := l + (r-l)&gt;&gt;1 //划分成左右两个有序的空间 mergeSort(nums, l, mid) mergeSort(nums, mid+1, r) //将左右两部分以mid为划分轴进行合并 merge(nums, l, mid, r)&#125;//合并nums[l:mid+1] 与 nums[mid+1:r+1]两部分内容func merge(nums []int, l, mid, r int) &#123; i, j := l, mid+1 cur := 0 //注意点1：这里必须借助一个数组，否则我们前面可能还没有被排序的结果会被我们后半部分的内容覆盖掉，导致前面就没有内容 help := make([]int, r-l+1) for i &lt;= mid &amp;&amp; j &lt;= r &#123; if nums[i] &lt; nums[j] &#123; help[cur], cur, i = nums[i], cur+1, i+1 &#125; else &#123; help[cur], cur, j = nums[j], cur+1, j+1 &#125; &#125; for i &lt;= mid &#123; help[cur], cur, i = nums[i], cur+1, i+1 &#125; for j &lt;= r &#123; help[cur], cur, j = nums[j], cur+1, j+1 &#125; //最后记得我们的help数组中的内容要放回到我们的原来的数组中 for i := 0; i &lt; len(help); i++ &#123; nums[l+i] = help[i] &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 30) fmt.Println(nums) temp := make([]int, 30) copy(temp, nums) sort.Ints(temp) MergeSort(nums) fmt.Println(temp) fmt.Println(nums)&#125; 归并排序时间复杂度：O(nlogN) 最好最坏都是O(NlogN)空间复杂度：O(n)。需要一个辅助空间是否稳定：稳定的（因为一旦两个数相等我们就不比较，并且每次都是前半部分与后半部分进行比较，所以前面同样的内容与后面同样的内容的相对位置不会改变） 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;log&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:29 下午 * @Desc: 从小到大的堆排序(需要建立一个大顶堆)从小到大排序需要建立一个大顶堆，因为我们建立好大顶堆之后，每次从堆头开始排除元素，然后都会将堆头放到目前数组的最后位置，最后位置会不断缩小，因此我们最后的位置就是一个不断往前移动的过程，从而就是说我们得到的整个数组是从小到大的 **/func HeapSort(nums []int) &#123; heapSort(nums)&#125;func heapSort(nums []int) &#123; if nums == nil || len(nums) &lt; 2 &#123; return &#125; for i := 0; i &lt; len(nums); i++ &#123; heapPush(nums, i) &#125; log.Println(&quot;建堆完成---------------&gt;&quot;, nums) heapSize := len(nums) //之后不断吐出元素 for heapSize &gt; 0 &#123; nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] heapSize-- heapify(nums, heapSize) &#125;&#125;//表示当前要加入的是nums中的索引为index的元素func heapPush(nums []int, index int) &#123; for (index-1)&gt;&gt;1 &gt;= 0 &amp;&amp; nums[index] &gt; nums[(index-1)&gt;&gt;1] &#123; nums[index], nums[(index-1)&gt;&gt;1], index = nums[(index-1)&gt;&gt;1], nums[index], (index-1)&gt;&gt;1 &#125;&#125;//length 表示堆的元素个数func heapify(nums []int, length int) &#123; index := 0 // (index &lt;&lt; 1 + 1) &lt; length 说明是有左子树的 for (index&lt;&lt;1 + 1) &lt; length &#123; //思路：每次找到左右孩子中更大的与父进行交换 left := index&lt;&lt;1 + 1 //如果有右子树并且右子树比左子树大 if left+1 &lt; length &amp;&amp; nums[left+1] &gt; nums[left] &#123; left++ &#125; //如果当前节点比左右孩子中大的大，就不交换 if nums[left] &lt;= nums[index] &#123; break &#125; //如果当前节点比左右孩子中大的小，交换当前节点与左右孩子中较大的 //同时让index变为left nums[left], nums[index], index = nums[index], nums[left], left &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 50) temp := make([]int, 50) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) HeapSort(nums) fmt.Println(nums)&#125; 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/15 2:20 下午 * @Desc: 从大到小的排序，需要建立一个小顶堆 **/func HeapSort(nums []int) &#123; heapSort(nums)&#125;func heapSort(nums []int) &#123; //如果nums为空或者元素个数小于两个，可以直接退出 if nums == nil || len(nums) &lt; 2 &#123; return &#125; //此时我们需要不断将元素加入我们的堆中 for i := 1; i &lt; len(nums); i++ &#123; heapInsert(nums, i) &#125; //获取堆的大小 heapSize := len(nums) //此时我们不断将堆里面的元素弹出放到应该放置的位置 for heapSize &gt; 0 &#123; //将堆的最后一个元素与堆顶交换 nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] //堆的元素个数减去1 heapSize-- //开始从堆顶从上往下开始调整堆 heapAdjustFromTopToBottom(nums, heapSize-1) // 从下到上的堆调整 &#125;&#125;//第二个参数表示插入的元素位于nums的位置func heapInsert(nums []int, index int) &#123; //不断比较当前插入的位置的元素与父节点的大小，如果比父节点小就交换 for (index-1)&gt;&gt;1 &gt;= 0 &amp;&amp; nums[(index-1)&gt;&gt;1] &gt; nums[index] &#123; nums[index], nums[(index-1)&gt;&gt;1], index = nums[(index-1)&gt;&gt;1], nums[index], (index-1)&gt;&gt;1 &#125;&#125;//第二个参数表示当前堆的元素个数func heapAdjustFromTopToBottom(nums []int, length int) &#123; index := 0 for index&lt;&lt;1+1 &lt; length &#123; left := index&lt;&lt;1 + 1 //如果有右孩子并且右比左小 if left+1 &lt; length &amp;&amp; nums[left+1] &lt; nums[left] &#123; left++ &#125; //当前节点小于等于两个孩子较小的 if nums[index] &lt;= nums[left] &#123; break &#125; nums[index], nums[left], index = nums[left], nums[index], left &#125;&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 50) temp := make([]int, 50) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) HeapSort(nums) fmt.Println(nums)&#125; 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;algos/模板/排序/util&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;sort&quot;)/** * @Author: yirufeng * @Date: 2021/4/14 3:31 下午 * @Desc: 从小到大的快速排序 **/func QuickSort(nums []int) &#123; quickSort(nums, 0, len(nums)-1)&#125;//表示对[l,r]的元素进行快排func quickSort(nums []int, l, r int) &#123; if l &lt; r &#123; //在[l,r]区间内生成一个随机数作为划分 index := rand.Intn(r-l+1) + l //每次都把我们随机选择的元素交换到最后 nums[index], nums[r] = nums[r], nums[index] //进行划分，得到两个相等的区间 less, more := partition(nums, l, r) //继续对小于和大于的两个区间进行快速排序 quickSort(nums, l, less-1) quickSort(nums, more+1, r) &#125;&#125;//返回两个结果是等于我们随机数的区间的左端点和右端点func partition(nums []int, l, r int) (int, int) &#123; //使用nums[r]作为一个划分 less, more := l-1, r num := nums[r] cur := l for cur &lt; more &#123; if nums[cur] &lt; num &#123; nums[less+1], nums[cur], less, cur = nums[cur], nums[less+1], less+1, cur+1 &#125; else if nums[cur] &gt; num &#123; nums[more-1], nums[cur], more = nums[less+1], nums[more-1], more-1 &#125; else if nums[cur] == num &#123; more++ &#125; &#125; nums[more], nums[r] = nums[r], nums[more] //每次随机择一个划分点 return less + 1, more - 1&#125;func main() &#123; nums := util.GenerateRandomNums(0, 100, 10) fmt.Println(nums) temp := make([]int, 10) copy(temp, nums) sort.Ints(temp) fmt.Println(temp) QuickSort(nums) fmt.Println(nums)&#125; 快速排序思路：采用荷兰国旗的问题进行划分，每次可以划分为3个区间，分别是小于，等于以及大于的区间。时间复杂度：O(nlogN) 最好是O(nlogN) 最坏是O(n^2)空间复杂度：O(n)。是否稳定：不稳定！！！ 外部排序算法桶排序基数排序计数排序 总结","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.sivan.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.sivan.tech/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://www.sivan.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://www.sivan.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://www.sivan.tech/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"直接插入排序","slug":"直接插入排序","permalink":"http://www.sivan.tech/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"饶大文章汇总","slug":"饶大文章汇总","date":"2021-04-07T20:34:03.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/04/07/饶大文章汇总/","link":"","permalink":"http://www.sivan.tech/2021/04/07/%E9%A5%B6%E5%A4%A7%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/","excerpt":"饶大文章汇总Go语言 深度解密系列 深度解密Go语言之Slice深度解密Go语言之sync.map深度解密Go语言之channel深度解密Go语言之context深度解密Go语言之unsafe深度解密Go语言之map深度解密Go语言之反射深度解密Go语言之关于 interface 的 10 个问题深度解密Go语言之scheduler深度解密Go语言之pprof深度解密Go语言之sync.pool Go语言其他 三足鼎立 —— GPM 到底是什么？（一）开天辟地 —— Go scheduler 初始化（二）粉墨登场 —— main goroutine 的诞生（三）偷天换日 —— g0 栈和用户栈如何完成切换？（四）新官上任 —— Go sheduler 开始调度循环（五）千难万险 —— goroutine 从生到死（六）生生世世 —— schedule 的轮回（七）锲而不舍 —— M 是怎样找工作的？（八）忠于职守 —— sysmon 线程到底做了什么？（九）意犹未尽 —— GPM 的状态流转（十）Golang error 的突围Go GC 20 问defer 链如何被遍历执行defer 的前世今生聊聊 g0Go 协作与抢占Go Modules 的智障版本选择惊！空 struct 地址竟然不相等fasthttp 快在哪里深度阅读之《Concurrency in Go》(内含饶大微信和内推)在 Go 语言中 Patch 非导出函数极端情况下收缩 Go 进程的线程数Go channel 的妙用[译]提案：在Go语言中增加对持久化内存的支持那些年曹大写过的博客Go http client 连接池不复用的问题Go pprof 快速分析 CPU 高负载问题Go 语言应用之 templateGo 程序是怎样跑起来的曹大谈内存重排图解Go语言内存分配Golang之变量去哪儿Golang之轻松化解defer的温柔陷阱","text":"饶大文章汇总Go语言 深度解密系列 深度解密Go语言之Slice深度解密Go语言之sync.map深度解密Go语言之channel深度解密Go语言之context深度解密Go语言之unsafe深度解密Go语言之map深度解密Go语言之反射深度解密Go语言之关于 interface 的 10 个问题深度解密Go语言之scheduler深度解密Go语言之pprof深度解密Go语言之sync.pool Go语言其他 三足鼎立 —— GPM 到底是什么？（一）开天辟地 —— Go scheduler 初始化（二）粉墨登场 —— main goroutine 的诞生（三）偷天换日 —— g0 栈和用户栈如何完成切换？（四）新官上任 —— Go sheduler 开始调度循环（五）千难万险 —— goroutine 从生到死（六）生生世世 —— schedule 的轮回（七）锲而不舍 —— M 是怎样找工作的？（八）忠于职守 —— sysmon 线程到底做了什么？（九）意犹未尽 —— GPM 的状态流转（十）Golang error 的突围Go GC 20 问defer 链如何被遍历执行defer 的前世今生聊聊 g0Go 协作与抢占Go Modules 的智障版本选择惊！空 struct 地址竟然不相等fasthttp 快在哪里深度阅读之《Concurrency in Go》(内含饶大微信和内推)在 Go 语言中 Patch 非导出函数极端情况下收缩 Go 进程的线程数Go channel 的妙用[译]提案：在Go语言中增加对持久化内存的支持那些年曹大写过的博客Go http client 连接池不复用的问题Go pprof 快速分析 CPU 高负载问题Go 语言应用之 templateGo 程序是怎样跑起来的曹大谈内存重排图解Go语言内存分配Golang之变量去哪儿Golang之轻松化解defer的温柔陷阱 其他系列 其他系列 三次握手，四次挥手”你真的懂吗？深度解密HTTP通信细节一个字节的网络漫游故事独白如何打造一份优雅的简历？中台的末路“���”引发的线上事故无人值守的自动 dump（一）无人值守的自动 dump（二）初级程序员常犯错误一览我的博客变迁史高并发服务遇 redis 瓶颈引发的事故写一个 panic blame 机器人事故现场之依赖了不该依赖的 host ip一个 bad file descriptor 的问题","categories":[{"name":"汇总","slug":"汇总","permalink":"http://www.sivan.tech/categories/%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"大牛","slug":"大牛","permalink":"http://www.sivan.tech/tags/%E5%A4%A7%E7%89%9B/"},{"name":"阅读清单","slug":"阅读清单","permalink":"http://www.sivan.tech/tags/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"}],"author":"yirufeng"},{"title":"mysql中的索引","slug":"mysql中的索引常见面试题","date":"2021-04-06T10:44:13.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/04/06/mysql中的索引常见面试题/","link":"","permalink":"http://www.sivan.tech/2021/04/06/mysql%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"查看代码测试 索引参考参考了解索引（索引概念）索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B数及其变种B+数。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。mysql索引的数据结构以及分类类似问题： 数据库索引结构是什么样的（我回答B+树，然后问对磁盘有什么优势夺命追问，我说降低IO次数，问为什么）类似问题： 数据库使用b+树的好处类似问题： b+树的特性，为啥要用到这类似问题： B+ Tree类似问题： 谈谈索引的数据结构？说了 B+树类似问题： B+树和 B-树的区别以及优点？类似问题： 为什么不用搜索树？类似问题： B+树的特点类似问题： mysql 索引 2次类似问题：mysql索引结构。从数据结构的角度看，常用的索引可以分为full-text索引，hash索引,b+树索引：在创建表时，InnoDB 存储引擎默认使用表的主键作为主键索引，该主键索引就是聚簇索引（Clustered Index），如果表没有定义主键，InnoDB 就自己产生一个隐藏的 6 个字节的主键 ID 值作为主键索引，而创建的主键索引默认使用的是 B+Tree 索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率。B+树和B树的明显区别：+树的叶子节点从左到右都是链接起来的，并且从左到右依次增大。解决了这个回旋查找的问题，这也是为什么我们排序的时候最好使用索引排序，因为索引帮助我们排好序了。B+树中非叶子节点的key都会在叶子节点中可以找到的，B+树非叶子节点只存储key，不存储value。叶子节点既存key又存value，value是对应数据的地址。在B树中，每个节点的value保存的是对应数据的地址。所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。那么问题来了，如果你当前查询数据时候，不是通过主键 ID，而是用商品编码查询商品，那么查询过程又是怎样的呢？通过非主键（辅助索引）查询商品数据的过程：如果你用商品编码查询商品（即使用辅助索引进行查询），会先检索辅助索引中的 B+Tree 的 商品编码，找到对应的叶子节点，获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫回表。以上就是索引的实现原理。如果你被问到“为什么 MySQL 会选择 B+Tree 当索引数据结构？”其实在考察你两个方面： B+Tree 的索引原理； B+Tree 索引相比于其他索引类型的优势。我们刚刚已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于其他常见索引结构，如 B 树、二叉树或 Hash 索引结构的优势在哪儿？B+Tree 相对于 B 树 索引结构的优势：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。B树在同样节点个数的情况下可以做到更低的树高 ，解决了树的高度的问题，更低的树高对应更低的磁盘IO次数。但是B树也是存在回旋查找（往回找）问题的，比如，这里要查找大于5的， 如果问到为什么可以降低IO次数，可以看该B树存储的图： B+Tree 相对于二叉树索引结构的优势对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 34 层左右，也就是说一次数据查询操作只需要做 34 次的磁盘 I/O 操作就能查询到目标数据（这里的查询参考上面 B+Tree 的聚簇索引的查询过程）。而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。但是实际上大多数的数据库存储却并不使用二叉树。其原因是：索引不止存在内存中，还要写到磁盘上。你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。B+Tree 相对于 Hash 表存储结构的优势我们知道范围查询是 MySQL 中常见的场景，因为hash的值是无序的，因为无序就不能进行范围查找。所以Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。还有就是我们排序的时候无法根据hash值进行排序，因为hash值是无序的。还有的就是hash冲突可能造成性能退化到O(N)总结：至此，你就知道“为什么 MySQL 会选择 B+Tree 来做索引”了。在回答时，你要着眼于 B+Tree 的优势，然后再引入索引原理的查询过程（掌握这些知识点，这个问题其实比较容易回答）。B+Tree 相对于 AVL树存储结构的优势avl树查找的话，查找速度随着高度增加会越来越慢。还有一个致命缺点：比如查找大于某一个值的数据，我们不仅仅在该值对应的右节点比他大，还要往回找。比如下图中查找大于6的：B+Tree 相对于 平衡二叉树树存储结构的优势B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;总结：B+树彻底解决了这个回旋查找的问题，如上图所示的B+树中，我们可以发现，B+树的所有非叶子节点最终都会存在叶子节点。B+Tree 相对于有序数组的优势如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，有序数组索引只适用于静态存储引擎参考：https://zhuanlan.zhihu.com/p/140876416参考：知乎文章聚簇索引，是每一个叶子节点最终都保留了一整行的记录信息，不需要进行回表，直接可以查找到但是非聚簇索引是每一个叶子节点都保留对应的主键值，通过主键进行回表来获取对应的记录信息，需要查两次别人的：这个问题会涉及到mysql的存储数据结构，B+tree多叉搜索树，有序，类似二叉搜索树(特性:中序遍历是有序的);curd的时间复杂度都是logN;再谈谈mysql的索引结构，innodb引擎中分主键(聚簇索引)索引树和二级索引树;Innodb的主键索引树的叶子节点上存储行数据，非叶子结点只存储主键id，简单讲就是聚簇索引相当于物理内存地址(一级指针)，查询快;而二级索引树的每个节点只会存储索引字段值和主键id;2种索引查询对比:主键索引树:主键id=&gt;叶子结点row数据二级索引树: 二级索引树上找到对应的id=&gt;主键索引树上的id=&gt;主键索引树上的叶子结点行记录上面“二级索引树=&gt;主键索引树”的过程叫做“回表”，可以通过“索引覆盖”，“索引下推”优化索引优化对于执行计划，参数有 possible_keys 字段表示可能用到的索引，key 字段表示实际用的索引，key_len 表示索引的长度，rows 表示扫描的数据行数。这其中需要你重点关注 type 字段， 表示数据扫描类型，也就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为（考虑到查询效率问题，全表扫描和全索引扫描要尽量避免）：ALL（全表扫描）；index（全索引扫描）；range（索引范围扫描）；ref（非唯一索引扫描）；eq_ref（唯一索引扫描）；const（结果只有一条的主键或唯一索引扫描）。总的来说，执行计划是研发工程师分析索引详情必会的技能（很多大厂公司招聘 JD 上写着“SQL 语句调优” ），所以你在面试时也要知道执行计划核心参数的含义，如 type。在回答时，也要以重点参数为切入点，再扩展到其他参数，然后再说自己是怎么做 SQL 优化工作的。常见索引优化方法前缀索引优化：前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。覆盖索引优化：覆盖索引是指 SQL 中 query 的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？我们可以建立一个组合索引，即商品ID、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。所以，使用覆盖索引的好处很明显，即不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。联合索引：联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。比如联合索引 (userpin, username)，如果查询条件是 WHERE userpin=1 AND username=2，就可以匹配上联合索引；或者查询条件是 WHERE userpin=1，也能匹配上联合索引，但是如果查询条件是 WHERE username=2，就无法匹配上联合索引。另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。区分度就是某个字段 column 不同值的个数除以表的总行数，比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。区分度公式：总结：数据库中数据很多的时候如何处理？面试官提示了索引索引越多越好么？不一定，通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:基于一个范围的检索，一般查询返回结果集小于表中记录数的30%基于非唯一性索引的检索查找过程可以理解为：最左匹配原则参考内部也是一棵B+树：参考如何创建索引mysql 索引慢分析（线上开启slowlog，提取慢查询，然后仔细分析explain 中 type字段以及extra字段，发生的具体场景及mysql是怎么做的，被表扬回答的不错）了解Mysql中的索引：涉3树是这样的一颗多路查找树，其中每一个节点都具有两个孩子及到什么是B树，与二叉搜索树和平衡二叉树区别，以及B+树区别InnoDB二级索引流程主键和索引的区别如何提高索引的速度innodb的索引有哪些联合索引的使用原则联合索引在b树，b+树的结构是怎么样的，查找过程你了解过么数据库聚集索引和辅助索引(也就是非聚簇索引)何时使用索引索引是如何实现的？多种引擎的实现区别？聚族索引，非聚族索引，二级索引，唯一索引、最左匹配原则等等（非常重要）上面“二级索引树=&gt;主键索引树”的过程叫做“回表”，可以通过“索引覆盖”，“索引下推”优化数据库覆盖索引假设我们有张表，结构如下：create table user( id int(11) not null, age int(11) not null, primary key(id), key(age) );覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。以上面的user表来举例，我们再增加一个name字段，然后做一些查询试试。explain select * from user where age=1; //查询的name无法从索引数据获取 explain select id,age from user where age=1; //可以直接从索引获取","categories":[],"tags":[],"author":"yirufeng"},{"title":"parallel安装的虚拟机登录root","slug":"parallel安装的虚拟机登录root","date":"2021-04-04T15:13:49.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/04/04/parallel安装的虚拟机登录root/","link":"","permalink":"http://www.sivan.tech/2021/04/04/parallel%E5%AE%89%E8%A3%85%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%99%BB%E5%BD%95root/","excerpt":"打开terminal 执行sudo passwd 出现Password:，键入自己当前用户的密码 出现Enter new UNIX password：这个是root的密码 出现Retype new UNIX password：重复root的密码 之后就可以使用su命令以及刚才设置的root用户密码切换到root用户","text":"打开terminal 执行sudo passwd 出现Password:，键入自己当前用户的密码 出现Enter new UNIX password：这个是root的密码 出现Retype new UNIX password：重复root的密码 之后就可以使用su命令以及刚才设置的root用户密码切换到root用户","categories":[{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/tags/tools/"},{"name":"parallel desktop","slug":"parallel-desktop","permalink":"http://www.sivan.tech/tags/parallel-desktop/"}],"author":"yirufeng"},{"title":"网易微课堂之中间件学习","slug":"网易微课堂之中间件学习","date":"2021-04-02T18:27:17.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/04/02/网易微课堂之中间件学习/","link":"","permalink":"http://www.sivan.tech/2021/04/02/%E7%BD%91%E6%98%93%E5%BE%AE%E8%AF%BE%E5%A0%82%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"分布式消息中间件 查看内容 总览分布式消息中间件设计篇amqamq入门amq支持的消息协议讲解ActiveMQ高可用集群方案持久化原理及事务机制rabbitmqrabbitmq入门以及内部消息分发机制课程目录AMQP协议RabbitMQ简介RabbitMQ基本概念RabbitMQ安装运行RabbitMQ基本配置RabbitMQ管理界面Hello WorldRabbitMQ简介RabbitMQ安装运行环境准备：Centos7 + erlangRabbitMQ基本配置rabbitMQ文件配置示例： 建议看Github和官网RabbitMQ端口rabbitmq集群和高可用方案持久化机制，内存，磁盘控制消息可靠性和插件化机制kafkakafka入门以及使用场景kafka connect数据传输作业工具kafka streams架构kafka优雅应用rocketmqrocketmq入门rocketmq架构方案以及角色详解有序消息订阅机制和定时消息批量消息和事务消息RocketMQ中高性能最佳实践案例网易后端架构中消息中间件应用（网易云） 负载均衡 查看内容 nginxnginx负载均衡代理缓存机制通过Lua拓展Nginx高性能Nginx实践LVSLVS基础概念解析基于VIP的keepalived高可用架构讲解搭建LVS负载均衡集群CDN使用CDN实现应用的缓存和加速DNS通过DNS实现高可靠的负载均衡和访问提速案例网易集团负载均衡的应用(网易云) 分布式缓存 查看内容 缓存介绍自研java内存缓存谷歌guava提供的缓存redisredis数据结构和常用命令(一)redis数据结构和常用命令(二)持久化机制redis内存管理redis主从复制哨兵高可用机制redis集群分片存储redis监控memcachedmemcached入门之安装使用memcached内存管理memcached集群方案memcached分布式算法案例大型互联网高并发缓存架构网易后端架构中缓存方面设计 数据库中间件 查看内容 数据库中间件设计理论数据库中间件设计要点分布式数据库在网易的最佳实践（网易云课堂） info, note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計 查看代码测试","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.sivan.tech/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/tags/redis/"},{"name":"架构","slug":"架构","permalink":"http://www.sivan.tech/tags/%E6%9E%B6%E6%9E%84/"},{"name":"nginx","slug":"nginx","permalink":"http://www.sivan.tech/tags/nginx/"},{"name":"中间件","slug":"中间件","permalink":"http://www.sivan.tech/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"memcached","slug":"memcached","permalink":"http://www.sivan.tech/tags/memcached/"}],"author":"yirufeng"},{"title":"mysql学习","slug":"mysql学习","date":"2021-04-02T10:38:35.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/04/02/mysql学习/","link":"","permalink":"http://www.sivan.tech/2021/04/02/mysql%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"安装环境 使用虚拟机的docker安装mysql Mysql逻辑架构 如图所示我们知道，Mysql可以分为server和存储引擎两大层。 Server层：涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。（不同存储引擎的表数据存取方式不同，支持的功能也不同） 一条查询语句的执行流程连接器：负责与客户端建立连接，获取权限，维持和管理连接。连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。 如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 注意： 一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。 分析器：词法分析+语法分析优化器：执行器： 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。（对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。） 长连接与其遇到的问题概念：数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。原因：建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。遇到的问题：全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了解决办法： 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态 redo log 是 InnoDB 引擎特有的日志问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高解决方法：为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。 优点：有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。因为即使宕机我们的记录依然保存到了我们的数据库或者没有保存到数据库也保存到了日志文件中。 Server 层也有自己的日志，称为 binlog（归档日志）。只依靠 binlog 是没有 crash-safe 能力的 这两种日志有以下三点不同。 redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。 redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 slave会从master读取binlog（二进制日志文件，我们在第一章讲到过mysql的二进制日志文件）来进行数据同步 一条修改语句的执行流程如下：在 InnoDB 存储引擎下，一条 update 语句在 MySQL 内部执行大概会经历下面五个步骤：1、执行器先找引擎取 id=2 这一行数据，如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。2、执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。4、执行器生成这个操作的 binlog，并把 binlog 写入磁盘。5、执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交(commit)状态，更新完成。 问题： 第2步调用引擎接口将数据写到哪里？内存还是磁盘上保存的数据：内存上 如果事务出错，需要回滚，回滚到了哪一步(1,2,3,4,5哪个)，回滚到了第2步，此时执行一个相反的命令(通过Undo log) 小结：我介绍了 MySQL 里面最重要的两个日志，即物理日志 redo log 和逻辑日志 binlog。 redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。 Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。 事务：在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不 是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。 事务隔离的实现：在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新 值，通过回滚操作，都可以得到前一个状态的值。 在实现上，数据库里面会创建一个视图(一致性视图read-view)，访问的时候以视图的逻辑结果为准。在“可重复 读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要 注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行 化”隔离级别下直接用加锁的方式来避免并行访问。 长事务：长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任 何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导 致大量占用存储空间。 在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长 事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的 时候展开。 索引：索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。 哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。 而有序数组在等值查询和范围查询场景中的性能就都非常优秀。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。 所以，有序数组索引只适用于静态存储引擎 在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。 这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。 根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。 基于主键索引和普通索引的查询有什么区别？ 如果查不到我们要的字段，基于非主键索引的查询需要多扫描一棵索引树，称为回表。 由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。 B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。 由于 InnoDB 是索引组织表，一般情况下我会建议你创建一个自增主键，这样非主键索引占用的空间最小。但事无绝对，我也跟你讨论了使用业务逻辑字段做主键的应用场景。 事务 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。事务在执行期间看到的数据前后必须是一致的。 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。 Oracle 数据库的默认隔离级别其实就是“读提交”。Mysql默认隔离级别就是“可重读” 可重读应用场景：假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。 回滚日志总不能一直保留吧，什么时候删除呢？：答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。 索引索引的出现其实就是为了提高数据查询的效率，就像书的目录一样 哈希表这种结构适用于只有等值查询的场景 覆盖索引：查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引优化手段：由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 联合索引底层结构：索引项是按照索引定义里面出现的字段顺序排序 最左前缀原则：可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。 索引的选择：，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。 这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。 索引下推： 例如执行如下的SQL语句：mysql&gt; select * from tuser where name like &#39;张 %&#39; and age=10 and ismale=1;在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。图 3 无索引下推执行流程： 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 图 4 索引下推执行流程： 在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。 图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。 图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。 原则：在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。我们在使用数据库的时候，尤其是在设计表结构（包括索引）时，也要以减少资源消耗作为目标 09做的笔记：唯一索引与普通索引区别：对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。 InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。 因为引擎是按页读写的，所以说，当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。 当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。 但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。 总结：回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。 change buffer与我们前面讲的redo log容易混淆：所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。 14做的笔记：MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这 个数，效率很高； 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面 读出来，然后累积计数。 15做的笔记： Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。 总结课做的笔记：带新人： 第一步就是要求他们手动搭建一套主备复制结构。并且，平时碰到问 题的时候，我要求要动手复现 有不少同学在跟着专栏中的案例做实验，我觉得这是个非 常好的习惯，希望你能继续坚持下去。在阅读其他技术文章、图书的时候，也是同样的道 理。如果你觉得自己理解了一个知识点，也一定要尝试设计一个例子来验证它。 在设计案例的时候，我建议你也设计一个对照的反例，从而达到知识融汇贯通的目 的。就像我在写这个专栏的过程中，就感觉自己也涨了不少知识，主要就得益于给文章设计 案例的过程。 原理说不清，双手白费劲。主动讲解自己理解的，并且进一步升华境界到写出来（把知识点“写下来”，还有一个好处，就是你会发现这个知识点的关联知识点。深究下去， 点就连成线，然后再跟别的线找交叉） 手册补全面，案例扫盲点：看手册的时机，应该是你的知识 网络构建得差不多的时候。那你可能会问，什么时候算是差不多呢？其实，这没有一个固定的标准。但是，有一些基本 实践可以帮你去做一个检验。 能否解释清楚错误日志（error log）、慢查询日志（slow log）中每一行的意思？ 能否快速评估出一个表结构或者一条 SQL 语句，设计得是否合理？ 能否通过 explain 的结果，来“脑补”整个执行过程（我们已经在专栏中练习几次 了）？ 到网络上找 MySQL 的实践建议，对于每一条做一次分析： 如果觉得不合理，能否给出自己的意见？ 如果觉得合理，能否给出自己的解释？那，怎么判断自己的意见或者解释对不对呢？最快速、有效的途径，就是找有经验的人讨 论。比如说，留言到我们专栏的相关文章的评论区，就是一个可行的方法。这些实践做完后，你就应该对自己比较有信心了。这时候，你可以再去看手册，把知识网络 中的盲点补全，进而形成面。而补全的方法就是前两点了，理论加实践。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/tags/mysql/"},{"name":"极客时间","slug":"极客时间","permalink":"http://www.sivan.tech/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"}],"author":"yirufeng"},{"title":"centos7安装docker","slug":"centos7安装docker","date":"2021-03-30T10:14:34.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/30/centos7安装docker/","link":"","permalink":"http://www.sivan.tech/2021/03/30/centos7%E5%AE%89%E8%A3%85docker/","excerpt":"系统要求：docker支持64位Centos7，并且要求内核版本(查看Linux系统内核版本：uname -r)不低于3.10 卸载旧版本安装docker 卸载旧版本 旧版本的docker称为docker或docker-engine，使用如下命令卸载旧版本1sudo yum remove docker docker-common docker-selinux docker-engine 安装方式一：使用yum安装 1sudo yum install docker-ce如果执行之后返回的是没有可用软件包，此时我们需要安装必要的软件依赖以及更新增加docker-ce yum源12sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo执行完这两条命令之后我们便可以重新执行`sudo yum install docker-ce`进行安装 安装方式二：使用脚本安装 在测试或开发环境中docker官方为了简化安装流程，提供了一套便捷的安装脚本，centos系统上可以使用这套脚本进行安装12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun执行完这个命令之后，系统会自动将一切工作准备好，并把docker ce的Edge版本安装在系统中","text":"系统要求：docker支持64位Centos7，并且要求内核版本(查看Linux系统内核版本：uname -r)不低于3.10 卸载旧版本安装docker 卸载旧版本 旧版本的docker称为docker或docker-engine，使用如下命令卸载旧版本1sudo yum remove docker docker-common docker-selinux docker-engine 安装方式一：使用yum安装 1sudo yum install docker-ce如果执行之后返回的是没有可用软件包，此时我们需要安装必要的软件依赖以及更新增加docker-ce yum源12sudo yum install -y yum-utils device-mapper-persistent-data lvm2sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo执行完这两条命令之后我们便可以重新执行`sudo yum install docker-ce`进行安装 安装方式二：使用脚本安装 在测试或开发环境中docker官方为了简化安装流程，提供了一套便捷的安装脚本，centos系统上可以使用这套脚本进行安装12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun执行完这个命令之后，系统会自动将一切工作准备好，并把docker ce的Edge版本安装在系统中 启动docker CE 12sudo systemctl enable dockersudo systemctl start docker启动docker之后可以使用docker info来查看docker的信息 建立docker用户组 默认情况下，docker命令会用Unix Socket与Docker引擎通讯，但是只有root用户与docker组的用户才可以访问Docker引擎的Unix Socket。一般Linux系统上不会直接使用root用户进行操作，因此需要将使用docker的用户加入docker用户组。12sudo groupadd docker #建立 docker 用户s组sudo usermod -aG docker $&#123;USER&#125; #将当前用户加入docker用户组启动docker之后可以使用docker info来查看docker的信息 测试docker是否正确安装 1docker run hello-world #启动一个基于hello-world的镜像的容器 配置docker镜像加速器docker默认从docker hub上拉取镜像，国内会网速偏慢，建议配置镜像加速器 步骤 在/etc/docker/daemon.json文件(如果没有就创建)中写入：这里配置的是自己的阿里云的，建议配置阿里云的（[获取镜像加速器地址](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors）123&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;*(涉密省略)**.mirror.aliyuncs.com&quot;]&#125;重新启动服务生效12sudo systemctl daemon-reloadsudo systemctl restart docker查看一下docker默认下载镜像的地址：执行docker info ，查看Registry Mirrors的内容是否为我们配置的内容。如下图所示： 卸载docker 删除docker安装包 1sudo yum remove docker-ce 删除docker镜像 1sudo rm -rf /var/lib/docker","categories":[{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/categories/docker/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"Centos","slug":"Centos","permalink":"http://www.sivan.tech/tags/Centos/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/tags/Linux/"}],"author":"yirufeng"},{"title":"基于Centos7 搭建 gitlab","slug":"基于Centos7-搭建-gitlab","date":"2021-03-26T10:37:13.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/26/基于Centos7-搭建-gitlab/","link":"","permalink":"http://www.sivan.tech/2021/03/26/%E5%9F%BA%E4%BA%8ECentos7-%E6%90%AD%E5%BB%BA-gitlab/","excerpt":"环境centos7腾讯云服务器一台 步骤 前提 更新软件包：yum update -y安装 sshd：yum install -y curl policycoreutils-python openssh-server启用并启动sshd：systemctl enable sshd 和 systemctl start sshd配置防火墙：打开 /etc/sysctl.conf 文件，在文件最后添加新的一行并按 Ctrl + S 保存：net.ipv4.ip_forward = 1启用并启动防火墙：systemctl enable firewalld 和 systemctl start firewalld放通 HTTP：firewall-cmd --permanent --add-service=http重启防火墙：systemctl reload firewalld在实际使用中，可以使用 systemctl status firewalld 命令查看防火墙的状态。安装postfixGitLab 需要使用 postfix 来发送邮件。当然，也可以使用 SMTP 服务器，具体步骤请参考 官方教程。安装：yum install -y postfix打开 /etc/postfix/main.cf 文件，在第 119 行附近找到 inet_protocols = all，将 all 改为 ipv4 并按 Ctrl + S 保存：inet_protocols = ipv4启用并启动 postfix：systemctl enable postfix + systemctl start postfix 配置 swap 交换分区 由于 GitLab 较为消耗资源，我们需要先创建交换分区，以降低物理内存的压力。在实际生产环境中，如果服务器配置够高，则不必配置交换分区。新建 2 GB 大小的交换分区：dd if=/dev/zero of=/root/swapfile bs=1M count=2048格式化为交换分区文件并启用：mkswap /root/swapfile 和 swapon /root/swapfile添加自启用。打开 /etc/fstab 文件，在文件最后添加新的一行并按 Ctrl + S 保存：/root/swapfile swap swap defaults 0 0将软件源修改为国内源：由于网络环境的原因，将 repo 源修改为清华大学。在 /etc/yum.repos.d 目录下新建 gitlab-ce.repo文件并保存。内容如下：12345[gitlab-ce]name&#x3D;Gitlab CE Repositorybaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el$releasever&#x2F;gpgcheck&#x3D;0enabled&#x3D;1 安装gitlab 刚才修改过了 yum 源，因此先重新生成缓存：yum makecache （此步骤执行时间较长，一般需要 3~5 分钟左右，请耐心等待）安装 GitLab：：yum install -y gitlab-ce （此步骤执行时间较长，一般需要 3~5 分钟左右，请耐心等待）配置 GitLab 的域名（非必需）：打开 /etc/gitlab/gitlab.rb 文件，在第 13 行附近找到 external_url &#39;http://gitlab.example.com&#39;，将单引号中的内容改为自己的域名（带上协议头，末尾无斜杠），并按 Ctrl + S 保存。例如：external_url &#39;http://work.myteam.com&#39; 记得将域名通过 A 记录解析到 centos7对应的IP 哦。设置完成后使用如下命令重启 GitLab的配置：sudo gitlab-ctl reconfigure + 重启gitlab服务sudo gitlab-ctl restart（此步骤执行时间较长，一般需要 5~10 分钟左右，请耐心等待）至此，我们已经成功地在 CentOS 7 上搭建了 GitLab。 现在可以在这里（http://centoss7主机ip地址/）访问 GitLab 了。 注意事项 在实际生产中，建议您使用 2 核 4 GB 或更高配置的 CVM。点击这里 可以查看 GitLab 官方推荐的配置和可承载人数对应表。再次提醒您，定期执行 yum update -y 以保持各软件包的最新状态。","text":"环境centos7腾讯云服务器一台 步骤 前提 更新软件包：yum update -y安装 sshd：yum install -y curl policycoreutils-python openssh-server启用并启动sshd：systemctl enable sshd 和 systemctl start sshd配置防火墙：打开 /etc/sysctl.conf 文件，在文件最后添加新的一行并按 Ctrl + S 保存：net.ipv4.ip_forward = 1启用并启动防火墙：systemctl enable firewalld 和 systemctl start firewalld放通 HTTP：firewall-cmd --permanent --add-service=http重启防火墙：systemctl reload firewalld在实际使用中，可以使用 systemctl status firewalld 命令查看防火墙的状态。安装postfixGitLab 需要使用 postfix 来发送邮件。当然，也可以使用 SMTP 服务器，具体步骤请参考 官方教程。安装：yum install -y postfix打开 /etc/postfix/main.cf 文件，在第 119 行附近找到 inet_protocols = all，将 all 改为 ipv4 并按 Ctrl + S 保存：inet_protocols = ipv4启用并启动 postfix：systemctl enable postfix + systemctl start postfix 配置 swap 交换分区 由于 GitLab 较为消耗资源，我们需要先创建交换分区，以降低物理内存的压力。在实际生产环境中，如果服务器配置够高，则不必配置交换分区。新建 2 GB 大小的交换分区：dd if=/dev/zero of=/root/swapfile bs=1M count=2048格式化为交换分区文件并启用：mkswap /root/swapfile 和 swapon /root/swapfile添加自启用。打开 /etc/fstab 文件，在文件最后添加新的一行并按 Ctrl + S 保存：/root/swapfile swap swap defaults 0 0将软件源修改为国内源：由于网络环境的原因，将 repo 源修改为清华大学。在 /etc/yum.repos.d 目录下新建 gitlab-ce.repo文件并保存。内容如下：12345[gitlab-ce]name&#x3D;Gitlab CE Repositorybaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el$releasever&#x2F;gpgcheck&#x3D;0enabled&#x3D;1 安装gitlab 刚才修改过了 yum 源，因此先重新生成缓存：yum makecache （此步骤执行时间较长，一般需要 3~5 分钟左右，请耐心等待）安装 GitLab：：yum install -y gitlab-ce （此步骤执行时间较长，一般需要 3~5 分钟左右，请耐心等待）配置 GitLab 的域名（非必需）：打开 /etc/gitlab/gitlab.rb 文件，在第 13 行附近找到 external_url &#39;http://gitlab.example.com&#39;，将单引号中的内容改为自己的域名（带上协议头，末尾无斜杠），并按 Ctrl + S 保存。例如：external_url &#39;http://work.myteam.com&#39; 记得将域名通过 A 记录解析到 centos7对应的IP 哦。设置完成后使用如下命令重启 GitLab的配置：sudo gitlab-ctl reconfigure + 重启gitlab服务sudo gitlab-ctl restart（此步骤执行时间较长，一般需要 5~10 分钟左右，请耐心等待）至此，我们已经成功地在 CentOS 7 上搭建了 GitLab。 现在可以在这里（http://centoss7主机ip地址/）访问 GitLab 了。 注意事项 在实际生产中，建议您使用 2 核 4 GB 或更高配置的 CVM。点击这里 可以查看 GitLab 官方推荐的配置和可承载人数对应表。再次提醒您，定期执行 yum update -y 以保持各软件包的最新状态。","categories":[{"name":"CI/CD","slug":"CI-CD","permalink":"http://www.sivan.tech/categories/CI-CD/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/tags/Linux/"},{"name":"gitlab","slug":"gitlab","permalink":"http://www.sivan.tech/tags/gitlab/"}],"author":"yirufeng"},{"title":"gorm学习使用","slug":"gorm学习使用","date":"2021-03-24T21:55:58.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/24/gorm学习使用/","link":"","permalink":"http://www.sivan.tech/2021/03/24/gorm%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"gorm的使用安装 使用指令进行安装：go get github.com/jinzhu/gorm DDL操作前提 新建一个数据库gorm_project 指定使用Utf8编码 数据库连接 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( &quot;fmt&quot; &quot;github.com/jinzhu/gorm&quot; //_ &quot;github.com/go-sql-driver/mysql&quot; //导入驱动方式一 _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot; //导入驱动方式二，前面加上_表示不去校验用没用)/** * @Author: yirufeng * @Date: 2021/3/22 10:00 下午 * @Desc: **/var ( MYSQL_USERNAME = &quot;root&quot; MYSQL_PASSWORD = &quot;qwertyasdfgh&quot; MYSQL_IP = &quot;81.69.26.201&quot; MYSQL_PORT = &quot;3306&quot; MYSQL_DATABASE = &quot;gorm_project&quot;)func main() &#123; //parseTime用来处理time.Time类型的数据 //loc=Local表示根据本地时区走 //连接信息：用户名:密码@tcp(ip:port)/数据库名称?charset=utf8&amp;parseTime=True&amp;loc=Local connInfo := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_IP, MYSQL_PORT, MYSQL_DATABASE) //使用open来连接数据库 //第一个参数是dialect也就是指定数据库的类型 //第二个参数是连接信息 db, err := gorm.Open(&quot;mysql&quot;, connInfo) if err != nil &#123; panic(err) &#125; defer db.Close() //关闭空闲的连接&#125; 数据库对表的操作拆分出的一个包：”gorm_demo/conn” 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package connimport ( &quot;fmt&quot; &quot;github.com/jinzhu/gorm&quot; //_ &quot;github.com/go-sql-driver/mysql&quot; //导入驱动方式一 _ &quot;github.com/jinzhu/gorm/dialects/mysql&quot; //导入驱动方式二，前面加上_表示不去校验用没用)/** * @Author: yirufeng * @Date: 2021/3/23 9:06 上午 * @Desc: **/var ( MYSQL_USERNAME = &quot;root&quot; MYSQL_PASSWORD = &quot;qwertyasdfgh&quot; MYSQL_IP = &quot;81.69.26.201&quot; MYSQL_PORT = &quot;3306&quot; MYSQL_DATABASE = &quot;gorm_project&quot; db *gorm.DB)func init() &#123; //parseTime用来处理time.Time类型的数据 //loc=Local表示根据本地时区走 //连接信息：用户名:密码@tcp(ip:port)/数据库名称?charset=utf8&amp;parseTime=True&amp;loc=Local connInfo := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, MYSQL_USERNAME, MYSQL_PASSWORD, MYSQL_IP, MYSQL_PORT, MYSQL_DATABASE) //使用open来连接数据库 //第一个参数是dialect也就是指定数据库的类型 //第二个参数是连接信息 var err error db, err = gorm.Open(&quot;mysql&quot;, connInfo) if err != nil &#123; panic(err) &#125;&#125;func GetConn() *gorm.DB &#123; return db&#125;func Close() &#123; db.Close()&#125; 创建表 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 9:03 上午 * @Desc: 连接数据库并对数据库中的表进行操作： 1. 创建表 2. 删除表 **///创建表之前先得有一个模型//字段中记得习惯性将首字母大写type User struct &#123; Id int Name string Age int Address string Pic string&#125;//不指定表名直接根据我们传入的结构体创建一个表/*生成的表的结果如下：表名是users字段名分别是id,name,age,addr,pic*/func demo1() &#123; //创建表的 conn.GetConn().CreateTable(&amp;User&#123;&#125;) //释放连接 conn.Close()&#125;//根据指定的表名创建表func demo2() &#123; //创建表 conn.GetConn().Table(&quot;user&quot;).CreateTable(&amp;User&#123;&#125;) //释放连接 conn.Close()&#125;func main() &#123; //demo1() //demo2() demo3()&#125; 删除表 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 9:03 上午 * @Desc: 连接数据库并对数据库中的表进行操作： 1. 创建表 2. 删除表 **///创建表之前先得有一个模型//字段中记得习惯性将首字母大写type User struct &#123; Id int Name string Age int Address string Pic string&#125;//删除表func demo3() &#123; db := conn.GetConn() //删除表的方式一：使用我们模型名 db.DropTable(&amp;User&#123;&#125;) //删除的就是users，因为删除的表的名字是模型名通过规则变成的表名 //删除表的方式二：直接使用表名 db.DropTable(&quot;user&quot;) //删除表的方式三：先判断是否存在之后再进行删除 db.DropTableIfExists(&amp;User&#123;&#125;) //释放连接 db.Close()&#125;func main() &#123; //demo1() //demo2() demo3()&#125; 查询表是否存在 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 9:03 上午 * @Desc: 连接数据库并对数据库中的表进行操作： 1. 创建表 2. 删除表 **///创建表之前先得有一个模型//字段中记得习惯性将首字母大写type User struct &#123; Id int Name string Age int Address string Pic string&#125;//检查表是否存在func demo4() &#123; db := conn.GetConn() //方式一：使用模型 b1 := db.HasTable(&amp;User&#123;&#125;) fmt.Println(b1) //方式二：使用指定的表名 b2 := db.HasTable(&quot;users&quot;) fmt.Println(b2)&#125;func main() &#123; //demo1() //demo2() demo3()&#125; [不讲，也不建议使用]对数据表中列的操作 一般很少有人修改，比如我们定义好的一个字段的类型，如果再去修改将会给别人造成一个很大的坑的感觉 数据库的迁移自动迁移会创建表，帮助我们添加缺少的列和索引，不会改变现有列的类型以及不会删除未使用的列来保护数据 对应的代码 12345678//方式一：迁移一个表db.AutoMigrate(&amp;User&#123;&#125;)//方式二：迁移多个表db.AutoMigrate(&amp;User&#123;&#125;,&amp;Product&#123;&#125;,&amp;Order&#123;&#125;)//方式三：创建表的时候添加表后缀db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE=InnoDB&quot;).AutoMigrate(&amp;Student&#123;&#125;) DML操作 主要是对数据的操作 增加数据 对应的代码 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;gorm_demo/conn&quot; &quot;gorm_demo/models&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 10:43 上午 * @Desc: **/func main() &#123; db := conn.GetConn() defer db.Close() //自动迁移数据表 db.AutoMigrate(&amp;models.User&#123;&#125;) //新增数据 db.Create(&amp;models.User&#123; Name: &quot;张三&quot;, Age: 18, Addr: &quot;XXX&quot;, Pic: &quot;/static/upic/download.png&quot;, Phone: &quot;13967845581&quot;, &#125;)&#125; 查询数据 对应的代码 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot; &quot;gorm_demo/models&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 10:47 上午 * @Desc: 使用first查询第一条数据，两个方式： 1. 根据我们默认的条件进行查询，默认是主键的值 2. 根据我们自己指定的条件进行查询 **/func main() &#123; db := conn.GetConn() defer db.Close() var user models.User //查询第一条数据 //第一个参数是容器，表示将查询结果放到哪里， //第二个参数是条件，默认是id db.First(&amp;user, 1) //这里的1默认是id var user2 models.User //根据指定的条件进行查询 db.First(&amp;user2, &quot;name=?&quot;, &quot;张三&quot;) fmt.Println(user) fmt.Println(user2)&#125; 修改数据 对应的代码 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;gorm_demo/conn&quot; &quot;gorm_demo/models&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 10:53 上午 * @Desc: 更新：先查询出对应的数据，然后 **/func main() &#123; db := conn.GetConn() defer db.Close() var user models.User //查询第一条数据 //第一个参数是容器，表示将查询结果放到哪里， //第二个参数是条件，默认是id db.First(&amp;user, 1) //这里的1默认是id //更新一个字段 db.Model(&amp;user).Update(&quot;Age&quot;, 30) //更新多个字段，【推荐】链式调用或者一行代码更新一个 db.Model(&amp;user).Update(&quot;Age&quot;, 35).Update(&quot;name&quot;, &quot;yirufeng&quot;)&#125; 删除数据 对应的代码 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot; &quot;gorm_demo/models&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 11:03 上午 * @Desc: 删除数据 **/func main() &#123; db := conn.GetConn() defer db.Close() //新增数据 db.Create(&amp;models.User&#123; Name: &quot;张三&quot;, Age: 18, Addr: &quot;XXX&quot;, Pic: &quot;/static/upic/download.png&quot;, Phone: &quot;13967845581&quot;, &#125;) //删除之前先要查询数据 var user models.User db.First(&amp;user, 3) fmt.Println(user) //删除数据 db.Delete(&amp;user)&#125; 【模型定义】模型名和表名的映射关系模型定义作用：用于数据库数据转换以及自动建表 规则： 第一个大写字母变为小写 遇到其他大写字母变为小写并在前面加上下划线 **比如UserInfo变成user_infos** 连着的几个大写字母，只有第一个遵循上面的两条规则，其他的大写字母转换为小写，不加下划线，遇到小写，前面的第一个大写字母变小写并在该大写字母前面加下划线。比如DBUserInfo变成db_user_infos 复数形式 举例： User —&gt; users 首字母小写，复数 UserInfo —&gt; user_infos DBUserInfo —&gt; db_user_infos DBXXXXUserInfo —&gt; dbxxxx_user_infos 【模型定义】自定义表名称模型名如何与表名进行自定义名称呢：也就是我们模型名定义之后，但是想定义在数据库的表名，我们可以按照如下思路做：在我们的结构体对应的.go文件中编写一个方法func (struct名称) TableName() string 对应的代码 1234567891011121314151617181920212223242526package mainimport &quot;gorm_demo/conn&quot;/** * @Author: yirufeng * @Date: 2021/3/23 2:51 下午 * @Desc: **/type StudentInfo struct &#123; Id int Name string Age int&#125;//对应的struct绑定一个方法func (StudentInfo) TableName () string &#123; return &quot;students&quot;&#125;func main() &#123; db := conn.GetConn() defer db.Close() db.AutoMigrate(&amp;StudentInfo&#123;&#125;)&#125; 给默认生成的表名前面加上前缀和后缀：给默认表名上面同一加上其他规则，只能在我们生成的默认表名的前面或后面加上指定的内容，不可以在中间加上指定的内容。 对应的代码 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;github.com/jinzhu/gorm&quot; &quot;gorm_demo/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/23 3:19 下午 * @Desc: **/type Employ struct &#123; Id int Name string Age int&#125;func main() &#123; db := conn.GetConn() defer db.Close() //给我们生成的默认表名的前面加上&quot;sys_&quot;以及后面加上&quot;_sys&quot; gorm.DefaultTableNameHandler = func(db *gorm.DB, defaultTableName string) string &#123; return &quot;sys_&quot; + defaultTableName + &quot;_sys&quot; &#125; db.AutoMigrate(&amp;Employ&#123;&#125;)&#125; 结果：在数据库中生成的表名是sys_employs_sys 【模型定义】字段名称和列名的映射关系规则：列名是字段名的蛇形小写 举例：Name—&gt;name ，CreatedTime —&gt; created_time DBACreateTime —&gt;dba_create_time 可以通过gorm标签指定列名：AnimalId int64 gorm:&quot;column:animal_id&quot; 【模型定义】gorm.Model 【模型定义】gorm标签的使用gorm中的primary_key默认就是auto_increment的 结构体标签gorm的使用 对应的代码 12345type UserInfo struct &#123; Id int `gorm:&quot;primary_key&quot;` Name string `gorm:&quot;index&quot;` Age int&#125; gorm标签属性值： 【模型定义】gorm标签属性值一二注意：多个属性之间使用;(英文的分号)分割两个属性 -表示忽略该字段的迁移 primary_key默认是auto_increment的 index如果没有指定名字，默认是idx_表名_列名 unique_index如果没有指定名字，默认是uix_表名_列名 unique给某个列加了约束，那么该列将会默认加上unique_index，名字是该列的名字 唯一约束和唯一索引在 MySQL 数据库里区别： 概念上不同，约束是为了保证数据的完整性，索引是为了辅助查询； 创建唯一约束时，会自动的创建唯一索引； 在理论上，不一样，在实际使用时，基本没有区别。 关于第二条，MySQL 中唯一约束是通过唯一索引实现的，为了保证没有重复值，在插入新记录时会再检索一遍，怎样检索快，当然是建索引了，所以，在创建唯一约束的时候就创建了唯一索引 【关联表】一对一回顾 一对一关联字段可以建在第一个表也可以建在第二个表。 【关联表】一对多回顾一对多的案例： 一个作者可以有多篇文章，一篇文章只能有一个作者。 一个家庭只能有两个房产证，一个房产证只能属于一个家庭 一个用户可以有多台车，但是一台车只可以属于一个用户 解决方案：如何关联呢？只可以将外键存放到多的一方这个表中 【关联表】多对多回顾多对多的案例： 文章和标签：一个文章可以有多个标签，一个标签可以属于多个文章 用户和客服：一个用户可以有多个客服，一个客服可以服务于多个用户 解决方案：通过中间表进行解决。 【一对一】一对一属于 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport &quot;gorm_demo/conn&quot;/** * @Author: yirufeng * @Date: 2021/3/23 6:08 下午 * @Desc: **/type User struct &#123; Id int Name string Age int Addr string&#125;//用户详细信息type UserProfile struct &#123; Id int Pic string //图片的地 址 CPic string //存的是地址 Phone string //方式一：默认的一对一包含 //这个User不是一个字段而是一个关联关系 //User User //关联关系 //UserID int //默认关联字段，格式：另外一个model名称全称然后加上ID //方式二：可以自己指定关联的字段通过gorm提供的标签进行指定：`gorm:&quot;ForeignKey:当前表的字段名称;AssociationForeignKey:另一个表的字段名称&quot;` User User `gorm:&quot;ForeignKey:UId;AssociationKey:Id&quot;` //默认关联字段，格式：另外一个model名称全称然后加上ID //关联关系 UId int&#125;func main() &#123; db := conn.GetConn() defer db.Close() var user User db.AutoMigrate(&amp;User&#123;&#125;, &amp;UserProfile&#123;&#125;)&#125; 注意：两种方式建立的外键并不会在数据库里面去建立一个外键体现出来。也就是不会在数据库里面绑定一个外键约束 【一对一】一对一包含属于和包含的区别就是：关联关系和外键字段(关系字段，也就是我们ForeignKey指定的那个字段)都在一方，但是在包含里面是在不同的方里面 也就是在上面那个案例中，我们的UserProfile(关联关系所在的表)是属于另外一个表的，因为两个都在一个model中定义 但是在这里我们的UserProfile是包含另一个表的，因为外键定义在了另外一个表，也就是关联关系与我们的外键字段不在一个model里面，因此就是包含 属于：关系和外键在同一方，有关系的那一方属于另外一个模型包含：关系和外键不在同一方，有关系的那一方包含另外一个模型A属于B,关系和外键在同一方，关系和外键在同一方，有关系的那一方（A）属于另外一个模型(B)A包含B,关系和外键不在同一方，关系和外键不在同一方，有关系的那一方（A）包含另外一个模型(B) 对应的代码 123456789101112131415161718192021222324252627282930313233343536package mainimport &quot;gorm_demo/conn&quot;/** * @Author: yirufeng * @Date: 2021/3/23 9:54 下午 * @Desc: 一对一的包含 **/type User struct &#123; Id int Name string Age int Addr string PId int //外键在另外一方&#125;type UserProfile struct &#123; Id int Pic string CPic string Phone string //关系在这一方,外键在另一方 User User `gorm:&quot;ForeignKey:PId;AssociationForeignKey:Id&quot;`&#125;func main() &#123; db := conn.GetConn() defer db.Close() var user User db.AutoMigrate(&amp;User&#123;&#125;, &amp;UserProfile&#123;&#125;)&#125; 【一对一】一对一小结 一对一的话关系可以放在任意一方， 外键放在与关系一方就是属于，否则就是包含，AssociationKey是和外键不在同一个表的另外一个表的主键属于：关系和外键在同一方，有关系的那一方属于另外一个模型包含：关系和外键不在同一方，有关系的那一方包含另外一个模型 通常建议还是要标签指定我们的两个字段的值一个是ForeignKey另外一个是AssociationForeignKey 【一对多】一对多的属于和包含一对多外键一定是放到多的那一方，但是关系放到哪里呢？如果与外键放到一起就是属于否则就是包含 假设有作者表与文章表 一个作者可以有多个文章，因此外键一定在文章 此时关系是可以放到作者的也是可以放到文章的，如果关系字段放到作者，那么是一个文章的切片 如果关系字段放到文章中，那么是一个作者切片 【多对多】模型定义在两个表中的其中一个表对应的外键字段(切片)并在后面加上标签gorm:&quot;many2many:中间表名称;&quot; 可以指定外键以及关联字段的名称：gorm:&quot;many2many:中间表名称;ForeignKey:可以是当前表也可以是另外一个表的主键;AssociationForeignKey:只能是除了ForeignKey的另外一个表的主键&quot; 注意：如果我们两个model的序号不是Id，而是别的名字，我们要自己加上gorm标签指定是主键 【一对一操作】增加数据create的时候是会给我们进行一个关联插入的，也就是创建userProfile的时候指定的属性User我们是没有办法确定user的id的值，而且我们也没有必要写，因为Gorm插入的时候是会关联插入的，也就是首先会在user_profile中插入一条记录，然后再插入user表的一条记录，并将user_profile的id作为新插入user的外键 对应的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport conn &quot;gorm_demo/util&quot;/** * @Author: yirufeng * @Date: 2021/3/24 9:26 上午 * @Desc: 一对一增加数据 **/type User struct &#123; Id int Name string Age int Addr string PId int //外键在另外一方&#125;type UserProfile struct &#123; Id int Pic string CPic string Phone string //关系在这一方,外键在另一方 User User `gorm:&quot;ForeignKey:PId;AssociationForeignKey:Id&quot;`&#125;func main() &#123; db := conn.GetConn() defer db.Close() user_profile := UserProfile&#123; Pic: &quot;/root/1.png&quot;, CPic: &quot;/root/1.png&quot;, Phone: &quot;13934999999&quot;, User: User&#123; //由于Id不知道，因为我们是要关联插入，也就是先插入UserProfile，然后同时向user插入一条记录并绑定 Name: &quot;yirufeng&quot;, Age: 20, Addr: &quot;北京市西城区&quot;, //PId: 我们其实也不知道PId的值，因为我们user_profile还没有插入 &#125;, &#125; //插入的时候会关联进行插入 db.Create(&amp;user_profile)&#125; 【一对一操作】关联查询 第一种方式-association： 【推荐，比较简单】第二种方式-preload： 第三种方式-related：注意：查看对应的sql语句：我们可以调用Debug()方法让其打印sql语句 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( &quot;fmt&quot; &quot;gorm_demo/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/24 9:46 上午 * @Desc: **/type User struct &#123; Id int Name string Age int Addr string PId int //外键在另外一方&#125;type UserProfile struct &#123; Id int Pic string CPic string Phone string //关系在这一方,外键在另一方 User User `gorm:&quot;ForeignKey:PId;AssociationForeignKey:Id&quot;`&#125;func main() &#123; db := conn.GetConn() defer db.Close() //关联查询第一种方式：使用asssociation var userProfile UserProfile db.First(&amp;userProfile, 1) fmt.Println(userProfile) //注意这里Association里面传入的参数是字段名， //另外需要注意的就是我们关联字段查询出的是给对应的关联字段赋值 db.Model(&amp;userProfile).Association(&quot;User&quot;).Find(&amp;userProfile.User) fmt.Println(userProfile) //关联查询第二种方式：使用preload var userProfile2 UserProfile //Preload参数必须是关联关系名字 //后面可以用First也可以使用Find db.Debug().Preload(&quot;User&quot;).First(&amp;userProfile2, 1) fmt.Println(userProfile2) //关联查询第三种方式： var userProfile3 UserProfile db.First(&amp;userProfile3, 1) var user User db.Model(&amp;userProfile3).Related(&amp;user, &quot;User&quot;) fmt.Println(userProfile3, user) //此时userProfile3的User字段全部为空，user是我们查出来的结果&#125; 【一对一操作】更新数据 这里讲的是通过UserProfile对User进行更新 注意：如果更新多个字段需要对模型初始化 对应的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( &quot;fmt&quot; &quot;gorm_demo/学习/conn&quot;)/** * @Author: yirufeng * @Date: 2021/3/24 6:42 下午 * @Desc: **/type User struct &#123; Id int Name string Age int Addr string PId int //外键在另外一方&#125;type UserProfile struct &#123; Id int Pic string CPic string Phone string //关系在这一方,外键在另一方 User User `gorm:&quot;ForeignKey:PId;AssociationForeignKey:Id&quot;`&#125;func main() &#123; db := conn.GetConn() defer db.Close() //关联查询第二种方式：使用preload var userProfile2 UserProfile //Preload参数必须是关联关系名字 //后面可以用First也可以使用Find db.Debug().Preload(&quot;User&quot;).First(&amp;userProfile2, 1) fmt.Println(userProfile2) //查询到之后对User进行更新 //更新单个字段 //更新user_profile db.Model(&amp;userProfile2.User).Update(&quot;Addr&quot;, &quot;北京海淀区&quot;) fmt.Println(userProfile2) //如果要更新多个字段 db.Model(&amp;userProfile2.User).Update(&amp;User&#123;Name: &quot;未来城&quot;, Age: 30&#125;) fmt.Println(userProfile2)&#125; 【一对一操作】删除数据 通过UserProfile对User中的数据进行删除 对应的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;fmt&quot; &quot;gorm_demo/学习/conn&quot; &quot;log&quot;)/** * @Author: yirufeng * @Date: 2021/3/24 6:44 下午 * @Desc: **/type User struct &#123; Id int Name string Age int Addr string PId int //外键在另外一方&#125;type UserProfile struct &#123; Id int Pic string CPic string Phone string //关系在这一方,外键在另一方 User User `gorm:&quot;ForeignKey:PId;AssociationForeignKey:Id&quot;`&#125;func main() &#123; db := conn.GetConn() defer db.Close() //关联查询第二种方式：使用preload var userProfile2 UserProfile //Preload参数必须是关联关系名字 //后面可以用First也可以使用Find db.Debug().Preload(&quot;User&quot;).First(&amp;userProfile2, 1) fmt.Println(userProfile2) log.Println(&quot;----------------------------删除数据----------------------------&quot;) db.Debug().Delete(&amp;userProfile2.User)&#125; 【一对多操作】插入数据注意：方式二中因为多那方的数据是已经在数据库中了，并且一那方的数据不会重复插入。 两种方式推荐使用第一种方式，因为第二种方式可读性不是很好，也就是会让人以为插入两次同样的数据。 对应的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package mainimport &quot;gorm_demo/学习/conn&quot;/** * @Author: yirufeng * @Date: 2021/3/24 7:00 下午 * @Desc: 一对多操作 **///分类type Category struct &#123; Id int Name string Articles []Article `gorm:&quot;ForeignKey:CId;AssociationKey:Id&quot;` //所以到时候我们就可以通过Category来操作文章了&#125;//文章type Article struct &#123; Id int Title string Content string Desc string //外键在这里 CId int&#125;func main() &#123; db := conn.GetConn() defer db.Close() db.AutoMigrate(&amp;Category&#123;&#125;, &amp;Article&#123;&#125;) //方式一：关联添加 cate := Category&#123; Name: &quot;IT&quot;, Articles: []Article&#123; &#123; Title: &quot;python权威指南&quot;, Content: &quot;python基础库以及第三方包&quot;, Desc: &quot;python进行全面讲解&quot;, &#125;, &#123; Title: &quot;beego权威指南&quot;, Content: &quot;beego基础库以及第三方包&quot;, Desc: &quot;beego进行全面讲解&quot;, &#125;, &#125;, &#125; db.Debug().Create(&amp;cate) //方式二：我们先对已经有的文章数据(也就是数据已经在文章中了)关联到对应的分类 article1 := Article&#123; Title: &quot;beego权威指南&quot;, Content: &quot;beego基础库以及第三方包&quot;, Desc: &quot;beego进行全面讲解&quot;, &#125; article2 := Article&#123; Title: &quot;beego权威指南&quot;, Content: &quot;beego基础库以及第三方包&quot;, Desc: &quot;beego进行全面讲解&quot;, &#125; db.Create(&amp;article1) db.Create(&amp;article2) cate2 := Category&#123; Name: &quot;IT&quot;, Articles: []Article&#123; //注意：此时article1与article2都在数据库中了， //但是此时这里要插入cate2的话我们不会再重复插入article1与article2 article1, article2, &#125;, &#125; db.Debug().Create(&amp;cate2)&#125; 【一对多操作】三种查询方式 方式1： 方式2： 方式3： 【一对多操作】更新数据注意： 一对多进行更新的时候，如果不加上where条件，那么将会更新全部数据。一般我们都会加上where条件进行过滤。 【一对多操作】删除数据注意：一对多进行数据更新和删除的时候，一定要记得使用where条件对数据进行过滤，之后再修改或删除。 【多对多操作】增加数据 多对多的模型定义： 修改已有文章的引用： + 【多对多操作】三种查询方式related不演示了 preload：association： association分成两个容器去存储，因此前端渲染中我们采用related与preload多一些，不然还得根据外键去查找 【多对多操作】更新操作 + update也可以传入一个结构体来更改多个字段 【多对多操作】删除操作 info, note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://www.sivan.tech/tags/%E6%A1%86%E6%9E%B6/"},{"name":"orm","slug":"orm","permalink":"http://www.sivan.tech/tags/orm/"}],"author":"yirufeng"},{"title":"配置编程环境Linux服务器","slug":"配置编程环境Linux服务器","date":"2021-03-21T21:17:42.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/03/21/配置编程环境Linux服务器/","link":"","permalink":"http://www.sivan.tech/2021/03/21/%E9%85%8D%E7%BD%AE%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"前提：将所有软件包放到~目录下 安装Git 操作存放在~目录下的Git-v2.26.2.tar.gz文件 解压并安装 123456789tar -zxvf Git-v2.26.2.tar.gzyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc-c++ perl-ExtUtils-MakeMakercd git-2.26.2/yum -y install autoconfmake configure./configure --prefix=/usr/local/gitmake profix=/usr/local/gitmake installyum remove git 之后加入环境变量 编辑配置⽂件：vim /etc/profile尾部加⼊Git的bin路径配置即可：export GIT_HOME=/usr/local/git export PATH=$PATH:$GIT_HOME/bin执行source /etc/profile使环境变量⽣效即可。 安装JDK 操作存放在~目录下的jdk-8u161-linux-x64.tar.gz 卸载系统自带的openJDK rpm -qa | grep java yum -y remove 我们上一步执行的结果 开始安装我们自己的jdk cd /usr/local/mkdir javacd javatar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./编辑/etc/profile⽂件，在⽂件尾部加⼊如下JDK环境配置即可：1234JAVA_HOME=/usr/local/java/jdk1.8.0_161 CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATHsource /etc/profile验证安装结果：执行java -version与 javac 安装node 操作存放在~目录下的node-v12.16.3-linux-x64.tar.xzcd /usr/local/mkdir nodecd nodetar -xJvf /root/node-v12.16.3-linux-x64.tar.xz -C ./编辑/etc/profile⽂件，在⽂件尾部加⼊如下环境配置即可：12# Nodejs export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATHsource /etc/profile验证安装结果：执行node -v与 npm version与 npx -v都输出了版本信息即可。","text":"前提：将所有软件包放到~目录下 安装Git 操作存放在~目录下的Git-v2.26.2.tar.gz文件 解压并安装 123456789tar -zxvf Git-v2.26.2.tar.gzyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc-c++ perl-ExtUtils-MakeMakercd git-2.26.2/yum -y install autoconfmake configure./configure --prefix=/usr/local/gitmake profix=/usr/local/gitmake installyum remove git 之后加入环境变量 编辑配置⽂件：vim /etc/profile尾部加⼊Git的bin路径配置即可：export GIT_HOME=/usr/local/git export PATH=$PATH:$GIT_HOME/bin执行source /etc/profile使环境变量⽣效即可。 安装JDK 操作存放在~目录下的jdk-8u161-linux-x64.tar.gz 卸载系统自带的openJDK rpm -qa | grep java yum -y remove 我们上一步执行的结果 开始安装我们自己的jdk cd /usr/local/mkdir javacd javatar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./编辑/etc/profile⽂件，在⽂件尾部加⼊如下JDK环境配置即可：1234JAVA_HOME=/usr/local/java/jdk1.8.0_161 CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATHsource /etc/profile验证安装结果：执行java -version与 javac 安装node 操作存放在~目录下的node-v12.16.3-linux-x64.tar.xzcd /usr/local/mkdir nodecd nodetar -xJvf /root/node-v12.16.3-linux-x64.tar.xz -C ./编辑/etc/profile⽂件，在⽂件尾部加⼊如下环境配置即可：12# Nodejs export PATH=/usr/local/node/node-v12.16.3-linux-x64/bin:$PATHsource /etc/profile验证安装结果：执行node -v与 npm version与 npx -v都输出了版本信息即可。 安装python环境 默认自带了python2.7环境，但是我们要安装python3操作存放在~目录下的Python-3.8.3.tgz执行tar zxvf Python-3.8.3.tgz，则可以在当前⽬录得到⽂件夹：Python-3.8.3安装相关预备环境：yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make编译并安装：123cd Python-3.8.3/./configure prefix=/usr/local/python3make &amp;&amp; make install等安装过程完毕，/usr/local/python3 ⽬录就会⽣成了我们还需要将刚刚安装⽣成的⽬录/usr/local/python3⾥的python3可执⾏⽂件做⼀份软链接，链接到/usr/bin下，⽅便后续使⽤python312ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3验证安装：python3可以正常交互，同时键入python也可以正常交互。 MAVEN项目构建和管理工具安装 操作存放在~目录下的apache-maven-3.6.3-bin.tar.gz创建目录：mkdir /opt/maven将apache-maven-3.6.3-bin.tar.gz拷贝到/opt/maven目录下：cp apache-maven-3.6.3-bin.tar.gz /opt/maven/移动到目录：cd /opt/maven/执行命令解压：tar zxvf apache-maven-3.6.3-bin.tar.gz配置maven加速镜像源：修改/opt/maven/apache-maven-3.6.3/conf/settings.xml文件，并在&lt;mirrors&gt;&lt;/mirrors&gt;标签对里面添加如下内容：123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;&#x2F;id&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;&#x2F;mirror&gt;配置环境变量：编辑/etc/profile⽂件，在⽂件尾部加⼊如下环境配置即可：12export MAVEN_HOME=/opt/maven/apache-maven-3.6.3 export PATH=$MAVEN_HOME/bin:$PATH刷新环境变量让maven环境的路径配置生效：source /etc/profile检验安装结果：执行mvn -v可以打印出maven的版本信息，说明安装并且配置成功。 mysql数据库安装部署 操作存放在~目录下的mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz卸载系统⾃带的MARIADB（如果有）rpm -qa|grep mariadbyum -y remove 上一步的结果解压mysql安装包：tar -zxvf /root/mysql-5.7.30-linux-glibc2.12-x86_64.tar.gz -C /usr/local/cd /usr/localmv mysql-5.7.30-linux-glibc2.12-x86_64 mysql创建MYSQL⽤户和⽤户组：groupadd mysql 和 useradd -g mysql mysql修改MYSQL⽬录的归属⽤户：chown -R mysql:mysql ./准备mysql的配置文件：在/etc⽬录下新建my.cnf⽂件12345678910111213141516171819202122[mysql] # 设置mysql客户端默认字符集 default-character-set&#x3D;utf8 socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock[mysqld] skip-name-resolve #设置3306端⼝ port &#x3D; 3306 socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock # 设置mysql的安装⽬录 basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql # 设置mysql数据库的数据的存放⽬录 datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data # 允许最⼤连接数 max_connections&#x3D;200 # 服务端使⽤的字符集默认为8⽐特编码的latin1字符集 character-set-server&#x3D;utf8 # 创建新表时将使⽤的默认存储引擎 default-storage-engine&#x3D;INNODBlower_case_table_names&#x3D;1 max_allowed_packet&#x3D;16Mmkdir /var/lib/mysql 和 chmod 777 /var/lib/mysql正式安装：cd /usr/local/mysqlyum -y install numactl./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 得到结果：复制脚本到资源目录：cp ./support-files/mysql.server /etc/init.d/mysqld修改/etc/init.d/mysqld，修改其basedir和datadir为实际对应⽬录12basedir=/usr/local/mysql datadir=/usr/local/mysql/data设置mysql系统服务并开启自启⾸先增加mysqld服务控制脚本执⾏权限：chmod +x /etc/init.d/mysqld同时将mysqld服务加⼊到系统服务：chkconfig --add mysqld最后检查mysqld服务是否已经⽣效即可：chkconfig --list mysqld。结果如图所示：这样就表明 ⽤ service服务已经⽣效了，在2、3、4、5运⾏级别随系统启动⽽⾃动启动，以后可以直接使 命令控制 mysql 的启停。启动MysqlD：service mysqld start将MYSQL的BIN⽬录加⼊PATH环境变量：vim ~/.bash_profile，然后文件末尾添加如下信息：export PATH=$PATH:/usr/local/mysql/bin执行命令使环境变量生效：source ~/.bash_profile首次登陆mysql：mysql -u root -p 之后键入我们上面保存的密码进入mysql命令行：执行如下命令更换密码：⽐如这⾥将密码设置成简单的“111111”了。12mysql&gt;alter user user() identified by &quot;111111&quot;; mysql&gt;flush privileges;设置主机远程登陆：123mysql&gt; use mysql; mysql&gt; update user set user.Host&#x3D;&#39;%&#39; where user.User&#x3D;&#39;root&#39;; mysql&gt; flush privileges;最后利⽤NAVICAT等⼯具进⾏测试即可：注意：如果在最后的navicat工具连接不上自己的虚拟机，请确保防火墙关闭。 redis安装 操作存放在~目录下的redis-5.0.8.tar.gzcd /usr/local/mkdir rediscd redistar zxvf /root/redis-5.0.8.tar.gz -C ./cd redis-5.0.8/make &amp;&amp; make installcd utils/./install_server.sh：全部选择默认配置即可(直接回车)：查看状态：systemctl status redis_6379.service 得到如下图中的结果redis-cli vim /etc/redis/6379.conf设置允许远程连接：将bind 127.0.0.1修改为bind 0.0.0.0重启redis服务：systemctl restart redis_6379.service设置访问密码：将#requirepass foobared修改为requirepass 你想设置的密码重启redis服务：systemctl restart redis_6379.service执行redis-cli之后redis客户端执行命令都需要访问密码，使用auth 我们设置的redis密码 安装消息队列rabbitMQ 因为 RabbitMQ 需要 erlang环境的⽀持，所以必须先安装erlang。我们这⾥要安装的是 erlang-22.3.3-1.el7.x86_64.rpm，所以首先执行如下命令来安装其对应的yum repo ：注意：如果之前安装了rabbitMQ以及erlang，所以执行如下命令卸载rabbitMQ和erlang123yum list | grep erlangyum -y remove erlang-*yum remove erlang.x86_64123rabbitmqctl app_stopyum list | grep rabbitmqyum -y remove rabbitmq-server.noarchcurl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bashyum install erlang-22.3.3-1.el7.x86_64执行erl命令查看是否安装成功，安装rabbitMQ：curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.rpm.sh | sudo bashyum install rabbitmq-server-3.8.3-1.el7.noarch设置RABBITMQ开机启动：chkconfig rabbitmq-server on启动RABBITMQ服务：systemctl start rabbitmq-server.service开启WEB可视化管理插件：rabbitmq-plugins enable rabbitmq_management访问可视化管理界⾯：你的服务器IP:15672我们可以在后台先添加⼀个⽤户/密码对：rabbitmqctl add_user 可视化用户名 可视化用户名对应的密码和 rabbitmqctl set_user_tags 可视化用户名 administrator登录网页：你的服务器IP:15672 tomcat安装部署 操作存放在~目录下的apache-tomcat-8.5.55.tar.gzcd /usr/local/mkdir tomcatcd tomcattar -zxvf /root/apache-tomcat-8.5.55.tar.gz -C ./cd apache-tomcat-8.5.55/bin./startup.sh ，访问主机ip地址:8080得到下图的网页内容：cd /etc/rc.d/init.d/touch tomcatchmod +x tomcat，接下来编辑tomcat文件并键入如下内容：12345678910#!&#x2F;bin&#x2F;bash #chkconfig:- 20 90 #description:tomcat #processname:tomcat TOMCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;apache-tomcat-8.5.55 case $1 in start) su root $TOMCAT_HOME&#x2F;bin&#x2F;startup.sh;; stop) su root $TOMCAT_HOME&#x2F;bin&#x2F;shutdown.sh;; *) echo &quot;require start|stop&quot; ;;esac这样后续对于Tomcat的开启和关闭只需要执⾏如下命令即可：service tomcat start和service tomcat stopchkconfig --add tomcatchkconfig tomcat on nginx安装 操作存放在~目录下的nginx-1.17.10.tar.gzcd /usr/local/ mkdir nginx cd nginx tar zxvf /root/nginx-1.17.10.tar.gz -C ./ yum -y install pcre-devel yum -y install openssl openssl-devel 编译并安装： cd nginx-1.17.10/ ./configuremake &amp;&amp; make install安装完成之后，nginx可执行位置位于：/usr/local/nginx/sbin/nginx启动nginx：/usr/local/nginx/sbin/nginx如果想停⽌Nginx服务，可执⾏：/usr/local/nginx/sbin/nginx -s stop如果修改了配置⽂件后想重新加载Nginx，可执⾏：/usr/local/nginx/sbin/nginx -s reload注意其配置⽂件位于：/usr/local/nginx/conf/nginx.conf验证：访问主机ip地址可以得到下图中的网页： 安装docker 安装docker：yum install -y docker开启docker服务：systemctl start docker.service查看安装结果：docker version设置开机启动：systemctl enable docker.service配置DOCKER镜像下载加速：直接编辑配置⽂件：vim /etc/docker/daemon.json加⼊加速镜像源地址即可：123&#123; &quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]&#125;加完加速地址后，重新加载配置⽂件，重启 docker 服务即可：systemctl daemon-reload 和 systemctl restart docker.service kubernetes集群部署 因为是集群，暂时没有做 ELASTICSEARCH集群部署 因为是集群，暂时没有做 ZOOKEEPER安装部署 操作存放在~目录下的apache-zookeeper-3.6.1-bin.tar.gzcd /usr/local/mkdir zookeepercd zookeeper/tar -zxvf /root/apache-zookeeper-3.6.1-bin.tar.gz -C ./cd apache-zookeeper-3.6.1-bin/mkdir datacd conf/cp zoo_sample.cfg zoo.cfgsudo vim zoo.cfg：修改配置⽂件zoo.cfg，将其中的dataDir(/usr/local/zookeeper/apache-zookeeper-3.6.1-bin/data)修改为上⾯刚创建的data⽬录。cd .../bin/zkServer.sh start ./bin/zkServer.sh status 显示的结果如下： 因为我们安装的是3.6.1的版本(在3.5.5版本及以上，Zookeeper 提供了一个内嵌的Jetty容器来运行 AdminServer，默认占用的是 8080端口，AdminServer 主要是来查看 Zookeeper 的一些状态，如果机器上有其他程序（比如：Tomcat）占用了 8080 端口，也会导致 Starting zookeeper … FAILED TO START 的问题。)：如果出现Starting zookeeper … FAILED TO START，请在我们刚才的zoo.cfg配置文件最后添加配置项，修改后重启即可：12# admin portadmin.serverPort&#x3D;9000vim /etc/profile ，尾部加入zookeeper的bin路径配置即可：12export ZOOKEEPER_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.6.1-bin export PATH&#x3D;$PATH:$ZOOKEEPER_HOME&#x2F;binsource /etc/profile进入目录：cd /etc/rc.d/init.d，创建文件，并赋予执行权限，touch zookeeper与chmod +x zookeeper编辑zookeeper文件vim zookeeper：#!/bin/bash #chkconfig: - 20 90 #description: zookeeper #processname: zookeeper ZOOKEEPER_HOME=/usr/local/zookeeper/apache-zookeeper-3.6.1-bin export JAVA_HOME=/usr/local/java/jdk1.8.0_161 # 此处根据你的实际情况更换对 应 case $1 instart) su root $ZOOKEEPER_HOME/bin/zkServer.sh start;; stop) su root $ZOOKEEPER_HOME/bin/zkServer.sh stop;; status) su root $ZOOKEEPER_HOME/bin/zkServer.sh status;; restart) su root $ZOOKEEPER_HOME/bin/zkServer.sh restart;; *) echo &quot;require start|stop|status|restart&quot; ;;esac注意：如果出现service zookeeper does not support chkconfig说明我们这个zookeeper文件没写对，重新检查是否和上面的内容一致。最后加入开启启动即可：chkconfig --add zookeeper 和 chkconfig zookeeper on 消息队列kafka安装部署 因为Kafka依赖zookeeper，所以得先安装zookeeper操作存放在~目录下的kafka_2.12-2.5.0.tgzcd /usr/local/mkdir kafkacd kafkatar -zxvf /root/kafka_2.12-2.5.0.tgz -C ./cd /usr/local/kafka/kafka_2.12-2.5.0mkdir logscd config/修改配置⽂件server.properties，⼀是将其中的log.dirs修改为上⾯刚创建的logs⽬录，其他选项可以按需配置vim server.properties另外关注⼀下连接ZooKeeper的相关配置，根据实际情况进⾏配置：启动kafka：在kafka根目录下执行./bin/kafka-server-start.sh ./config/server.properties 或者如果需要后台启动，则加上-daemon参数即可，也就是执行命令：./bin/kafka-server-start.sh -daemon ./config/server.properties⾸先创建⼀个名为codesheep的topic：./bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic codesheep 创建完成以后，可以使⽤命令来列出⽬前已有的topic列表接下来创建⼀个⽣产者，⽤于在codesheep这个topic上⽣产消息：./bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic codesheep⽽后在另外一个终端创建⼀个消费者，⽤于在codesheep这个topic上获取消息：./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic codesheep此时⽣产者发出的消息，在消费者端可以获取到：","categories":[{"name":"linux","slug":"linux","permalink":"http://www.sivan.tech/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.sivan.tech/tags/linux/"},{"name":"服务器","slug":"服务器","permalink":"http://www.sivan.tech/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://www.sivan.tech/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"author":"yirufeng"},{"title":"极客时间-畅聊Go发展和面试","slug":"极客时间-畅聊Go发展和面试","date":"2021-03-19T21:46:50.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/03/19/极客时间-畅聊Go发展和面试/","link":"","permalink":"http://www.sivan.tech/2021/03/19/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E7%95%85%E8%81%8AGo%E5%8F%91%E5%B1%95%E5%92%8C%E9%9D%A2%E8%AF%95/","excerpt":"go语言是基础架构层 paas 的最重要的项目","text":"go语言是基础架构层 paas 的最重要的项目 周洋：Go程序员如何快速提高技术Go程序员如何快速提高技术调优：如何看协程阻塞情况，协程泄漏如何定位(go自带的工具是可以看到的)，如何看协程调用链情况如何避免死锁，如何做竞态检测实践：golang中很多都是重io操作的 毛大分享：如何搞定面试如何搞定面试方法论 + 实战经验充分准备面试 + 如何准备技术面试 + 如何准备hr面试：尽量找有类似岗位经验丰富的去聊一聊，万能的朋友圈，比如go有很多回忆，go meetup还有gocn 还有go夜读，关注社区，然后加入进去，经常活跃在群里面久而久之混熟，多关注一些朋友，他们有渠道，如果你靠谱他们会推荐你，例如脉脉加人刷题 + 终面抛开放性问题来优化（但是应聘者说接下来要对这个进行优化，说明考虑到这个问题）有技术视野 + 技术追求 + 开源贡献 + 技术书籍的翻译 + 工作态度，执行力是否强否（比如紧急任务要修复）比如存储设计，可用性，api设计什么样的，比如某一个组件挂了怎么弄？不要说一些似乎，可能这些词的话了解工作目标，面试反馈，对技术进一步的探讨(趁机可以加上微信)现在的面试官如果加了你微信，说明大概率喜欢你hr面试：谈资：如果你要double 工资或者很高的涨幅，我们可以拿其他公司的offer来counter 这家，但是避免拿A公司的offer count B公司的offer并且拿B公司的offer count A公司的offer，被知道之后就会觉得人品不好了。在公司里面看个人薪资和个人发展。背调：只要不和原公司闹瓣就行，毛大的课听完之后如果能理解P6肯定没问题。听完能形成自己的理解并把自己的项目升级，那么你p7就没问题了。如果能够更加对引用的文章和书籍还有论文阅读的话，那么就更加厉害了。 info, note info 默认主题色，适合中性的信息 查看代码测试","categories":[],"tags":[],"author":"yirufeng"},{"title":"linux下的五种网络IO模型以及select/poll/epoll区别","slug":"linux下的五种IO模型以及select-poll-epoll区别","date":"2021-03-19T13:25:51.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/19/linux下的五种IO模型以及select-poll-epoll区别/","link":"","permalink":"http://www.sivan.tech/2021/03/19/linux%E4%B8%8B%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Aselect-poll-epoll%E5%8C%BA%E5%88%AB/","excerpt":"前提知识：了解同步/异步，阻塞/非阻塞参考：聊聊同步、异步、阻塞与非阻塞 正题：5种IO模型 同步阻塞 同步非阻塞 异步IO IO多路复用 信号驱动IO 参考：聊聊Linux 五种IO模型 select/poll/epoll区别select, poll，以及epoll都是多路复用。 配合视频享用更加 这里插入我们的pdf图。。 场景：设计一个高性能的网络服务器，可以向多个客户端提供同时连接，并且可以处理这些客户端的请求。如何设计呢？","text":"前提知识：了解同步/异步，阻塞/非阻塞参考：聊聊同步、异步、阻塞与非阻塞 正题：5种IO模型 同步阻塞 同步非阻塞 异步IO IO多路复用 信号驱动IO 参考：聊聊Linux 五种IO模型 select/poll/epoll区别select, poll，以及epoll都是多路复用。 配合视频享用更加 这里插入我们的pdf图。。 场景：设计一个高性能的网络服务器，可以向多个客户端提供同时连接，并且可以处理这些客户端的请求。如何设计呢？ 两种方案： 多线程：每一个请求让一个线程去处理，但是需要线程频繁上下文切换，代价比较高 单线程（如果A传上来的消息正在处理，这个时候B传上来消息是否会丢失？不会丢失，因为迎接B传上来的数据这个人不是CPU,是我们专注于IO的DMA控制器来保证。这个过程中，cpu只是在开始和结束的时候做一下简单的中断处理，） DMA补充： “Direct Memory Access（存储器直接访问）。这是指一种高速的数据传输操作，允许在外部设备和存储器之间直接读写数据。整个数据传输操作在一个称为”DMA控制器”的控制下进行的。CPU除了在数据传输开始和结束时做一点处理外（开始和结束时候要做中断处理），在传输过程中CPU可以进行其他的工作（前提是未设置停止CPU访问）。这样，在大部分时间里，CPU和输入输出都处于并行操作。因此，使整个计算机系统的效率大大提高”。 DMA传送方式是让存储器与外设、或外设与外设之间直接交换数据，不需要经过CPU的累加器中转，减少了这个中间环节，并且内存地址的修改、传送完毕的结束报告都是由硬件电路实现的，因此大大地提高了数据的传输速度。一个DMA传送只需要执行一个DMA周期，相当于一个总线读写周期。 DMA是在专门的硬件（ DMA）控制下，实现高速外设和主存储器之间自动成批交换数据尽量减少CPU干预的输入/输出操作方式。 总结： select，poll，epoll 都是 IO 多路复用的机制 IO 多路复用就是实现一个进程可以监视多个文件句柄（socket、文件或者管道等等），一旦某个文件句柄就绪，就能够通知程序进行相应的读写操作。 select，poll，epoll 都是同步 IO。所谓同步 IO，便是读写是阻塞的 select、poll和epoll的区别 IO多路复用模型 select poll epoll 最大连接数限制 内核对 fd_set 集合的大小，为1024 无最大连接限制，原因是它是基于链表来存储的 连接数有上限，1/2G内存的机器上可以打开10/20万左右的连接。 连接大带来的IO效率 每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题” 同select epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少没有线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 消息传递方式 内核需要将消息传递到用户空间，都需要内核拷贝动作 同select epoll通过内核和用户空间共享一块内存来实现的。 时间复杂度 O(n) O(n) O(1) 特点 触发模式 水平触发 水平触发 水平触发LT和边缘触发ET 优点 缺点 1.调用 select 函数时，需要把 fd_set 集合从用户态拷贝到内核态，当 fd_set 集合很大时，这个开销将会非常巨大 2.调用 select 函数时，需要在内核遍历传递进来的所有 fd_set，当 fd_set 集合很大时，这个开销将会非常巨大 内核对被监控的 fd_set 集合大小做了限制 select，poll，epoll 之间的对比: IO 效率：select 只知道有 IO 事件发生，却不知道是哪几个流，只能采取轮询所有流的方式，故其具有 O(n) 的无差别轮询复杂度，处理的流越多，无差别轮询时间就越长；poll 与 select 并无区别，它的时间复杂度也是 O(n)；epoll 会将哪个流发生了怎样的 IO 事件通知我们（当描述符就绪时，系统注册的回调函数会被调用，将就绪描述符放到 readyList 里面），它是事件驱动的，其时间复杂度为 O(1) 操作方式：select 和 poll 都是采取遍历的方式，而 epoll 则是采取了回调的方式 底层实现：select 的底层实现为数组，poll 的底层实现为链表，而 epoll 的底层实现为红黑树 最大连接数：select 的最大连接数为 1024 或 2048，而 poll 和 epoll 是无上限的 对描述符的拷贝：select 和 poll 每次被调用时都会把描述符集合从用户态拷贝到内核态，而 epoll 在调用 epoll_ctl 时会拷贝进内核并保存，之后每次 epoll_wait 时不会拷贝 性能：epoll 在绝大多数情况下性能远超 select 和 poll，但在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，因为 epoll 的通知机制需要很多函数回调 水平触发与边缘触发水平触发(level-trggered) 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知 边缘触发(edge-triggered) 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知 两者的区别在哪里呢？水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次 select函数定义1int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout); poll函数定义1int poll(struct pollfd *fds, nfds_t nfds, int timeout); epoll函数定义123456int epoll_create(int size);//创建epoll实例，会创建所需要的红黑树，以及就绪链表，以及代表epoll实例的文件句柄int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//对于添加到epfd的文件描述符fd, 添加或者删除或者修改， 对应的eventint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);//等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中 参考 面试必备：对 select，poll，epoll 的详细解析 Linux面试必知: 一句话讲透epoll","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/categories/Linux/"},{"name":"网络","slug":"Linux/网络","permalink":"http://www.sivan.tech/categories/Linux/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"IO","slug":"IO","permalink":"http://www.sivan.tech/tags/IO/"},{"name":"多路复用","slug":"多路复用","permalink":"http://www.sivan.tech/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"}],"author":"yirufeng"},{"title":"互联网系统架构演进之路","slug":"互联网系统架构演进之路","date":"2021-03-15T21:20:44.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/15/互联网系统架构演进之路/","link":"","permalink":"http://www.sivan.tech/2021/03/15/%E4%BA%92%E8%81%94%E7%BD%91%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"缓存本地缓存：与我们的应用程序部署在一起。速度极快，因为与我们的应用在一个地方，不足：缓存的数据量有限，与我们的应用程序争抢内存。远程分布式缓存：部署在远程的主机上，远程主机可以做到按需扩展，相较于本地缓存，性能会稍微差一点，因为必须要通过一次网络访问，但是相较于从数据库查取通过空间换得了时间， 常用缓存组件：memcache + redis 缓存更强的服务器也是有天花板的，但是使用了集群之后我们可以按需进行扩展，有很强的可扩展能力。应用集群之后，我们前面需要一个负载均衡调度服务器，那么负载均衡需要什么能力呢？高性能，高并发，因为所有的请求都会经过负载均衡调度服务器，负载均衡的实现方式（3个方式：软件，硬件，DNS）我们在中间件讲过。 软件方式中nginx性能优异，如果配置高一点，10w并发没问题，并且消耗资源很少，所以现在中小型用的多。当并发量超过了Nginx处理能力之后，我们可以选用LVS。硬件的方式在中小型很少用，在大型用的多，能力优于软件，一个几十万DNS负载均衡利用的是域名解析的过程，我一个域名对应多个Ip地址，当机器发送域名到域名服务器解析的时候，每次返回一个不同的ip地址实现负载均衡。如果忘记负载均衡记得回顾中间件的视频，并且还有一个直播课里面讲了负载均衡的面试。 此时前台我们的并发就没有问题了，但是经过一段时间的发展，我们的后端又有了压力。 我们采用主从复制，将读写分开（因为合在一起压力比较大），所以采用数据库集群的方式，利用主流数据库都有主从热备这么一个功能来做读写分离，利用的是主从复制，一个主库，一个从库。 注意：读写分离之后，我们自然就需要有一个数据访问模块，因为如果没有数据访问模块，我们的应用程序面临的是后端有多个数据库。 CDN与反向代理CDN：内容分发网络，必须要部署在电信运营商的数据中心里面，原理：比如我们买个东西，只在杭州有，但是我是乌鲁木齐的，找个代理商将商品寄存到它那里，然后再来访问的时候就不需要到杭州了，直接在乌鲁木齐拿货走了。适用于静态资源，将我们的静态资源提前缓存到电信运营商的数据中心里面去。当我们的用户通过电信网络发出请求的时候，请求一定走到电信的数据中心里面，然后进行路由分发，一看请求地址对应的资源在我的cdn服务器资源商，于是就直接返回了。反向代理服务器：也是将静态资源缓存到反向代理服务器上，与CDN的区别：地点不一样，反向代理服务器是部署在数据中心的最外层的，还是在数据中心里面，但是是整个应用系统的最外层，反向代理与CDN原理都是缓存，提前将我们需要的资源缓存上去。避免请求跑到应用服务器上。 info, 好处： 继续发展： 原来的单文件服务器变成了分布式文件系统，是一个集群，可以按需进行扩展，原来的数据库读写分离之后，已经是一个集群了，但是读写分离之后，每一个数据库服务器存的都是相同的拷贝数据，那么数据量一大存不下来，所以现在变成了分库分表，也就是分布式系统。 疑问：分布式文件系统怎么做？分库分表怎么做？ 分布式文件系统不可以用hdfs存储，因为hdfs是用来存储大数据(大文件，将每个大文件分成数据块，之后小文件不够数据块大小依然是按照一个数据块的大小来存储)的。 数据访问模块就不可以使用mybatis插件了，因为涉及到了分库分表，处理变得复杂，所以使用开源的数据库中间件。 比如我们的电商系统网易严选，电子商务系统里面，商品是一张表的存储，商品各行各业字段是不一样的，因此这样一个存储要定义很多字段，每一个分类都并不是很多字段都需要。找一个商品的时候我们做搜索使用模糊查询，我们知道模糊查询对于索引是没有效果的，此时搜索性能很差，我们就需要用NoSQL（分布式）和搜索引擎（因为我们数据量很大） NoSQL 和 搜索引擎服务器就是用来解决存储的多样化，非模式的各种方式，还有搜索引擎。 搜索引擎Lucence：apache基金会支持的顶级项目，开源搜索引擎开发工具包，如果系统里面具有搜索的需要就可以将其集成到系统里面。solr是lucence下面的子项目，是一个已经开发好的子平台，拿过来之后直接部署就可以使用，功能提供非常多，比如高亮等搜索引擎中的基本功能，es也是基于lucence开发的，直接拿过来就可以使用的， 发展过来我们就是一个工程，当我们做的事情越来越多的时候就会越来越庞大，但是我们希望加入更多的业务，比如3天一次版，5天一次版 如上图所示我们对应用进行了拆分，拆分出多个应用 引用消息中间件做解耦，以及应用之间的通信服务 还有RocketMQ 将相同的大家都用到的模块做成服务，大家不需要再去拥有它相关的模块了，只要调用对应的服务就可以了， 我们将服务做成分布式的，可以用该服务来连接各个系统与各个数据库。此时我们引入了服务，就要引入配置中心，那么如何做服务化，如何做配置中心呢？ 微服务：图上的齿轮代表是一个服务提供者，或者调用者SOA：SOA里面有一个很重要的概念就是ESB，企业服务总线，我们的服务都是连到ESB里面的，传统的服务就是采用的这种，缺点就是ESB这个中心点容易出现瓶颈，因为所有的服务都是通过它来传递的。微服务：微服务里面没有总线（中心点）的概念，谁调用谁就连接谁，是彼此之间可以互联的，我们的服务也是可以做出负载均衡的。同样还有一个问题：我们用了微服务之后，服务之间互相调用，那么涉及到一个服务治理的问题，比如启动A服务依赖于B服务，并且有一些服务应用一段时间之后发现不需要这么多资源，那么如何进行治理，这就涉及到微服务治理的过程。 注意：此时引入的3个系统不直接与我们的应用分布式系统关联了 按照这个路线不断积累，各个击破，就可以成为技术大牛 架构设计思想总结：分而治之：我们前端压力太大，数据库压力太大，缓存存储不下来，文件存储不下来，高并发，海量数据存储，都可以通过分布式系统来进行解决，随网站所需灵活应对业务发展驱动技术发展，技术发展反哺业务软件系统的价值在于它能为用户提供什么价值，在于网站能做什么，而不在于它是怎么做的。主要是为了提供用户给价值的，而不是高大上的 大公司的设计方案并不一定适用于你的场景。并且有一些问题可以通过业务手段来解决，一定要加强业务理解，并不一定需要通过技术来解决。比如12306抢票我们可以通过分时间卖票来解决。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.sivan.tech/categories/%E6%9E%B6%E6%9E%84/"},{"name":"学习路线","slug":"架构/学习路线","permalink":"http://www.sivan.tech/categories/%E6%9E%B6%E6%9E%84/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.sivan.tech/tags/%E6%9E%B6%E6%9E%84/"},{"name":"学习路线","slug":"学习路线","permalink":"http://www.sivan.tech/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"author":"yirufeng"},{"title":"基本数据结构-map","slug":"基本数据结构-map","date":"2021-03-08T07:48:05.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/08/基本数据结构-map/","link":"","permalink":"http://www.sivan.tech/2021/03/08/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-map/","excerpt":"","text":"什么是map 为什么要用map map的底层如何实现 map内存模型 创建map 哈希函数 key定位过程 map的两种get操作 【面试重点】如何进行扩容 【重点】map的遍历 map的赋值 map的删除 map进阶 可以边遍历边删除么 key可以是float类型么 总结 参考资料 面试经常被问到golang map的扩容，特此记录下来 map的结构 golang中map是采用哈希查找表以及链表法来解决冲突， 查看map内部的构造：golang 1.15.5 的 runtime/map.go 中查看源码 12345678910111213141516// A header for a Go map.type hmap struct &#123; // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler&#x27;s definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields&#125; 结构剖析，hmap 共有9个属性：count，表示map中键值对的个数flags，标志位，表示当前map的状态B，表示我们map中元素的个数，buckets的对数log_2noverflow，overflow的bucket的近似数hash0，计算key的时候传入我们hash函数的一个随机种子buckets，指向我们旧桶，也就是还没有搬迁的oldbuckets，扩容的时候oldbuckets将会是buckets的两倍nevacuate，指示扩容进度，小于此地址的buckets搬迁完成 map中key定位过程： 用户传入的key经过哈希计算(需要两个参数，一个是key，一个是hmap的hash0字段的值)之后获得哈希值，共64个Bit， 最后的B（hmap结构体中B的值）个bit位决定落在哪个桶。 同时哈希值的高8位为此key在bucket中的位置（tophash），如果对应的bucket没找到还要去找后面的overflow bucket。 【重点】map扩容 通过汇编语言可以找到赋值操作对应源码中的函数是 mapassign 时机在向map中插入新key的时候，会进行条件检测，符合下面两个条件，就会触发扩容： 装载因子（计算公式：localFactor = count/(2^B)）超过阈值，源码里定义的阈值是 6.5。 overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。 如下是判断是否需要扩容的代码： 1234567 // Did not find mapping for key. Allocate new cell &amp; add entry.// If we hit the max load factor or we have too many overflow buckets,// and we&#x27;re not already in the middle of growing, start growing.if !h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123; hashGrow(t, h) goto again // Growing the table invalidates everything, so try again&#125; 计算装载因子的函数： 1234// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.func overLoadFactor(count int, B uint8) bool &#123; return count &gt; bucketCnt &amp;&amp; uintptr(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)&#125; 判断是否有太多的overflow buckets： 1234567891011121314// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.// Note that most of these overflow buckets must be in sparse use;// if use was dense, then we&#x27;d have already triggered regular map growth.func tooManyOverflowBuckets(noverflow uint16, B uint8) bool &#123; // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B &gt; 15 &#123; B = 15 &#125; // The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code. return noverflow &gt;= uint16(1)&lt;&lt;(B&amp;15)&#125; 流程： 解释一下： 第1个条件：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。 第2个条件：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。 不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。 对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。 对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。 对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。 搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。 对于条件 1，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。 对于条件 2，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 rehash。 再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。 // 指向 x，y 中的 key xk, ykunsafe.Pointer // 指向 x，y 中的 value xv, yvunsafe.Pointer ) // 默认是等 size 扩容，前后 bucket 序号不变 【重点】map的遍历 注意，遍历都是遍历的 bucket 指针，也就是所谓的新 buckets，oldbuckets指向的是旧桶 当我们在遍历 map 时，并不是固定地从 0 号 bucket 开始遍历，每次都是从一个随机值序号的 bucket 开始遍历，并且是从这个 bucket 的一个随机序号的 cell 开始遍历。这样，即使你是一个写死的 map，仅仅只是遍历它，也不太可能会返回一个固定序列的 key/value 对了。 初始化startBucket(也就是从哪个桶开始遍历)以及offset（从哪个cell开始，对应桶的第1个元素经过的偏移） 从startBucket中的offset对应元素开始遍历，一直遍历到overflow buckets为空 之后遍历下一个bmap中的桶，如果此时startBucket为最后一个则回到开头，也就是循环遍历，直到所有桶都遍历完成， 来到一个桶首先要检查是否搬迁 如果没有搬迁，则要取出搬迁后分配到新的startBucket桶的那些元素 不断循环 note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計 查看代码测试 搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。 对于条件 1，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。 对于条件 2，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 rehash。 上面说的 hashGrow() 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。 理解了上面 bucket 序号的变化，我们就可以回答另一个问题了：为什么遍历 map 是无序的？ map 在扩容后，会发生 key 的搬迁，原来落在同一个 bucket 中的 key，搬迁后，有些 key 就要远走高飞了（bucket 序号加上了 2^B）。而遍历的过程，就是按顺序遍历 bucket，同时按顺序遍历 bucket 中的 key。搬迁后，key 的位置发生了重大的变化，有些 key 飞上高枝，有些 key 则原地不动。这样，遍历 map 的结果就不可能按原来的顺序了。 源码部分比较好看懂，尤其是理解了前面注释的几段代码后，再看这部分代码就没什么压力了。所以，接下来，我将通过图形化的方式讲解整个遍历过程，希望能够清晰易懂。 迭代：","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"基本数据结构","slug":"go/基本数据结构","permalink":"http://www.sivan.tech/categories/go/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"go的基本数据结构","slug":"go的基本数据结构","permalink":"http://www.sivan.tech/tags/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"yirufeng"},{"title":"redis知识汇总","slug":"redis知识汇总","date":"2021-03-07T13:58:58.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/03/07/redis知识汇总/","link":"","permalink":"http://www.sivan.tech/2021/03/07/redis%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"redis就数据结构 单线程 高可用 缓存应用 reidis 数据结构!&gt; redis中键的类型是字符串，值的数据类型有很多 字符串 列表 字典 集合 有序集合 bitmap hyperloglog geospatial stream（5.0推出的数据类型。支持多播的可持久化的消息队列，用于实现发布订阅功能，借鉴了kafka的设计。 对应的底层实现： 字符串： embstr编码：是专门用于保存短字符串的一种优化编码方式，跟正常的字符编码会调用两次内存分配函数来分别创建 redisObject 和 sdshdr 结构（动态字符串结构），而 embstr 编码则通过调用一次内存分配函数来分配一块连续的内存空间， 列表两种实现方法： 压缩列表(ziplist)：相较于数组存储每个元素大小固定，必须以元素中最长的作为长度存储，因此压缩列表相比于数据会节省内存。如图所示： 双向循环链表 使用压缩列表的条件（列表中存储的数据量比较少）： 列表中保存的单个数据(有可能是字符串类型)小于64字节 列表中数据个数少于512个 压缩列表的两个好处： 节省内存 支持不同类型数据的存储。 因为数据存储在一片连续的内存空间，通过键获取值为列表类型的数据，读取效率非常高。 字典两种实现方法： 压缩列表 散列表 当存储数据量比较少，才会使用压缩列表，具体需要同时满足如下两个条件： 字典中保存的键和值的大小都要小于64字节 字典中键值对的个数都要小于512个 散列表：redis使用murmurhash2这种运行速度快，随机性号的哈希算法作为哈希函数。对于哈希冲突，使用链表法进行解决，除此之外，还支持散列表的动态扩容、缩容。由于散列表中数据量增大，装载因子不断增大，因此为了避免性能下降，当装载因子大于1的时候，会进行扩容，扩容大小为原来的2倍左右。装载因子小于0.1的情况下会触发缩容，缩小为字典中数据个数的大约2倍大小。由于扩容和缩容需要做大量的数据搬移和哈希值的重新计算，比较耗时，redis中我们使用散列表中的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。 集合两种实现方式： 有序数组 散列表 当同时满足如下两个条件的时候就使用有序数组： 存储的数据都是整数 存储的数据元素个数不超过512个 有序集合两种实现方式 压缩列表 跳表 数据量比较小的时候，redis会用压缩列表来实现有序集合，有两个前提： 所有数据的大小都要小于64字节 元素个数要小于128个 如何将数据结构持久化到硬盘？我们主要有两种解决思路。 第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存 的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思 路。1.1 不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时 间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建 散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重 构数据结构的耗时就不可忽视了。 第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这 样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都 保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新 计算哈希值。 References redis九大数据类型数据结构及底层源码 数据结构与算法之美：52 note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計 查看代码测试","categories":[{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/tags/redis/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"}],"author":"yirufeng"},{"title":"进程,线程与协程区别和联系","slug":"进程-线程与协程区别和联系","date":"2021-03-05T17:50:58.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/03/05/进程-线程与协程区别和联系/","link":"","permalink":"http://www.sivan.tech/2021/03/05/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/","excerpt":"!&gt; 很多题目还没有完善，之后会慢慢补充并完善…… 进程概念进程：正在执行程序的一个实例，是资源分配的基本单位。（进程控制块（process control block）描述进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对PCB的操作） 线程概念线程：进程中的单条流向，是程序独立调度的基本单位。（线程控制块（process control block）描述线程的基本信息和运行状态，所谓的创建和撤销线程，都是指对TCB的操作） 协程概念协程可以理解为用户态的线程，其实就是可以被暂停以及可以被恢复运行的函数。虽然线程也可以自己暂停和恢复，只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。这就是为什么有的人说可以把协程理解为用户态线程的原因。参考","text":"!&gt; 很多题目还没有完善，之后会慢慢补充并完善…… 进程概念进程：正在执行程序的一个实例，是资源分配的基本单位。（进程控制块（process control block）描述进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对PCB的操作） 线程概念线程：进程中的单条流向，是程序独立调度的基本单位。（线程控制块（process control block）描述线程的基本信息和运行状态，所谓的创建和撤销线程，都是指对TCB的操作） 协程概念协程可以理解为用户态的线程，其实就是可以被暂停以及可以被恢复运行的函数。虽然线程也可以自己暂停和恢复，只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见。这就是为什么有的人说可以把协程理解为用户态线程的原因。参考 进程是由什么组成的？有哪些数据？ 进程是由进程控制块、程序段、数据段三部分组成; 进程具有创建其他进程的功能，而程序没有。 主要有如下几部分数据： ❎线程是由什么组成的？有哪些数据？❎协程是由什么组成的？有哪些数据？协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 ❎进程上下文切换细节进程上下文切换需要切换页表等重量级资源，线程上下文切换只需要切换寄存器等轻量级数据 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 ❎线程上下文切换细节协程上下文切换细节协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 进程，线程，协程各自的联系与区别进程与线程区别： （拥有资源）一个进程可以有多个线程，由于线程不拥有资源，这几个线程共享进程内的资源。 （资源开销）创建和撤销线程比进程开销小很多，因为创建线程仅仅需要堆栈空间以及程序计数器就可以了而创建进程需要分配地址空间，数据资源等，开销比较大。 （调度）由于线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，但是两个不同进程中的线程切换会引起进程切换。 （通信）线程可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。 进程是资源分配的基本单位，线程是独立运行和独立调度的基本单位(CPU上真正运行的是线程) 多线程程序中只要有一个线程死掉了，整个进程也死掉了，而一个进程死掉了，并不会对另一个进程造成影响，因为进程有自己独立的地址空间 线程与协程区别以goroutine为例 线程就是内核级线程，协程就是用户级线程，着重点在于编程语言自己设计的调度器的效率高低，如果调度器做的好，并发会比线程好很多。 创建：协程是一种用户态的轻量级线程，创建开销比线程低。原因：内存栈占用少(原来一个进程可以占用几G，线程占用几M，将goroutine内存大小改为了几KB，从而我们可以大量的使用goroutine) 切换：协程之间切换成本没有线程切换成本高：就是这个goroutine执行完切换到下个goroutine的执行栈上去执行这个成本超级低， 调度：GMP是两级线程模型：用户有绑定内核线程，内核主要负责cpu调度，用户主要对接内核 进程生命周期 创建状态：系统已为其分配了PCB，但进程所需资源尚未分配，进程还未进入主存，即创建工作尚未完成，进程还不能被调度运行。 就绪状态：进程已分配到除CPU以外打的所有必要资源，等待获得CPU。 执行状态：进程已获得CPU，程序正在执行。 阻塞状态：正在执行的进程由于某事件而暂时无法继续执行时，放弃处理机而自行阻塞。 终止状态：进程到达自然结束点或者因意外被终结，将进入终止状态，进入终止状态的进程不能再执行，但在操作系统中仍然保留着一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。参考： 线程生命周期 新生状态：在程序中用构造方法（new操作符）创建一个新线程时，如new Thread(r)，该线程就是创建状态，此时它已经有了相应的内存空间和其它资源，但是还没有开始执行。 就绪状态：新建线程对象后，调用该线程的start()方法就可以启动线程。当线程启动时，线程进入就绪状态（runnable）。由于还没有分配CPU，线程将进入线程队列排队，等待 CPU 服务，这表明它已经具备了运行条件。当系统挑选一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态。系统挑选的动作称之为“CPU调度”。一旦获得CPU线程就进入运行状态并自动调用自己的run方法。 运行状态：当就绪状态的线程被调用并获得处理器资源时，线程就进入了运行状态。此时，自动调用该线程对象的run()方法。run()方法定义了该线程的操作和功能。运行状态中的线程执行自己的run方法中代码。直到调用其他方法或者发生阻塞而终止。 阻塞状态：一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入输出操作时，suspend()、 wait()等方法，线程都将进入堵塞状态。堵塞时，线程不能进入排队队列，只有当引起堵塞的原因被消除后，线程转入就绪状态。重将让出 CPU 并暂时中止自己的执行，进入堵塞状态。在可执行状态下，如果调用 sleep()、 新到就绪队列中排队等待，这时被CPU调度选中后会从原来停止的位置开始继续执行。 死亡状态：线程调用stop()方法、destory()方法或 run()方法执行结束后，线程即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。 进程之间如何通信 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。 有名管道(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 进程之间的同步方法：1、临界区（Critical Section）:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。优点：保证在某一时刻只有一个线程能访问数据的简便办法 缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。 2、互斥量（Mutex）:为协调共同对一个共享资源的单独访问而设计的。 互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。 优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 缺点：①互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。 ②通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。 3、信号量（Semaphore）:为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。 优点：适用于对Socket（套接字）程序中线程的同步。（例如，网络上的HTTP服务器要对同一时间内访问同一页面的用户数加以限制，只有不大于设定的最大用户数目的线程能够进行访问，而其他的访问企图则被挂起，只有在有用户退出对此页面的访问后才有可能进入。） 缺点：①信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点； ②信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担； ③核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。 4、事件（Event）: 用来通知线程有一些事件已发生，从而启动后继任务的开始。 优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作 线程之间的同步方式🙋 我 ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式： 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操 协程之间的同步方式 以goroutine为例 time.Sleep channel sync.WaitGroup 参考 线程之间如何通信 使用全局变量：主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile 使用消息实现通信：在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。 使用事件CEvent类实现线程间通信：Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。协程之间如何通信 共享内存 channel进程调度算法 先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。 优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。 ❎【没问到】进程之间共享什么，不共享什么线程之间共享什么，不共享什么共享的资源有： 堆。 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的） 全局变量 。它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的 静态变量。 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的 文件等公用资源。 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。 独享的资源有： 栈 。栈是独享的 寄存器 。 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC ❎【没问到】协程之间共享什么，不共享什么❎孤儿进程，危害以及如何解决孤儿进程的出现❎僵尸进程，危害以及解决办法❎上层协程结束了，如果通知到子协程也结束❎用户态和内核态 用户态(user mode)：用户态运行的进程可以直接读取用户程序的数据。 系统态(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。 为什么会有用户态，因为进程在执行过程中需要完成一些操作系统提供的功能，比如读写文件，涉及到了与硬盘打交道，这个过程是由操作系统来完成的，进程只需要给操作系统发出请求，操作系统代表进程在内核中执行，这个时候就处于核心态。这也是核心态体现的地方 ❎内核态线程和用户态线程的区别如何切换❎fork之后的父子进程虚拟内存空间的相同与不同什么是线程安全参考 多线程线程的弊端 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换. 更多的线程需要更多的内存空间 线程中止需要考虑对程序运行的影响. 通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生 一个进程是如何被挂起的 主动挂起：通过sleep让进程间歇性挂起。sleep的原理之前有分析过，就不再分析。大概的原理：就是设置一个定时器，到期后唤醒进程。而后修改进程为挂起状态，等待唤醒。 被动挂起：场景比较多，主要是进程申请一个资源，但是资源没有满足条件。参考 ❎一个线程是如何被挂起的❎【没问到】一个协程是如何被挂起的❎进程池 线程池 协程池多线程中会对全局变量进行pad操作，请问是为啥？面试官解释说是padding操作，也就是struct中的内存对其那种 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 参考 参考 JavaGuide 今日份面试题： 自我介绍的时候说本科学过java，之后被问现在为什么学Go,说了go比java并发强很多，之后引申出了如下问题 讲一下进程，线程，协程区别和联系 说一下进程，线程，协程的组成 fork之后的父子进程虚拟内存空间的相同与不同：fork 复制父进程的页表+写时复制 僵尸进程与孤儿进程危害，如何解决？ 讲一下线程上下文切换 讲一下进程的状态和上下文切换 一个进程是如何被挂起的，线程呢？ 上层协程结束了，如果通知到子协程也结束 内核态线程和用户态线程的区别如何切换 线程有共享数据么，共享什么，不共享什么？进程之间呢？协程之间呢？ 计网：https过程讲一下，为啥非对称加密是安全的(自己说了不可逆) 证书链，根域名？（问不下去了） 数据库：慢查询优化思路，一般是什么原因? 算法：有的任务有优先级，有的任务有依赖关系，如何设计，用什么数据结构，之后又问如何设计具体的算法呢？","categories":[{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/categories/OS/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/tags/OS/"}],"author":"yirufeng"},{"title":"二叉树，二叉搜索树，AVL树，B树，B+树","slug":"算法学习-树-二叉搜索树","date":"2021-02-23T18:04:01.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2021/02/23/算法学习-树-二叉搜索树/","link":"","permalink":"http://www.sivan.tech/2021/02/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"二叉树树形结构，但是树中每个节点的分支最多只有两个，我们叫做二叉树 二叉搜索树(BST)!&gt; 二叉搜索树又叫二叉排序树，或二叉查找树。它或者是一颗空树或者是具有下列性质的二叉树： 若它的左子树不为空，则左子树上的所有节点的值均小于它的根节点的值 若它的右子树不为空，则右子树上的所有节点的值均大于它的根节点的值 它的左右子树也分别是二叉排序树 平衡二叉树(AVL)!&gt; 平衡二叉树(self-balancing binary search tree或height-balanced binary search tree)是一颗二叉排序树，其中每个节点的左右子树高度差至多等于1高度平衡：要么是一颗空树，要么它的左右子树都是平衡二叉树并且左右子树的深度之差的绝对值不超过1。我们将左子树深度减去右子树深度的值称为平衡因子(BF, balance factor) B树背景：前面我们讨论的数据结构所处理的数据都是在内存中的，因此考虑的都是内存中运算时间的复杂度。倘若我们操作的数据集非常大，大到内存没法处理怎么办？比如数据库中上千万条记录以及硬盘中的上万个文件等，在这种情况下，对数据的处理需要不断从硬盘等存储设备中调入或调出内存页面。一旦涉及到这样的外存设备，时间复杂度的计算就发生了变化，我们还必须考虑访问外存的时间以及访问外存的次数。 多路查找树也叫B树，其中每个节点的孩子数可以多余两个，且每个节点处可以存储多个元素，由于它是查找树，所有元素之间存在某种特定的排序关系。 例如2-3树，是这样的一颗多路查找树，每个节点都有两个孩子(称为2节点)或三个孩子(称为3节点)一个2节点包含一个元素和两个孩子，一个3节点包含3个孩子和两个元素，并且2-3树中所有叶子都在同一层上。 B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，节点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树 一个m阶的B树具有如下属性： 如果根结点不是叶结点，则其至少有两棵子树。 每一个非根的分支结点都有k-1个元素和k个孩子，其中。每一个叶 子结点n都有k-1个元素，其中。 所有叶子结点都位于同一层次。 所有分支结点包含下列信息数据 B+树","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"树","slug":"算法/树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"}],"tags":[{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://www.sivan.tech/tags/Algorithms/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"AVL树","slug":"AVL树","permalink":"http://www.sivan.tech/tags/AVL%E6%A0%91/"},{"name":"B树","slug":"B树","permalink":"http://www.sivan.tech/tags/B%E6%A0%91/"},{"name":"B+树","slug":"B-树","permalink":"http://www.sivan.tech/tags/B-%E6%A0%91/"}],"author":"yirufeng"},{"title":"go底层汇编学习","slug":"go底层汇编学习","date":"2021-02-10T09:53:33.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/02/10/go底层汇编学习/","link":"","permalink":"http://www.sivan.tech/2021/02/10/go%E5%BA%95%E5%B1%82%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"虽然go汇编是plan9汇编，但是x86汇编与go汇编是相通的 程序编译的几个阶段：编译-&gt;汇编-&gt;优化—&gt;链接 一个代码经过汇编之后就生成了汇编代码，然后经过编译器优化，优化之后进行链接，最终得到可执行程序。这里说的优化是汇编优化，实际上我们在所有阶段都有优化， 编译的话，广义上就是指的我们整个编译阶段，狭义上的话就是说词法语法分析，但是这个阶段还没有编译 我们虽然写的是汇编代码，但是实际上机器指定的是0101的这些序列，这就是汇编和机器码的关系，指令集是指一般每一种cpu都会给你提供你可以用的指令的集合， 指令寄存器存储的是我们代码的地址，CPU在解释指令的时候是一条一条解释的，没有并发这种。通过这个地址器中的值就可以找到我们的指令，大部分不需要理解，知道通用寄存器，和简单的扩展寄存器就可以了。 函数调用都是有一个函数栈存在的，有函数栈的话可能会发生栈溢出，函数栈是同一个函数跳转或者调用另外一个函数的时候栈的结构，将参数按照规范传入到栈上，然后在被调用函数中我们可以读取到被传入的参数，然后用这些参数做一些业务逻辑，最后返回值。 intel cpu上栈是从高地址向低地址生长 被调用函数如何读取到形参：在老的平台上所有参数都是通过栈传入，我在传入的时候其实只需要读这个位置就可以了，后来到了64位平台上寄存器数量变多，c语言很多编译器尽量在参数比较少的函数调用的时候做优化，会将我们前6个参数传入到寄存器中，我具体用哪几个寄存器都是约定好的，在栈上都是只传第7个以后的参数， 每一个函数都有自己的栈，栈一般用rbp(栈的栈底，frame base pointer)以及rsp(栈的栈顶，很靠近调用该函数的位置，所以直接向上找到输入参数即可)描述 我们之前原来函数的时候在上半部分搞事情，调用函数的时候，会将调用者下一条指令传入到return address这个地方中，之后被调用函数执行完之后拿到原来的地址返回去执行下一条指令，之后被调函数的栈其实进行了名义上的销毁，并没有改变值，只是我们后面执行其他指令的时候如果栈往下增长就会将原来的内容进行覆盖，64位系统中，6个参数以内的都是通过寄存器传入，6个以外的通过函数栈传入， 任意的编程语言自己分配内存的时候，其实都需要自己对这段内存清0，os并不保证，go语言中其实都是给我们赋0，回收的时候并不需要自己赋值0，成本太高。 通用寄存器是16个 section .data表示我的代码是在哪个段， 执行syscall也就是进行了系统调用将会切换到内核态 我们写的go执行成plan9的汇编，最终还是要转换到各个平台的汇编 MOVB $1, DI -&gt; mov al, 0x44 // 1 byte英特尔的汇编是将44挪到al里面，然后前面我们的plan9表示将1挪到DI里面。 程序有基本的分段概念，text段就是代码存储的位置，也就是代码段jbe指令是大于等于就跳转，sub rsp, 0x18是将rsp(因为是我们的栈顶)向下移动 lea是做地址运算的(自己查到的：取有效地址，也就是取偏移地址)call是调用函数mov是移动JNE是不等于就跳转 生成两种汇编形式的代码：哪种舒服用哪种 golang中函数的参数以及返回值都是通过函数栈来进行的 我们写的代码最终都在编译的时候转成内部函数，make一个slice和make一个map编译后底层都是不一样的，所以我们可以通过反汇编进行分析 go会根据逃逸分析进行分配确定是在堆还是栈中， 程序在编译之后，编译器会在编译后的代码的函数头部和函数尾部插入两段调度指令，中间是逻辑 nosplit表示go的栈空间不够就会重新分配，顺便将执行权交给runtime，（如果我们非常确定栈的大小之后编译器就不会在函数头部和尾部插入调度指令，这两段指令就是为了检查我们是否需要扩容，如果扩容就跳到插入到函数尾部的代码等）为什么会重新分配：一个g初始化之后，栈只有2kb，慢慢随着深层次函数的递归调用会慢慢增长，增长到一定程度会溢出。 汇编的结果是go tool compile -S 文件名.go反汇编是使用go build生成的.o文件，然后使用go tool objdump 我们的二进制文件 如果我们线上遇到问题，可以pprof(1.11将火焰图都集成进去了 )指令看到goroutine栈以及死锁之类的，帮助我们快速定位问题。 note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計 查看代码测试 查看默认打开的折叠框 参考 深入Go的底层，带你走近一群有追求的人 GO汇编-函数 汇编常用指令 曹大的文章","categories":[],"tags":[],"author":"yirufeng"},{"title":"基本数据结构-slice","slug":"基本数据结构-slice","date":"2021-02-10T09:29:35.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/02/10/基本数据结构-slice/","link":"","permalink":"http://www.sivan.tech/2021/02/10/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-slice/","excerpt":"查看slice结构查看slice内部的构造：在runtime/slice.go中查看源码 123456// runtime/slice.gotype slice struct &#123; array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量&#125; 结构剖析，slice 共有三个属性：指针，指向底层数组，同一个底层数组可以被多个slice同时指向，因此只要有一个slice修改，其他指向该底层数组的slice也会被修改； 长度，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；容量，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。 对切片进行赋值的时候，实际是对表层结构体的拷贝，但是拷贝出来的结构体与原来的结构体的array指向同一个底层数组。 切片的三种状态平常我们创建切片的方式有很多种，其实里面就包含了我们切片中的三种状态（零切片，nil切片，空切片），只是很少有人关注罢了 创建方式一 创建方式二 特点 zero slice 【任意数据类型都可以】s1 := make([]int, 10) 【指针类型】s2 := make([]*int, 10) 数组中的元素值都是对应类型的零值 nil slice var s1 []int s1 := *new([]int) 底层数组是nil empty slice s1 := make([]int, 0) s1 := []int&#123;&#125; 底层数组都指向某一个特殊的内存地址(zerobase)","text":"查看slice结构查看slice内部的构造：在runtime/slice.go中查看源码 123456// runtime/slice.gotype slice struct &#123; array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量&#125; 结构剖析，slice 共有三个属性：指针，指向底层数组，同一个底层数组可以被多个slice同时指向，因此只要有一个slice修改，其他指向该底层数组的slice也会被修改； 长度，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；容量，底层数组的元素个数，容量 &gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。 对切片进行赋值的时候，实际是对表层结构体的拷贝，但是拷贝出来的结构体与原来的结构体的array指向同一个底层数组。 切片的三种状态平常我们创建切片的方式有很多种，其实里面就包含了我们切片中的三种状态（零切片，nil切片，空切片），只是很少有人关注罢了 创建方式一 创建方式二 特点 zero slice 【任意数据类型都可以】s1 := make([]int, 10) 【指针类型】s2 := make([]*int, 10) 数组中的元素值都是对应类型的零值 nil slice var s1 []int s1 := *new([]int) 底层数组是nil empty slice s1 := make([]int, 0) s1 := []int&#123;&#125; 底层数组都指向某一个特殊的内存地址(zerobase) nil切片与我们的空切片的区别：nil 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 nil 切片，看原因3。创建出来的nil slice，它的长度和容量都为0。指向数组的指针也是0。这里比较混淆的是empty slice，empty slice的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0(zerobase)。空切片和 nil slice 比较的结果为false。nil切片与nil比较为true，空切片与nil比较为false序列化之后的结果，nil切片json序列化之后为null，但是空切片序列化之后为[]也就是我们json中的空数组结构体中有一个切片属性，我们创建结构体的时候没有给切片属性赋值默认是nil切片，如果赋值[]int&#123;&#125;则为空切片。如下案例中，c1的students就是一个empty slice，但是c2的students是一个nil slice1234567891011type class struct &#123; students []int&#125;func main() &#123; c1 := class&#123; students: []int&#123;&#125;, &#125; c2 := class&#123; &#125;&#125; 截取 语法：data[low:high:max] 要求low &lt;= high &lt;= max，此时长度为high-low，容量为max-low。也就是长度不包括high指向的元素，容量不包括max指向的元素。 s1 := slice[2:5] 表示s1是从slice的2号索引开始，目前的最后一个元素是位于slice的4号索引，也就是说长度位于5号索引位置，容量没有给出的话默认是slice结束 s2 := s1[2:6:7] 表示s2是从s1的2号索引开始，目前的最后一个元素位于s1的5号索引，也就是说长度位于6号索引位置(不包括6号位置)，容量是位于7号索引(不包括7号位置) 如图所示： 案例：以下结果输出什么？123456789101112131415func main() &#123; slice := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; s1 := slice[2:5] s2 := s1[2:6:7] s2 = append(s2, 100) s2 = append(s2, 200) s1[2] = 20 fmt.Println(s1) fmt.Println(s2) fmt.Println(slice)&#125; 输出结果： 123[2 3 20][4 5 6 7 100 200][0 1 2 3 20 5 6 7 100 9] 扩容 使用append添加元素，如果容量不够将会进行扩容，调用的是growslice函数传入的三个参数分别是：老的元素的类型，老的切片，最小求得的容量 golang 1.15.5 的 runtime/slice.go 中的growslice函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// growslice handles slice growth during append.// It is passed the slice element type, the old slice, and the desired new minimum capacity,// and it returns a new slice with at least that capacity, with the old data// copied into it.// The new slice&#x27;s length is set to the old slice&#x27;s length,// NOT to the new requested capacity.// This is for codegen convenience. The old slice&#x27;s length is used immediately// to calculate where to write new values during an append.// TODO: When the old backend is gone, reconsider this decision.// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.func growslice(et *_type, old slice, cap int) slice &#123; if raceenabled &#123; callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice)) &#125; if msanenabled &#123; msanread(old.array, uintptr(old.len*int(et.size))) &#125; if cap &lt; old.cap &#123; panic(errorString(&quot;growslice: cap out of range&quot;)) &#125; if et.size == 0 &#123; // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn&#x27;t need to preserve old.array in this case. return slice&#123;unsafe.Pointer(&amp;zerobase), old.len, cap&#125; &#125; newcap := old.cap doublecap := newcap + newcap if cap &gt; doublecap &#123; newcap = cap &#125; else &#123; if old.len &lt; 1024 &#123; newcap = doublecap &#125; else &#123; // Check 0 &lt; newcap to detect overflow // and prevent an infinite loop. for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123; newcap += newcap / 4 &#125; // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap &lt;= 0 &#123; newcap = cap &#125; &#125; &#125; var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don&#x27;t need any division/multiplication. // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch &#123; case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) &gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 &#123; // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63 &#125; else &#123; shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31 &#125; lenmem = uintptr(old.len) &lt;&lt; shift newlenmem = uintptr(cap) &lt;&lt; shift capmem = roundupsize(uintptr(newcap) &lt;&lt; shift) overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift) newcap = int(capmem &gt;&gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) &#125; // The check of overflow in addition to capmem &gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // type T [1&lt;&lt;27 + 1]int64 // // var d T // var s []T // // func main() &#123; // s = append(s, d, d, d, d) // print(len(s), &quot;\\n&quot;) // &#125; if overflow || capmem &gt; maxAlloc &#123; panic(errorString(&quot;growslice: cap out of range&quot;)) &#125; var p unsafe.Pointer if et.ptrdata == 0 &#123; p = mallocgc(capmem, nil, false) // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) &#125; else &#123; // Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory. p = mallocgc(capmem, et, true) if lenmem &gt; 0 &amp;&amp; writeBarrier.enabled &#123; // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata) &#125; &#125; memmove(p, old.array, lenmem) return slice&#123;p, old.len, newcap&#125;&#125; 扩容规则：新的slice的容量大于等于原来的slice的1.25倍或2倍。当slice容量小于1024的时候，新的容量是原来的2倍，但是超过了1024之后，先是扩容到原来的1.25倍容量，之后还要进行一次内存对齐。 注意点 将一个切片作为参数与将一个切片的指针作为参数的区别： 将切片作为参数，如果我们切片进行扩容或者底层数组的指向改变，那么调用者对应的切片指向的底层数组不会改变 将切片指针作为参数，如果切片 参考 深度解密Go语言之Slice 码洞《深度解析 Go 语言中「切片」的三种特殊状态》","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"基本数据结构","slug":"go/基本数据结构","permalink":"http://www.sivan.tech/categories/go/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"go的基本数据结构","slug":"go的基本数据结构","permalink":"http://www.sivan.tech/tags/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"yirufeng"},{"title":"Golang中使用gdb调试工具","slug":"gdb调试工具的使用","date":"2021-02-01T21:59:22.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/02/01/gdb调试工具的使用/","link":"","permalink":"http://www.sivan.tech/2021/02/01/gdb%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"gdb 工具的安装!&gt; 以mac系统为例 1brew install gdb 使用场景通常情况下，我们使用gdb是为了研究底层源码的实现，比如go中的runtime的入口在哪里？ go中使用 编译go程序的时候，要带上编译信息，也就是使用命令go build --gcflags=all=&quot;-N -l&quot; . 执行命令 gdb 二进制文件的名字 就可以进入gdb调试了 gdb 中常用命令的使用note info 注意：gdb中命令行有一个特点，如果我们在命令中没有任何输入按下回车将会重复上一个命令，但是有一些命令不会，例如run list：将当前行号所在的代码打印出来 加一个断点：break 断点所在的行 或者 b 断点所在的行。 当我们执行run命令之后将会停在第一个断点上，然后使用next或ns执行到下一行，如果想要跟踪进去调用函数的内部，我们使用命令s进入调用函数的内部，如果我们想要退出该函数了，我们可以使用命令return退出返回到调用代码的地方，如果想要查看某一个变量的值，可以使用命令p 变量名，如果我们不想每次都打印指定的变量，我们可以使用info args打印参数或info locals打印本地变量next：执行下一行 使用info files命令，看到有一个entry point，也就是代码是从这里开始执行的，我们想要让代码在入口停下，我们在入口加上一个端点，也就是在entry point对应的值的地址加上断点b 对应的地址 list。列出代码，输入第一次后如果输入回车，那么就会重复以上命令 break。加断点，一般是list之后，break 行号来加断点 bt。打印调用链 info files。打印调试文件信息 run。运行所要调试的代码 up 和 down。在frame里跳来跳去 info args 和 info locals 打印参数和本地变量 whatis 和 p。打印变量和想要看的值，例如数组啊，函数啊，都可以 info goroutines。查看所有的goroutine及其ID goroutine 命令。对对应的goroutine执行命令。 q。退出 help。打印帮助文档 参考参考安装教程使用教程使用视频","text":"gdb 工具的安装!&gt; 以mac系统为例 1brew install gdb 使用场景通常情况下，我们使用gdb是为了研究底层源码的实现，比如go中的runtime的入口在哪里？ go中使用 编译go程序的时候，要带上编译信息，也就是使用命令go build --gcflags=all=&quot;-N -l&quot; . 执行命令 gdb 二进制文件的名字 就可以进入gdb调试了 gdb 中常用命令的使用note info 注意：gdb中命令行有一个特点，如果我们在命令中没有任何输入按下回车将会重复上一个命令，但是有一些命令不会，例如run list：将当前行号所在的代码打印出来 加一个断点：break 断点所在的行 或者 b 断点所在的行。 当我们执行run命令之后将会停在第一个断点上，然后使用next或ns执行到下一行，如果想要跟踪进去调用函数的内部，我们使用命令s进入调用函数的内部，如果我们想要退出该函数了，我们可以使用命令return退出返回到调用代码的地方，如果想要查看某一个变量的值，可以使用命令p 变量名，如果我们不想每次都打印指定的变量，我们可以使用info args打印参数或info locals打印本地变量next：执行下一行 使用info files命令，看到有一个entry point，也就是代码是从这里开始执行的，我们想要让代码在入口停下，我们在入口加上一个端点，也就是在entry point对应的值的地址加上断点b 对应的地址 list。列出代码，输入第一次后如果输入回车，那么就会重复以上命令 break。加断点，一般是list之后，break 行号来加断点 bt。打印调用链 info files。打印调试文件信息 run。运行所要调试的代码 up 和 down。在frame里跳来跳去 info args 和 info locals 打印参数和本地变量 whatis 和 p。打印变量和想要看的值，例如数组啊，函数啊，都可以 info goroutines。查看所有的goroutine及其ID goroutine 命令。对对应的goroutine执行命令。 q。退出 help。打印帮助文档 参考参考安装教程使用教程使用视频","categories":[{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"调试","slug":"调试","permalink":"http://www.sivan.tech/tags/%E8%B0%83%E8%AF%95/"},{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/tags/%E5%B7%A5%E5%85%B7/"}],"author":"yirufeng"},{"title":"Golang-逃逸分析","slug":"Golang-逃逸分析","date":"2021-01-28T18:26:04.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2021/01/28/Golang-逃逸分析/","link":"","permalink":"http://www.sivan.tech/2021/01/28/Golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","excerpt":"两个命令知识$ go tool compile -m pro_2.go 打印出编译器逃逸分析的过程，使用 -m 参数。 $ go tool compile -S pro_2.go &gt; pro_2.S go tool compile -S pro_2.go用于反编译代码为汇编代码，这里后面使用pro_2.S表示输出到pro_2.S文件中 逃逸分析 核心：go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 作用：go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。 具体流程参考 总结Golang中一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定。","text":"两个命令知识$ go tool compile -m pro_2.go 打印出编译器逃逸分析的过程，使用 -m 参数。 $ go tool compile -S pro_2.go &gt; pro_2.S go tool compile -S pro_2.go用于反编译代码为汇编代码，这里后面使用pro_2.S表示输出到pro_2.S文件中 逃逸分析 核心：go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 作用：go语言声称这样可以释放程序员关于内存的使用限制，更多的让程序员关注于程序功能逻辑本身。 具体流程参考 总结Golang中一个函数内局部变量，不管是不是动态new出来的，它会被分配在堆还是栈，是由编译器做逃逸分析之后做出的决定。","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"逃逸分析","slug":"go/逃逸分析","permalink":"http://www.sivan.tech/categories/go/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逃逸分析","slug":"逃逸分析","permalink":"http://www.sivan.tech/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"}],"author":"yirufeng"},{"title":"iTeach与广州的羁绊","slug":"iTeach与广州的羁绊","date":"2020-12-27T21:18:20.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/27/iTeach与广州的羁绊/","link":"","permalink":"http://www.sivan.tech/2020/12/27/iTeach%E4%B8%8E%E5%B9%BF%E5%B7%9E%E7%9A%84%E7%BE%81%E7%BB%8A/","excerpt":"前言 随着11月通知的发布，被老师通知和师弟师妹组成team一起携手，熬了10多个夜晚赶了一个科普类的卡通视频以及一个软件出来，初赛上传之后，边一直等待消息，12月7号终于看到了团队作品入围决赛，于是开始着手准备决赛的作品打磨以及广州之行。广州之行和3个小伙伴一起，师弟师妹以及学妹，一路上嘻嘻哈哈走过来少不了互相鼓励与调侃，虽然都是第一次见面但韩式很快就融入成了一个旅游的小团队，伴随着2020年iTeach全国大学生数字化教育应用创新大赛圆满落幕，自己的广州旅行也到此结束。 比赛经过时间 2020.12.17 参赛选手报到：分配赛区以及抽序号 2020.12.18 参加开幕式以及正式比赛 2020.09 颁奖典礼与教育论坛 精彩瞬间","text":"前言 随着11月通知的发布，被老师通知和师弟师妹组成team一起携手，熬了10多个夜晚赶了一个科普类的卡通视频以及一个软件出来，初赛上传之后，边一直等待消息，12月7号终于看到了团队作品入围决赛，于是开始着手准备决赛的作品打磨以及广州之行。广州之行和3个小伙伴一起，师弟师妹以及学妹，一路上嘻嘻哈哈走过来少不了互相鼓励与调侃，虽然都是第一次见面但韩式很快就融入成了一个旅游的小团队，伴随着2020年iTeach全国大学生数字化教育应用创新大赛圆满落幕，自己的广州旅行也到此结束。 比赛经过时间 2020.12.17 参赛选手报到：分配赛区以及抽序号 2020.12.18 参加开幕式以及正式比赛 2020.09 颁奖典礼与教育论坛 精彩瞬间 我们买的17号广州南去武汉的车票，回来是20号下午两点广州南出发到武汉的车票，17号下午报道完之后就到了6点多吃了晚饭回去备战了，我和学妹是第2天上午比赛，师弟和师妹是第2天下午去比赛，第2天上午去比赛，最后时间特别紧，浪费在了寻找自己文件，所以很感谢评委老师从答辩的5分钟时间里抽了1分钟让我快速讲完项目。老师问的问题也是我故意没有透露的项目最核心的要素，就是和其他方法的对比，是我们项目的最大优势。晚上一起吃饭完去”小蛮腰”广州塔以及珠江边闲逛，最后去了琶醍边聊天边喝了杯酒。 18号上午参加了颁奖典礼之后和团队去了陈家祠，然后去了宝华路吃了鲜虾云吞面以及椰子蛋糕，去了沙面，北京路步行街，以及最后的天河附近。 遗憾去过很多地方旅行，从没有像这次这么匆忙，准备去石圣心教堂发现关门，大晚上还奔着白云山拍夜景，还好后来路上看到已经关门就早点和团队成员下车去了天河广场附近吃了八合里牛肉火锅，最后愣是在一个关门的精品礼物店买了几个小礼物带回去给同学。","categories":[{"name":"旅行","slug":"旅行","permalink":"http://www.sivan.tech/categories/%E6%97%85%E8%A1%8C/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://www.sivan.tech/tags/%E6%97%85%E8%A1%8C/"},{"name":"杂记","slug":"杂记","permalink":"http://www.sivan.tech/tags/%E6%9D%82%E8%AE%B0/"}],"author":"yirufeng"},{"title":"iTerm-Mac自定义自己的终端","slug":"iTerm-Mac自定义自己的终端","date":"2020-12-22T19:16:48.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/22/iTerm-Mac自定义自己的终端/","link":"","permalink":"http://www.sivan.tech/2020/12/22/iTerm-Mac%E8%87%AA%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%88%E7%AB%AF/","excerpt":"看一下效果：","text":"看一下效果： 步骤过程安装iTerm21.1 安装 iterm2 后，修改 Report Terminal Type为 xterm-256color：依次Preferences &gt; Profiles &gt; Terminal &gt; Report Terminal Type，设为xterm-256color修改主题下载支持图标的字体下载将我们自己的配置覆盖到~目录 参考过程参考详细文档参考其他人的配置自己的配置","categories":[{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/categories/tools/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/tags/%E5%B7%A5%E5%85%B7/"},{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/tags/tools/"}],"author":"yirufeng"},{"title":"使用gin解决CORS跨域问题","slug":"使用gin解决CORS跨域问题","date":"2020-12-21T19:42:46.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/21/使用gin解决CORS跨域问题/","link":"","permalink":"http://www.sivan.tech/2020/12/21/%E4%BD%BF%E7%94%A8gin%E8%A7%A3%E5%86%B3CORS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"什么是跨域问题相同的源：如果两个页面的协议端口还有主机都相同，那这两个页面具有相同的源。 跨域问题在请求发送之前，浏览器会先发送一个option请求给gin项目，之后gin项目需要告知浏览器授权访问的协议，端口或者方法，浏览器接收到后台传给前台的访问的这些控制信息，再进一步是否决定正式请求。 option请求也叫域请求 如何解决跨域问题对于跨域问题的几种解决方法： 包括前端的jsond 和 反向代理 后端的api拦截option请求返回浏览器一个控制信息 如下代码是使用gin自己封装了一个CORS中间件进行跨域 使用gin解决跨域问题 1234567891011121314151617181920212223func CORSMiddleware() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; fmt.Println(&quot;--------------------------允许跨域中间件--------------------------&quot;) //通过中间件给header写入允许访问的域名或方法 //这里最后一个参数传入的是允许前台的域名访问，因此最后一个参数应该是前台的域名加端口 //ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:63343/&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) //设置缓存时间 ctx.Writer.Header().Set(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;) //指定方法，可以传入POST以及GET，但是也可以用*代替所有的方法 ctx.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) //如果option请求直接返回200 if ctx.Request.Method == http.MethodOptions &#123; ctx.AbortWithStatus(http.StatusOK) &#125; else &#123; ctx.Next() &#125; &#125;&#125;","text":"什么是跨域问题相同的源：如果两个页面的协议端口还有主机都相同，那这两个页面具有相同的源。 跨域问题在请求发送之前，浏览器会先发送一个option请求给gin项目，之后gin项目需要告知浏览器授权访问的协议，端口或者方法，浏览器接收到后台传给前台的访问的这些控制信息，再进一步是否决定正式请求。 option请求也叫域请求 如何解决跨域问题对于跨域问题的几种解决方法： 包括前端的jsond 和 反向代理 后端的api拦截option请求返回浏览器一个控制信息 如下代码是使用gin自己封装了一个CORS中间件进行跨域 使用gin解决跨域问题 1234567891011121314151617181920212223func CORSMiddleware() gin.HandlerFunc &#123; return func(ctx *gin.Context) &#123; fmt.Println(&quot;--------------------------允许跨域中间件--------------------------&quot;) //通过中间件给header写入允许访问的域名或方法 //这里最后一个参数传入的是允许前台的域名访问，因此最后一个参数应该是前台的域名加端口 //ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:63343/&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) //设置缓存时间 ctx.Writer.Header().Set(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;) //指定方法，可以传入POST以及GET，但是也可以用*代替所有的方法 ctx.Writer.Header().Set(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;) ctx.Writer.Header().Set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) //如果option请求直接返回200 if ctx.Request.Method == http.MethodOptions &#123; ctx.AbortWithStatus(http.StatusOK) &#125; else &#123; ctx.Next() &#125; &#125;&#125; 参考 参考 参考","categories":[{"name":"golang","slug":"golang","permalink":"http://www.sivan.tech/categories/golang/"}],"tags":[{"name":"跨域问题","slug":"跨域问题","permalink":"http://www.sivan.tech/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"name":"CORS","slug":"CORS","permalink":"http://www.sivan.tech/tags/CORS/"}],"author":"yirufeng"},{"title":"jwt-go的使用","slug":"jwt-go的使用","date":"2020-12-13T19:57:08.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/13/jwt-go的使用/","link":"","permalink":"http://www.sivan.tech/2020/12/13/jwt-go%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"了解JWT jwt简称为json web token，一般用于用户认证(前后端分离/微信小程序/app开发)。紧凑且安全，特别适合分布式站点的单点登录 JWT通常用在请求头的Authorization字段中，形如：Authorization: Bearer &lt;token&gt;，也是最标准传递JWT的方法","text":"了解JWT jwt简称为json web token，一般用于用户认证(前后端分离/微信小程序/app开发)。紧凑且安全，特别适合分布式站点的单点登录 JWT通常用在请求头的Authorization字段中，形如：Authorization: Bearer &lt;token&gt;，也是最标准传递JWT的方法 JWT的构成 header: 指明了加密算法的类型以及JWT的类型，因为是JWT所以类型固定写成”JWT”1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 加密步骤：首先将json转换成字符串，然后使用base64加密，然后将加密后的字符串中的+号使用_代替，以及里面的\\用某个字符替代 payload: 是我们存放有效信息的载体加密步骤：首先将json转换成字符串，然后使用base64加密，然后将加密后的字符串中的+号使用_代替，以及里面的\\用某个字符替代 verify signature: 第一部分加密后的密文与第二部分的密文拼接起来，形成s1 对s1使用第一部分头部指定的algo方法进行加密，同时进行加盐，此时生成一个密文s2 对s2加密之后的密文再做base64Url加密 返回给用户 公式如下：HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret_key)具体：第一部分的密文与第二部分的密文拼接起来，对前两部分的密文进行第一部分指定的algo方法(上面是hs256)的加密，同时进行加盐(就是放一个随机字符串，确保加盐其他人不知道，对我们来说很重要)。此时生成一个hash256的密文。对hash256加密之后的密文再做base64url加密 注意：由于base64编码是可逆的，因为payload中存的信息是可逆的base64编码，所以第二部分的数据上实际上是可以逆向到明文的，因此我们不可以在payload中存放隐私数据。 以后用户再来访问的时候都需要携带token，后端都需要对token进行校验 校验步骤： i. 获取token ii. 第一步：对token切割 iii. 第二步：将第二段进行base64url解密，拿到payload，验证payload中的超时时间是否超时 iv. 第三步：验证第3段合法性（md5以及hash256都不可以反解），将第1，2段进行algo指定的方法(上面是hs256)加密，加密之后得到密文与我们第3段通过base64url解密之后的字符串进行比对，如果密文相等表示token没有修改过，此时认证通过 如果将payload中的超时时间修改了，即使前两段认证通过，但是第3段我们是对第一段以及第二段中的内容进行加密，所以第三段验证将不会通过，即使用户修改了第3段，但是没有我们的盐值也是无法进行修改成和我们一样的。 使用的时候如何做？已经有模块帮我们做了，内部已经帮我们实现了对应的算法， 真正在企业里面如何使用：一般都是集成在中间件中，我们用户想访问一些需要登录的接口将会访问对应的中间件，例如我们的jwt中间件 JWT验证执行流程普通的token验证执行流程： 1. 首先用户进行登录，服务端生成一个token，服务端自己保存一份，之后服务端会将token返回给前端或浏览器，每个token都有一个对应的失效时间 2. 之后用户所有的操作都会携带token去访问，我们服务端都要对这个token进行校验。 JWT的执行流程如下： 用户提交用户名以及密码进行登录，如果登录成功，创建一个JWT返回给用户注意：使用JWT生成的token是由3段字符串组成的，中间通过”.”进行连接，第一段字符串：叫做header, 一般我们写后台登录只需要用session以及cookie就可以了，但是如果要前后端分离需要使用jwt golang中使用JWT进行校验 这里我们使用gin结合jwt-go将其封装成一个中间件，对需要进行认证的使用该中间件进行认证 12 补充参考之前在一个帖子上看到说数据库中每一个用户的salt值都是随机的，用户注册的时候生成并且存入数据库中，注册执行过程如下： 获取用户的明文密码 随机生成一个salt 将salt以及用户使用的salt加密后的密码存入到数据库中，因为进行登录的时候我们还需要使用salt进行认证 登录执行过程如下： 获取用户输入的密码 去查询数据库对应的salt 对用户密码使用salt进行加密并与数据库中的密文进行比对 使用方式 JWT的特点 参考武佩奇老师的jwt课程阮一峰老师的jwt讲解使用gin + jwt-go实现restful api校验JWT内部具体如何做的JWT-GO中间件使用参考 note info 默认主题色，适合中性的信息 标题（可选）Windows 10不是為所有人設計,而是為每個人設計 查看代码测试","categories":[{"name":"jwt","slug":"jwt","permalink":"http://www.sivan.tech/categories/jwt/"},{"name":"go","slug":"jwt/go","permalink":"http://www.sivan.tech/categories/jwt/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"jwt","slug":"jwt","permalink":"http://www.sivan.tech/tags/jwt/"},{"name":"jwt-gos","slug":"jwt-gos","permalink":"http://www.sivan.tech/tags/jwt-gos/"}],"author":"yirufeng"},{"title":"(LeetCode系列)寻找旋转排序数组中的值","slug":"寻找旋转排序数组中的值","date":"2020-12-08T11:49:36.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/08/寻找旋转排序数组中的值/","link":"","permalink":"http://www.sivan.tech/2020/12/08/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%80%BC/","excerpt":"前言在旋转数据中搜索值包括两个系列的题型：搜索旋转点(也就是最小值)以及搜索我们给定的目标值。关于旋转排序数组的定义这里就不再赘述","text":"前言在旋转数据中搜索值包括两个系列的题型：搜索旋转点(也就是最小值)以及搜索我们给定的目标值。关于旋转排序数组的定义这里就不再赘述 为何每次选取mid位置对应的元素与right位置对应的元素比较 旋转排序数组中找旋转点 寻找旋转点其实也就是寻找旋转排序数组中的最小值 这个问题下又包含两个题目：一个是给定的旋转排序数组没有重复值，另外一个是给定的旋转排序数组中有重复值 选择target因为题目中没有给出明显的target，对于这类型题目，一般我们都是选取端点。 这里假设选取左端点，如果nums[mid] &gt; nums[l]，并不能说明最小值就在mid左边，因为可能数组发生了旋转，最小值会在mid右边，因而使用nums[l]作为target无法确定最小值在哪一侧。 因而这里我们选择右侧即nums[r] 没有重复值思路每次我们都在有效的搜索区间[l, r]中找到该区间上的中点mid，此时有以下几种情形：nums[mid] &gt; nums[r] 说明数组在[l, mid]上是递增的，因此旋转点一定在mid右侧，l = mid + 1nums[mid] &lt; nums[r] 说明数组在[mid, r]上是递增的，因此旋转点一定在mid左侧(包含mid)，r = midnums[mid] == nums[r] 因为数组中不存在重复值，所以当出现这种情况时，一定有l == mid == r 此时一定指向最小值，直接返回即可 代码 123456789101112131415161718192021func findMin(nums []int) int &#123; l, r := 0, len(nums)-1 for l &lt;= r &#123; if nums[l] &lt; nums[r] &#123; return nums[l] &#125; mid := l + (r-l)&gt;&gt;1 if nums[mid] &gt; nums[r] &#123; l = mid + 1 &#125; else if nums[mid] &lt; nums[r] &#123; r = mid &#125; else if nums[mid] == nums[r] &#123; return nums[mid] &#125; &#125; //随便返回一个即可，不会走到这里 //因为最小值一定存在 return -1&#125; 有重复值思路每次我们都在有效的搜索区间[l, r]中找到该区间上的中点mid，此时有以下几种情形：nums[mid] &gt; nums[r] 说明数组在[l, mid]上是递增的，因此旋转点一定在mid右侧，l = mid + 1nums[mid] &lt; nums[r] 说明数组在[mid, r]上是递增的，因此旋转点一定在mid左侧(包含mid)，r = midnums[mid] == nums[r] 此时最小值可能在左侧也可能在右侧，例如[1, 1, 1, 0, 1]最小值在右侧，[1, 0, 1, 1, 1]最小值在左侧，因而无法确定。所以只能一步一步不断缩减区间，让r = r - 1 代码 1234567891011121314151617181920212223func findMin(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; l, r := 0, len(nums)-1 for l &lt;= r &#123; if nums[l] &lt; nums[r] &#123; return nums[l] &#125; mid := l + (r-l)&gt;&gt;1 if nums[mid] &gt; nums[r] &#123; l = mid + 1 &#125; else if nums[mid] &lt; nums[r] &#123; r = mid &#125; else if nums[mid] == nums[r] &#123; r = r - 1 &#125; &#125; //最后结束时一定有l = r + 1，所以因为r向左移动了一步就直接返回l return nums[l]&#125;s 参考 没有重复值 有重复值 旋转排序数组中找目标值 数组中元素没有重复 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** ✅ * @Author: yirufeng * @Date: 2020/12/3 7:52 下午 * @Desc:执行用时：4 ms, 在所有 Go 提交中击败了78.30%的用户内存消耗：2.5 MB, 在所有 Go 提交中击败了96.57%的用户 **/func search(nums []int, target int) int &#123; if len(nums) == 0 &#123; return 0 &#125; l, r := 0, len(nums)-1 for l &lt;= r &#123; mid := l + (r-l)&gt;&gt;1 if nums[mid] == target &#123; return mid &#125; if nums[mid] &lt; nums[r] &#123; //说明[mid, r]上是递增的 if target &lt; nums[mid] &#123; r = mid - 1 &#125; else if target &gt; nums[mid] &#123; if target &lt;= nums[r] &#123; l = mid + 1 &#125; else if target &gt; nums[r] &#123; r = mid - 1 &#125; &#125; &#125; else if nums[mid] &gt; nums[r] &#123; //说明此时[l, mid]上是递增的 if target &gt; nums[mid] &#123; l = mid + 1 &#125; else if target &lt; nums[mid] &#123; if target &gt;= nums[l] &#123; r = mid - 1 &#125; else if target &lt; nums[l] &#123; l = mid + 1 &#125; &#125; &#125; else if nums[mid] == nums[r] &#123; //说明此时l,r以及mid指向同一个元素 //此时判断该元素是否为目标值， //因为在前面我们执行了nums[mid]==target所以这里肯定不是等于目标值 //所以返回-1 return -1 &#125; &#125; //一定不会执行到这里 return -1&#125;//对上面的代码进行优化//执行用时：4 ms, 在所有 Go 提交中击败了78.30%的用户//内存消耗：2.5 MB, 在所有 Go 提交中击败了96.57%的用户func search(nums []int, target int) int &#123; if len(nums) == 0 &#123; return 0 &#125; l, r := 0, len(nums)-1 for l &lt;= r &#123; mid := l + (r-l)&gt;&gt;1 if nums[mid] == target &#123; return mid &#125; if nums[mid] &lt; nums[r] &#123; //说明[mid, r]上是递增的 /*if target &lt; nums[mid] &#123; r = mid - 1 &#125; else if target &gt; nums[mid] &#123; if target &lt;= nums[r] &#123; l = mid + 1 &#125; else if target &gt; nums[r] &#123; r = mid - 1 &#125; &#125;*/ //上面注释代码改成这样 if target &gt; nums[mid] &amp;&amp; target &lt;= nums[r] &#123; l = mid + 1 &#125; else &#123; r = mid - 1 &#125; &#125; else if nums[mid] &gt; nums[r] &#123; //说明此时[l, mid]上是递增的 /*if target &gt; nums[mid] &#123; l = mid + 1 &#125; else if target &lt; nums[mid] &#123; if target &gt;= nums[l] &#123; r = mid - 1 &#125; else if target &lt; nums[l] &#123; l = mid + 1 &#125; &#125;*/ //上面注释代码改成这样 if target &lt; nums[mid] &amp;&amp; target &gt;= nums[l] &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; else if nums[mid] == nums[r] &#123; //说明此时l,r以及mid指向同一个元素 //此时判断该元素是否为目标值， //因为在前面我们执行了nums[mid]==target所以这里肯定不是等于目标值 //所以返回-1 return -1 &#125; &#125; //一定不会执行到这里 return -1&#125; 数组中元素有重复 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//不同于33题就在于nums[mid]==nums[r]的情况，此时因为数组中有重复元素，不同于33题，并不能判断l, mid, r都指向同一个元素，所以只能不断缩减区间//执行用时：4 ms, 在所有 Go 提交中击败了90.74%的用户//内存消耗：3.2 MB， 在所有 Go 提交中击败了95.60%的用户func search(nums []int, target int) bool &#123; if len(nums) == 0 &#123; return false &#125; l, r := 0, len(nums)-1 for l &lt;= r &#123; mid := l + (r-l)&gt;&gt;1 if target == nums[mid] &#123; return true &#125; if nums[mid] &gt; nums[r] &#123; //说明此时[l, mid]是单调递增的 if target &gt; nums[mid] &#123; l = mid + 1 &#125; else if target &lt; nums[mid] &#123; if target &gt;= nums[l] &#123; r = mid - 1 &#125; else if target &lt; nums[l] &#123; l = mid + 1 &#125; &#125; &#125; else if nums[mid] &lt; nums[r] &#123; if target &lt; nums[mid] &#123; r = mid - 1 &#125; else if target &gt; nums[mid] &#123; if target &lt;= nums[r] &#123; l = mid + 1 &#125; else if target &gt; nums[r] &#123; r = mid - 1 &#125; &#125; &#125; else if nums[mid] == nums[r] &#123; //关键点：不同于33题的 //因为数组中有重复元素，我们不能确定l, mid, r是指向同一个元素的 //因此让r不断缩减 r-- &#125; &#125; //最后一定不会执行到这里 return false&#125;//对上面的代码进行优化//执行用时：4 ms, 在所有 Go 提交中击败了90.74%的用户//内存消耗：3.2 MB， 在所有 Go 提交中击败了95.60%的用户func search(nums []int, target int) bool &#123; if len(nums) == 0 &#123; return false &#125; l, r := 0, len(nums)-1 for l &lt;= r &#123; mid := l + (r-l)&gt;&gt;1 if target == nums[mid] &#123; return true &#125; if nums[mid] &gt; nums[r] &#123; //说明此时[l, mid]是单调递增的 //if target &gt; nums[mid] &#123; // l = mid + 1 //&#125; else if target &lt; nums[mid] &#123; // if target &gt;= nums[l] &#123; // r = mid - 1 // &#125; else if target &lt; nums[l] &#123; // l = mid + 1 // &#125; //&#125; if target &lt; nums[mid] &amp;&amp; target &gt;= nums[l] &#123; r = mid - 1 &#125; else &#123; l = mid + 1 &#125; &#125; else if nums[mid] &lt; nums[r] &#123; //if target &lt; nums[mid] &#123; // r = mid - 1 //&#125; else if target &gt; nums[mid] &#123; // if target &lt;= nums[r] &#123; // l = mid + 1 // &#125; else if target &gt; nums[r] &#123; // r = mid - 1 // &#125; //&#125; if target &gt; nums[mid] &amp;&amp; target &lt;= nums[r] &#123; l = mid + 1 &#125; else &#123; r = mid - 1 &#125; &#125; else if nums[mid] == nums[r] &#123; //关键点：不同于33题的 //因为数组中有重复元素，我们不能确定l, mid, r是指向同一个元素的 //因此让r不断缩减 r-- &#125; &#125; //最后一定不会执行到这里 return false&#125; 参考","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"算法/二分","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"}],"author":"yirufeng"},{"title":"(LeetCode系列)矩阵中的搜索","slug":"LeetCode系列-矩阵中的搜索","date":"2020-12-07T17:47:08.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/12/07/LeetCode系列-矩阵中的搜索/","link":"","permalink":"http://www.sivan.tech/2020/12/07/LeetCode%E7%B3%BB%E5%88%97-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/","excerpt":"套路总结套路总结 注意：方法一二代码较为简单，这里就不再赘述了 方法三上图中的方法三，我们以LeetCode 240为例 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** ✅ * @Author: yirufeng * @Date: 2020/12/7 11:41 上午 * @Desc: * 方法一：暴力 * 方法二：从右上角或者左下角每次排除一行或者一列 * 方法三：每一行二分搜索 * 方法四：采用二分 思路：获取当前搜索矩阵的中心点，然后排出左上角或者右下角的矩阵 如下是方法四代码 **/func searchTarget(matrix [][]int, x1, y1, x2, y2, target int) bool &#123; //递归可能越界 if x1 &gt; x2 || y1 &gt; y2 &#123; return false &#125; //之前这个if语句块没有写会死循环， //注意点：避免x1，y1，x2，y2相等时调用searchTarget(matrix, x1, y1, xMid, yMid, target)死循环 if x1 == x2 &amp;&amp; y1 == y2 &#123; if matrix[x1][y1] == target &#123; return true &#125; return false &#125; //得到中心点坐标 xMid, yMid := x1+(x2-x1)&gt;&gt;1, y1+(y2-y1)&gt;&gt;1 if matrix[xMid][yMid] &gt; target &#123; //排除右下角 return searchTarget(matrix, x1, y1, xMid, yMid, target) || searchTarget(matrix, x1, yMid+1, xMid-1, y2, target) || searchTarget(matrix, xMid+1, y1, x2, yMid-1, target) &#125; else if matrix[xMid][yMid] &lt; target &#123; //排除左上角 return searchTarget(matrix, x1, yMid+1, xMid, y2, target) || searchTarget(matrix, xMid+1, y1, x2, yMid, target) || searchTarget(matrix, xMid+1, yMid+1, x2, y2, target) &#125; return true&#125;func searchMatrix(matrix [][]int, target int) bool &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return false &#125; return searchTarget(matrix, 0, 0, len(matrix)-1, len(matrix[0])-1, target)&#125;","text":"套路总结套路总结 注意：方法一二代码较为简单，这里就不再赘述了 方法三上图中的方法三，我们以LeetCode 240为例 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** ✅ * @Author: yirufeng * @Date: 2020/12/7 11:41 上午 * @Desc: * 方法一：暴力 * 方法二：从右上角或者左下角每次排除一行或者一列 * 方法三：每一行二分搜索 * 方法四：采用二分 思路：获取当前搜索矩阵的中心点，然后排出左上角或者右下角的矩阵 如下是方法四代码 **/func searchTarget(matrix [][]int, x1, y1, x2, y2, target int) bool &#123; //递归可能越界 if x1 &gt; x2 || y1 &gt; y2 &#123; return false &#125; //之前这个if语句块没有写会死循环， //注意点：避免x1，y1，x2，y2相等时调用searchTarget(matrix, x1, y1, xMid, yMid, target)死循环 if x1 == x2 &amp;&amp; y1 == y2 &#123; if matrix[x1][y1] == target &#123; return true &#125; return false &#125; //得到中心点坐标 xMid, yMid := x1+(x2-x1)&gt;&gt;1, y1+(y2-y1)&gt;&gt;1 if matrix[xMid][yMid] &gt; target &#123; //排除右下角 return searchTarget(matrix, x1, y1, xMid, yMid, target) || searchTarget(matrix, x1, yMid+1, xMid-1, y2, target) || searchTarget(matrix, xMid+1, y1, x2, yMid-1, target) &#125; else if matrix[xMid][yMid] &lt; target &#123; //排除左上角 return searchTarget(matrix, x1, yMid+1, xMid, y2, target) || searchTarget(matrix, xMid+1, y1, x2, yMid, target) || searchTarget(matrix, xMid+1, yMid+1, x2, y2, target) &#125; return true&#125;func searchMatrix(matrix [][]int, target int) bool &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return false &#125; return searchTarget(matrix, 0, 0, len(matrix)-1, len(matrix[0])-1, target)&#125; 方法四上图中的方法四，我们以牛客上的NC86矩阵元素查找为例 代码 1234567891011121314151617181920212223242526272829package main/** * * @param mat int整型二维数组 * @param n int整型 * @param m int整型 * @param x int整型 * @return int整型一维数组*/func findElement(mat [][]int, n int, m int, x int) []int &#123; // write code here //此时右上角对应的坐标 curX, curY := 0, m-1 for curX &lt; n &amp;&amp; curY &gt; -1 &#123; if mat[curX][curY] &gt; x &#123; //说明不在该列 curY-- &#125; else if mat[curX][curY] &lt; x &#123; //说明不在该行 curX++ &#125; else if mat[curX][curY] == x &#123; return []int&#123;curX, curY&#125; &#125; &#125; //说明找不到 return []int&#123;-1, -1&#125;&#125; 第二种题型特有解法上图中的针对第二种题型的解法，我们以LeetCode74为例 题目中说明了m行n列，假设有序数组中的下标为i(0~m*n-1)，转换对应的矩阵所在位置为(i / n, i % n) 代码 12345678910111213141516171819202122func searchMatrix(matrix [][]int, target int) bool &#123; // write code here if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return false &#125; row, col := len(matrix), len(matrix[0]) l, r := 0, row*col-1 for l &lt;= r &#123; mid := l + (r-l)&gt;&gt;1 if matrix[mid/col][mid%col] &gt; target &#123; //说明 r = mid - 1 &#125; else if matrix[mid/col][mid%col] &lt; target &#123; l = mid + 1 &#125; else if matrix[mid/col][mid%col] == target &#123; return true &#125; &#125; //说明没找到 return false&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"二分","slug":"算法/二分","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%88%86/"},{"name":"矩阵","slug":"矩阵","permalink":"http://www.sivan.tech/tags/%E7%9F%A9%E9%98%B5/"}],"author":"yirufeng"},{"title":"两个全排列的题目","slug":"两个全排列的题目","date":"2020-11-28T20:28:09.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/11/28/两个全排列的题目/","link":"","permalink":"http://www.sivan.tech/2020/11/28/%E4%B8%A4%E4%B8%AA%E5%85%A8%E6%8E%92%E5%88%97%E7%9A%84%E9%A2%98%E7%9B%AE/","excerpt":"第一道题","text":"第一道题 思路每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，我们从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，之后进行下一层的递归最后递归回来之后，我们再交换回去 代码 12345678910111213141516171819202122232425262728293031323334353637//✅//核心：如何做到每次从后面的选择，并且不会重复呢？如果后面选择某个元素，我们就把该元素交换到我们已经选择完的下一个元素//index表示下次从nums中的哪个位置元素开始，因为之前的都已经选好了func backtrack(ret *[][]int, path []int, index int, nums []int) &#123; if len(path) == len(nums) &#123; //将当前路径加入到结果中 temp := make([]int, len(path)) copy(temp, path) *ret = append(*ret, temp) return &#125; //开始进入选择 for i := index; i &lt; len(nums); i++ &#123; //利用交换，让我们每次选择的都放置到上次选择的后面那个相邻元素 nums[i], nums[index] = nums[index], nums[i] //下次我们将index位置的元素加入路径 path = append(path, nums[index]) //进入下一层 backtrack(ret, path, index+1, nums) //从路径中撤销 path = path[:len(path)-1] //撤销交换 nums[i], nums[index] = nums[index], nums[i] &#125;&#125;func permute(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; var ret [][]int backtrack(&amp;ret, []int&#123;&#125;, 0, nums) return ret&#125; 第二道题 note info 核心：如何避免重复出现。思路：我们使用一个map或者set来统计index位置，我们已经交换过的元素，如果下次要交换的元素与我们之前交换过的元素的元素值相同则跳过，因此我们可以使用map或者set来统计。但是要注意位置，每次递归进来的时候我们都要重新建立针对当前index位置的一个统计容器 思路每次假设我们当前要选择的是index位置的元素，有很多选择，从index开始一直到数组结束但是我们每次选择之后如何和前面已经选择好的元素组成的数组连接起来呢，如果放置的元素与我们之前放置过的元素不重复，那么我们将从后面选择要放置到index位置的元素，与我们目前的index位置的元素进行互换，之后进行下一层的递归最后递归回来之后，我们再交换回去 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//✅func permuteUnique(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; var ret [][]int backtrack(nums, &amp;ret, 0, []int&#123;&#125;) return ret&#125;func backtrack(nums []int, ret *[][]int, index int, path []int) &#123; if len(nums) == len(path) &#123; temp := make([]int, len(nums)) copy(temp, path) *ret = append(*ret, temp) return &#125; visited := make(map[int]bool) for i := index; i &lt; len(nums); i++ &#123; //如果没有被访问过 if !visited[nums[i]] &#123; nums[i], nums[index] = nums[index], nums[i] //加入路径以及visited中 path = append(path, nums[index]) visited[nums[index]] = true //进入到下一层 backtrack(nums, ret, index+1, path) //撤销加入路径以及撤销加入visited中 path = path[:len(path)-1] //❌ //下面这一行代码是不需要的，因为当前可选的数字如果选了加入到visited下次我们就不可以再选了，所以不可以再撤销了 //delete(visited, nums[index]) //撤销交换 nums[i], nums[index] = nums[index], nums[i] &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"算法","slug":"LeetCode/算法","permalink":"http://www.sivan.tech/categories/LeetCode/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"}],"author":"yirufeng"},{"title":"二叉树的序列化与反序列化","slug":"二叉树的序列化与反序列化","date":"2020-11-18T16:25:33.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/11/18/二叉树的序列化与反序列化/","link":"","permalink":"http://www.sivan.tech/2020/11/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"前言序列化：二叉树被记录成文件的过程叫做序列化 反序列化：通过文件内容重建原来二叉树的过程叫做反序列化","text":"前言序列化：二叉树被记录成文件的过程叫做序列化 反序列化：通过文件内容重建原来二叉树的过程叫做反序列化 第一种方式：先序遍历 先序遍历进行序列化和反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125; 第二种方式：层次遍历自己写的层次遍历序列化 层次遍历进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//方法二：使用层次遍历进行序列化和反序列化func LevelOrderSerialize(root *TreeNode) string &#123; //首先如果根节点为空，我们直接返回一个空字符串即可 if root == nil &#123; return &quot;#!&quot; &#125; var ret string queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; //首先弹出一个节点 node := queue[0] queue = queue[1:] //如果弹出的节点不为空，我们直接将值转换为字符串并加入其中 if node != nil &#123; ret += strconv.Itoa(node.Val) + &quot;!&quot; &#125; else &#123; ret += &quot;#!&quot; //这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码 continue &#125; queue = append(queue, node.Left) queue = append(queue, node.Right) &#125; return ret&#125;func LevelOrderDeserialize(str string) *TreeNode &#123; strs := strings.Split(str, &quot;!&quot;) root := LevelOrderReconstruct(strs) return root&#125;//根据层次遍历重建二叉树func LevelOrderReconstruct(strs []string) *TreeNode &#123; var head *TreeNode //一进来首先建立根节点 if strs[0] == &quot;#&quot; &#123; return nil &#125; else &#123; val, _ := strconv.Atoi(strs[0]) head = &amp;TreeNode&#123; Val: val, &#125; &#125; //用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点 //因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点 index := 1 //使用一个队列将我们后面需要建立子树的非空节点加入进来， queue := []*TreeNode&#123;head&#125; for len(queue) != 0 &#123; //说明当前开始建立cur的左右子树 cur := queue[0] queue = queue[1:] //建立左子树 if strs[index] == &quot;#&quot; &#123; cur.Left = nil &#125; else &#123; val, _ := strconv.Atoi(strs[index]) cur.Left = &amp;TreeNode&#123; Val: val, &#125; queue = append(queue, cur.Left) &#125; index++ //建立右子树 if strs[index] == &quot;#&quot; &#123; cur.Right = nil &#125; else &#123; val, _ := strconv.Atoi(strs[index]) cur.Right = &amp;TreeNode&#123; Val: val, &#125; queue = append(queue, cur.Right) &#125; index++ &#125; return head&#125; 参考左神代码：对层次遍历进行序列化和反序列化的改进 加入了一个函数generateNodeFromString避免代码臃肿 层次遍历进行序列化和反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//对方法二的改进func LevelOrderSerialize(root *TreeNode) string &#123; //首先如果根节点为空，我们直接返回一个空字符串即可 if root == nil &#123; return &quot;#!&quot; &#125; var ret string queue := []*TreeNode&#123;root&#125; for len(queue) != 0 &#123; //首先弹出一个节点 node := queue[0] queue = queue[1:] //如果弹出的节点不为空，我们直接将值转换为字符串并加入其中 if node != nil &#123; ret += strconv.Itoa(node.Val) + &quot;!&quot; &#125; else &#123; ret += &quot;#!&quot; //这里因为是当前节点为空，因此加入到#!到字符串之后我们需要重新循环，不可以执行下面的代码 continue &#125; queue = append(queue, node.Left) queue = append(queue, node.Right) &#125; return ret&#125;func LevelOrderDeserialize(str string) *TreeNode &#123; strs := strings.Split(str, &quot;!&quot;) root := LevelOrderReconstruct(strs) return root&#125;//根据层次遍历重建二叉树func LevelOrderReconstruct(strs []string) *TreeNode &#123; //一进来首先建立根节点 head := generateNodeFromString(strs[0]) //这里要注意判断一下head是否为空 //注意点：判断head是否为空，如果为空就推出，否则后面会报错的 if head == nil &#123; return nil &#125; //用于表示我们当前遍历到的节点是层次遍历结果中的第几个节点 //因为头节点已经建立完，说明下次我们需要从strs中的index为1的位置开始建立节点 index := 1 //使用一个队列将我们后面需要建立子树的非空节点加入进来， queue := []*TreeNode&#123;head&#125; for len(queue) != 0 &#123; //说明当前开始建立cur的左右子树 cur := queue[0] queue = queue[1:] //建立左子树 cur.Left = generateNodeFromString(strs[index]) index++ //建立右子树 cur.Right = generateNodeFromString(strs[index]) index++ //如果左子树不为空，加入到队列中 if cur.Left != nil &#123; queue = append(queue, cur.Left) &#125; //如果右子树不为空，加入到队列中 if cur.Right != nil &#123; queue = append(queue, cur.Right) &#125; &#125; return head&#125;func generateNodeFromString(val string) *TreeNode &#123; if val == &quot;#&quot; &#123; return nil &#125; temp, _ := strconv.Atoi(val) return &amp;TreeNode&#123; Val: temp, &#125;&#125; 可能出现的问题递归函数传入切片作为参数造成切片修改后递归回来又还原","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"},{"name":"二叉树","slug":"算法/面试/二叉树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"yirufeng"},{"title":"Golang中刷题关于切片的一些坑","slug":"golang中刷题关于切片的一些坑","date":"2020-11-18T09:58:06.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/11/18/golang中刷题关于切片的一些坑/","link":"","permalink":"http://www.sivan.tech/2020/11/18/golang%E4%B8%AD%E5%88%B7%E9%A2%98%E5%85%B3%E4%BA%8E%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"问题1问题描述：递归的过程中，传递了一个切片作为参数，每次我们都需要对切片切取首元素，之后递归回来的时候发现切片中的元素还是没有切取首元素，是一个很严重的逻辑错误。 问题解决：我们递归函数使用切片作为参数的时候，我们直接传入切片的地址。因为切片每次删除元素，地址也会改变。当切片增加元素引起扩容，地址也会发生改变，而如果只传入切片我们只是引用最开始的时候的切片的地址，因此会发现切片没有任何改变。 例如我们自己写的二叉树序列化和反序列化代码：在最开始只是传递一个切片，但是后来传递切片的地址进去发现代码逻辑正常运行。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125;","text":"问题1问题描述：递归的过程中，传递了一个切片作为参数，每次我们都需要对切片切取首元素，之后递归回来的时候发现切片中的元素还是没有切取首元素，是一个很严重的逻辑错误。 问题解决：我们递归函数使用切片作为参数的时候，我们直接传入切片的地址。因为切片每次删除元素，地址也会改变。当切片增加元素引起扩容，地址也会发生改变，而如果只传入切片我们只是引用最开始的时候的切片的地址，因此会发现切片没有任何改变。 例如我们自己写的二叉树序列化和反序列化代码：在最开始只是传递一个切片，但是后来传递切片的地址进去发现代码逻辑正常运行。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//方法一：使用先序遍历进行序列化和反序列化//进行序列化func PreorderSerialize(root *TreeNode) string &#123; if root == nil &#123; return &quot;#!&quot; &#125; var ret string ret += strconv.Itoa(root.Val) + &quot;!&quot; ret += PreorderSerialize(root.Left) ret += PreorderSerialize(root.Right) return ret&#125;//进行反序列化func PreorderDeserialize(ret string) *TreeNode &#123; strs := strings.Split(ret, &quot;!&quot;) //注意点：由于切片在执行过程中有可能会因为增加和删除元素而造成切片不是原来那个切片，但是我们递归回去的时候还是指向原来的切片，因此会有问题 //所以这里我们传递的是切片的地址 //因为切片扩容可能会生成一个新的底层数组，并且由于切片移除了元素，因此对应的头部地址一定会改变，所以会造成地址的改变 root := ReconstructTreeFromPreorder(&amp;strs) return root&#125;//根据我们分割后的字符串建立二叉树func ReconstructTreeFromPreorder(strs *[]string) *TreeNode &#123; if (*strs)[0] == &quot;#&quot; &#123; (*strs) = (*strs)[1:] return nil &#125; //首先将该值对应的字符串转换为int val, _ := strconv.Atoi((*strs)[0]) //建立一个针对于该值的节点 node := &amp;TreeNode&#123; Val: val, &#125; //去掉我们建立过的节点的值 (*strs) = (*strs)[1:] //之后进行递归建立左右子树 node.Left = ReconstructTreeFromPreorder(strs) node.Right = ReconstructTreeFromPreorder(strs) return node&#125;","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://www.sivan.tech/tags/%E5%88%B7%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"}],"author":"yirufeng"},{"title":"二叉树的三种遍历方式","slug":"二叉树的三种遍历方式","date":"2020-11-17T20:30:26.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/11/17/二叉树的三种遍历方式/","link":"","permalink":"http://www.sivan.tech/2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","excerpt":"基于递归的遍历","text":"基于递归的遍历 先序遍历 先序遍历方式1 123456789101112131415161718//✅代码func PreorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val) if root.Left != nil &#123; ret = append(ret, PreorderTraverse(root.Left)...) &#125; if root.Right != nil &#123; ret = append(ret, PreorderTraverse(root.Right)...) &#125; return ret&#125; 先序遍历方式2 123456789101112func PreorderTraverseII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val) ret = append(ret, PreorderTraverse(root.Left)...) ret = append(ret, PreorderTraverse(root.Right)...) return ret&#125; 先序遍历错误方式 错误方式12345678910func PreorderTraverseIII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, root.Val, PreorderTraverseIII(root.Left)..., PreorderTraverseIII(root.Right)...) return ret&#125; 中序遍历 中序遍历 1234567891011func InorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, InorderTraverse(root.Left)...) ret = append(ret, root.Val) ret = append(ret, InorderTraverse(root.Right)...) return ret&#125; 后序遍历 后序遍历 123456789101112func PostorderTraverse(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int ret = append(ret, PostorderTraverse(root.Left)...) ret = append(ret, PostorderTraverse(root.Right)...) ret = append(ret, root.Val) return ret&#125; 基于非递归的遍历先序遍历 申请一个新的栈，记为stack，然后将头结点压入到stack中 从stack中弹出栈顶结点，记为cur，然后打印cur结点的值，再将cur结点的右孩子（不为空）压入到栈中，最后将左孩子（不为空）压入到stack中 不断重复步骤2，直到stack为空，全部过程结束 非递归实现二叉树的先序遍历 123456789101112131415161718192021222324252627282930//✅//思路：使用栈来求解，初始化的时候若根不为空，则将根加入到栈中，//之后，每次遍历到一个节点将值加入到结果中并弹出，然后将右子树加入到栈中，之后将左子树加入到栈中func PreorderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; for len(stack) != 0 &#123; //首先从栈中弹出一个节点 node := stack[len(stack)-1] stack = stack[:len(stack)-1] //将当前节点的值加入到我们要返回的结果中 ret = append(ret, node.Val) //将当前节点的右节点加入到栈中 if node.Right != nil &#123; stack = append(stack, node.Right) &#125; //将当前节点的左节点加入到栈中 if node.Left != nil &#123; stack = append(stack, node.Left) &#125; &#125; return ret&#125; 中序遍历 申请一个新栈，记为stack。初始时，令变量cur = head 先把cur节点压入栈中，对以cur节点为头节点的整颗子树来说，依次把左边界压入到栈中，即不停地令cur = cur.Left，然后重复步骤3 不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点，记为node，打印node的值，并且让cur = node.right，然后继续重复步骤2。 当stack为空且cur为空，整个过程停止。 非递归实现二叉树的中序遍历 123456789101112131415161718192021222324252627282930//✅func InorderTraverseNoRecursion(root *TreeNode) []int &#123; //如果为空，直接返回 if root == nil &#123; return nil &#125; var ret []int var stack []*TreeNode cur := root for cur != nil || len(stack) != 0 &#123; if cur != nil &#123; //说明当前节点是第一次遍历，直接加入到栈中 stack = append(stack, cur) //之后移动到该节点的左子树节点 cur = cur.Left &#125; else &#123; //首先从栈中弹出一个节点 cur = stack[len(stack)-1] stack = stack[:len(stack)-1] //将当前节点的值加入到结果中 ret = append(ret, cur.Val) //之后移动到当前节点的右节点 cur = cur.Right &#125; &#125; return ret&#125; 后序遍历第一种方式：先介绍用两个栈实现后序遍历的过程，具体过程如下： 1．申请一个栈，记为s1，然后将头节点head压入s1中。 2．从s1中弹出的节点记为cur，然后依次将cur的左孩子和右孩子压入s1中。 3．在整个过程中，每一个从s1中弹出的节点都放进s2中。 4．不断重复步骤2和步骤3，直到s1为空，过程停止。 5．从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。” 通过如上过程我们知道，每棵子树的头节点都最先从s1中弹出，然后把该节点的孩子节点按照先左再右的顺序压入s1，那么从s1弹出的顺序就是先右再左，所以从s1中弹出的顺序就是中、右、左。然后，s2重新收集的过程就是把s1的弹出顺序逆序，所以s2从栈顶到栈底的顺序就变成了左、右、中。 非递归实现二叉树的后序遍历方式1 12345678910111213141516171819202122232425262728293031323334353637383940414243//✅//方法一：使用两个栈实现二叉树的非递归后序遍历func PostorderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int var stack2 []*TreeNode //首先我们将root加入到stack1中 stack1 := []*TreeNode&#123;root&#125; //如果stack1不为空 for len(stack1) != 0 &#123; cur := stack1[len(stack1)-1] //将当前节点从栈1移除并且将当前节点加入到栈2 stack1 = stack1[:len(stack1)-1] //将当前节点的左右子节点分别加入到栈1 //注意点1：这里有可能左右子节点有可能为空 if cur.Left != nil &#123; stack1 = append(stack1, cur.Left) &#125; if cur.Right != nil &#123; stack1 = append(stack1, cur.Right) &#125; //之后将当前节点加入到栈2中 stack2 = append(stack2, cur) &#125; //最后我们从stack2弹出的顺序就是我们后序遍历得到的结果 for len(stack2) != 0 &#123; node := stack2[len(stack2)-1] stack2 = stack2[:len(stack2)-1] ret = append(ret, node.Val) &#125; return ret&#125; 第二种方式：最后介绍只用一个栈实现后序遍历的过程，具体过程如下： 1．申请一个栈，记为stack，将头节点压入stack，同时设置两个变量h和c。在整个流程中，h代表最近一次弹出并打印的节点，c代表” 摘录来自: 左程云. “程序员代码面试指南:IT名企算法与数据结构题目最优解。” Apple Books. “stack的栈顶节点，初始时h为头节点，c为null。 2．每次令c等于当前stack的栈顶节点，但是不从stack中弹出，此时分以下三种情况。 ①：如果c的左孩子不为null，并且h不等于c的左孩子，也不等于c的右孩子，则把c的左孩子压入stack中。具体解释一下这么做的原因，首先h的意义是最近一次弹出并打印的节点，所以如果h等于c的左孩子或者右孩子，说明c的左子树与右子树已经打印完毕，此时不应该再将c的左孩子放入stack中。否则，说明左子树还没处理过，那么此时将c的左孩子压入stack中。 ②：如果条件①不成立，并且c的右孩子不为null，h不等于c的右孩子，则把c的右孩子压入stack中。含义是如果h等于c的右孩子，说明c的右子树已经打印完毕，此时不应该再将c的右孩子放入stack中。否则，说明右子树还没处理过，此时将c的右孩子压入stack中。 ③：如果条件①和条件②都不成立，说明c的左子树和右子树都已经打印完毕，那么从stack中弹出c并打印，然后令h=c。 3．一直重复步骤2，直到stack为空，过程停止。” 非递归实现二叉树的后序遍历方式2： 12345678910111213141516171819202122232425262728293031323334//方法二：只使用一个栈实现二叉树的非递归后序遍历//✅//思路：使用一个栈和两个变量，h代表上次访问并删除的节点，c代表当前节点func PostorderTraverseNoRecursionII(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; //初始化的时候h置为root，将c置为nil h := root var c *TreeNode //如果栈不为空 for len(stack) != 0 &#123; c = stack[len(stack)-1] //如果当前节点的左子树不为空，并且左右子树都不等于h，说明左子树没有遍历过，将左节点加入栈中 if c.Left != nil &amp;&amp; h != c.Left &amp;&amp; h != c.Right &#123; //也就是第一次遍历该节点的时候 stack = append(stack, c.Left) &#125; else if c.Right != nil &amp;&amp; c.Right != h &#123; //如果当前节点的右子树不为空，且不等于h，说明没有遍历过，则将右节点加入到栈中，也就是第二次遍历该节点的时候 stack = append(stack, c.Right) &#125; else &#123; //否则，弹出节点，并加入到结果中，也就是第三次遍历该节点的时候 node := stack[len(stack)-1] stack = stack[:len(stack)-1] ret = append(ret, node.Val) //并且将上一次访问并且打印过的节点重置为node h = node &#125; &#125; return ret&#125; 【推荐】第三种方式： 后序遍历是按照左-&gt;右-&gt;根的顺序遍历，我们可以按照根-&gt;右-&gt;左的顺序遍历，然后将我们的结果反转即可。 非递归实现二叉树的后序遍历方式3： 1234567891011121314151617181920212223242526272829func PostOrderTraverseNoRecursion(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var ret []int stack := []*TreeNode&#123;root&#125; //按照根右左的顺序遍历之后反转我们的结果 for len(stack) != 0 &#123; cur := stack[len(stack)-1] stack = stack[:len(stack)-1] ret = append(ret, cur.Val) if cur.Left != nil &#123; //加入左 stack = append(stack, cur.Left) &#125; if cur.Right != nil &#123; //加入右 stack = append(stack, cur.Right) &#125; &#125; //反转我们的ret for i := 0; i &lt; len(ret)&gt;&gt;1; i++ &#123; ret[i], ret[len(ret)-1-i] = ret[len(ret)-1-i], ret[i] &#125; fmt.Println(ret) return ret&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.sivan.tech/tags/DP/"},{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.sivan.tech/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"yirufeng"},{"title":"树形DP套路","slug":"树形DP套路","date":"2020-11-17T14:12:50.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/11/17/树形DP套路/","link":"","permalink":"http://www.sivan.tech/2020/11/17/%E6%A0%91%E5%BD%A2DP%E5%A5%97%E8%B7%AF/","excerpt":"步骤 以某个节点X为头结点的子树中，分析答案有哪些可能性，并且这种分析是以X的左子树，X的右子树，和X整棵树的角度来考虑可能性的 根据第一步分析的可能性，列出所需要的信息，例如在二叉树是否平衡中，左子树和右子树都需要知道各自是否平衡，以及高度这两个信息。 根据第二步信息汇总，定义自己的信息结构体 设计递归函数，递归函数是处理以X为头结点的情况相爱的答案，包括设计递归函数的base case，默认直接得到左树和右树所有的信息，以及把可能性左整合，并且返回第三步的信息结构这4个小步骤。","text":"步骤 以某个节点X为头结点的子树中，分析答案有哪些可能性，并且这种分析是以X的左子树，X的右子树，和X整棵树的角度来考虑可能性的 根据第一步分析的可能性，列出所需要的信息，例如在二叉树是否平衡中，左子树和右子树都需要知道各自是否平衡，以及高度这两个信息。 根据第二步信息汇总，定义自己的信息结构体 设计递归函数，递归函数是处理以X为头结点的情况相爱的答案，包括设计递归函数的base case，默认直接得到左树和右树所有的信息，以及把可能性左整合，并且返回第三步的信息结构这4个小步骤。 题目应用：判断一颗二叉树是否平衡第一步： 内容：考虑可能性 ​ 可能性一：如果X的左子树不平衡，说明以X为头结点的树就是不平衡的 ​ 可能性二：如果X的右子树不平衡，说明以X为头结点的树就是不平衡的 ​ 可能性三：如果X的左右子树高度差超过1，说明以X为头结点的树就是不平衡的 ​ 可能性四：如果前三种可能性都不满足，说明以X为头结点的树是平衡的。 注意：空树也是一个平衡二叉树，会满足可能性四 第二步： 内容：根据第一步的可能性分析，列出所需要的信息。这里左右子树都需要知道是否平衡以及高度这两个信息。 第三步： 内容：汇总信息，并为此定义一个信息结构体 第四步： 内容：设计递归函数，递归函数是处理以X为头结点的情况下的答案，包括设计递归函数的base case，默认直接得到左右子树的信息，以及把可能性做整合并且也返回第三步的信息结构这4个小步骤。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;leetcode-go/model&quot; //model中只定义了一个TreeNodetype RetType struct &#123; IsBalanced bool Height int&#125;func isBalanced(root *model.TreeNode) bool &#123; return isBalancedCore(root).IsBalanced&#125;func isBalancedCore(root *model.TreeNode) RetType &#123; if root == nil &#123; return RetType&#123; IsBalanced: true, Height: 0, &#125; &#125; //获取左右子树的信息 left := isBalancedCore(root.Left) right := isBalancedCore(root.Right) //如果左右子树都平衡且左右子树高度差绝对值小于等于1，直接返回True信息 if left.IsBalanced == true &amp;&amp; right.IsBalanced == true &amp;&amp; left.Height-right.Height &gt;= -1 &amp;&amp; left.Height-right.Height &lt;= 1 &#123; return RetType&#123; IsBalanced: true, Height: max(left.Height, right.Height) + 1, &#125; &#125; //否则说明不平衡直接返回false return RetType&#123; IsBalanced: false, Height: max(left.Height, right.Height) + 1, &#125;&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://www.sivan.tech/tags/DP/"},{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.sivan.tech/tags/%E6%A0%91%E5%BD%A2DP/"}],"author":"yirufeng"},{"title":"布隆过滤器总结","slug":"布隆过滤器总结","date":"2020-11-11T14:19:08.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/11/11/布隆过滤器总结/","link":"","permalink":"http://www.sivan.tech/2020/11/11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%80%BB%E7%BB%93/","excerpt":"了解布隆过滤器什么是布隆过滤器？一个布隆过滤器精确地代表了一个集合。并不像哈希表那样存储原始信息，而是存储原始信息的压缩信息以节省空间，但牺牲了一定的准确度。 布隆过滤器的作用可以精确地判断一个元素是否在这个集合中。注意只是精确代表和精确判断，到底有多精确，取决于我们自己的设计。想做到完全正确是不可能的，布隆过滤器的优势在于使用很少的空间就可以将准确率做到很高的程度。","text":"了解布隆过滤器什么是布隆过滤器？一个布隆过滤器精确地代表了一个集合。并不像哈希表那样存储原始信息，而是存储原始信息的压缩信息以节省空间，但牺牲了一定的准确度。 布隆过滤器的作用可以精确地判断一个元素是否在这个集合中。注意只是精确代表和精确判断，到底有多精确，取决于我们自己的设计。想做到完全正确是不可能的，布隆过滤器的优势在于使用很少的空间就可以将准确率做到很高的程度。 应用网页黑名单系统，垃圾邮件过滤系统，爬虫的网址判重系统。即面试官考察的问题需要在一个很大数据量的应用中要求我们用有限的空间设计一个容忍一定错误率的系统。 如何生成一个布隆过滤器：假设有一个长度为m的bit类型的数组，即数组中的每一个位置只占用一个Bit，每一个bit只有0和1。假设一共有k个哈希函数，这些函数的输出域都大于等于m，并且这些哈希函数都已经足够优秀且彼此独立，输入一个数，分别计算出当输入为该数字时，对应的哈希函数的结果，一共有k个，每个结果都对m取余，然后在bit array上将对应的位置置为1。bit类型的数组记为bitMap，至此，一个输入对象对bitMap的影响过程就结束了，bitMap中的一些位置会被抹黑，接下来按照第2步对所有数都执行该操作，最后bitMap中很多位置都会被抹黑。至此，一个bloom filter生成完毕，这个bloom filter 代表之前所有输入对象组成的集合。 如何检查一个数是否在布隆过滤器中假设一个输入对象为m，我们对该输入对象通过k个哈希函数计算出k个值，然后把k个值取余，就得到在0~m-1范围的k个值，如果在bitMap上对应位置不为1，则说明一定不在布隆过滤器中。如果都为黑，则说明在这个集合里，但有可能误判 布隆过滤器的失误率分析如果bitMap的大小m相比输入对象的个数n过小，失误率将会变大。接下来介绍根据n的大小和我们想达到的失误率，如何确定布隆过滤器的大小m以及哈希函数的个数k。黑名单中样本个数为100亿，记为n，失误率不超过0.01%，记为p，每个样本的大小为64B，这个信息不会影响布隆过滤器的大小，只和选择哈希函数有关，一般的哈希函数都可以接收64B的输入对象，所以使用bloom filter还有一个好处就是不用顾忌单个样本的大小，它丝毫不会影响布隆过滤器的大小所以n=100亿，p=0.01%，布隆过滤器的大小m由以下公式决定：$ m = - \\frac{n \\ast (ln P) }{(ln 2)^2} $计算出m=20*n，也就需要2000亿个bit，也就是25GB哈希函数的个数由以下公式进行决定：$ k = ln2 \\ast \\frac{m}{n} $。最后计算出k = 14，但是真实失误率我们还需要重新计算。真实失误率公式： $ (1 - e^{- \\frac{n \\ast k }{ m }}) $计算出真实失误率为0.006%，比0.01%更低，由于哈希函数本身不占用什么空间，因此最主要占用空间的就是bitMap的大小，符合我们题目中的要求。 哈希函数的性质 哈希函数输入可以无限大，但是输出是固定的范围。 典型的哈希函数都有无限的输入范围。 哈希函数传入相同的输入值时，返回值也一样。 哈希函数传入不同的输入值时，返回值可能一样，可能不一样。所以会有不同的输入值对应同一个输出值。 很多不同的输入值所得到的返回值会均匀的分布在哈希函数上 另外自己查到的哈希函数还有一个特点，就是哈希函数输入可以任意大，但是输出是固定大小 评价：1-3点是哈希函数的基础，第4点性质是评价一个哈希函数优劣的关键，不同的输入经过哈希函数得到的结果越均匀分布在哈希函数上，哈希函数就越优秀，并且这种均匀分布与输入出现的规律无关。 结论：如果一个哈希函数能够根据很多不同的输入得到的返回值非常均匀的分布在S上，那么所有的返回值对m取余，可以认为所有的返回值也是均匀分布在0~m-1的空间上。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://www.sivan.tech/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"}],"author":"yirufeng"},{"title":"使用nginx部署网页到云服务器","slug":"使用nginx部署网页到云服务器","date":"2020-10-24T09:56:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/24/使用nginx部署网页到云服务器/","link":"","permalink":"http://www.sivan.tech/2020/10/24/%E4%BD%BF%E7%94%A8nginx%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"最近腾讯云上88一年入手了一台云服务器，希望可以部署自己的项目或者静态网站，顺便学习一下部署相关的操作 环境介绍环境腾讯云服务器：centos 7.5 64位本地环境：Mac OS","text":"最近腾讯云上88一年入手了一台云服务器，希望可以部署自己的项目或者静态网站，顺便学习一下部署相关的操作 环境介绍环境腾讯云服务器：centos 7.5 64位本地环境：Mac OS 需要辅助工具：可以远程连接服务器的工具，这里使用的是secure CRT可以上传文件到服务器的工具，这里使用的是FileZilla 具体步骤 步骤 服务器上新建要存放静态资源的目录，假设为/root/html使用FileZilla将静态资源从本地上传到/root/html安装nginx并进行配置(修改/etc/nginx/nginx.conf文件)修改user nginx;为nginx root; 避免之后用户访问静态网页出现permisson denied域名解析到服务器 参考链接nginx安装并进行配置","categories":[{"name":"nginx","slug":"nginx","permalink":"http://www.sivan.tech/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.sivan.tech/tags/nginx/"},{"name":"部署","slug":"部署","permalink":"http://www.sivan.tech/tags/%E9%83%A8%E7%BD%B2/"},{"name":"云服务器","slug":"云服务器","permalink":"http://www.sivan.tech/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":"yirufeng"},{"title":"golang中的defer-recover-panic","slug":"golang中的defer-recover-panic","date":"2020-10-13T21:28:35.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/13/golang中的defer-recover-panic/","link":"","permalink":"http://www.sivan.tech/2020/10/13/golang%E4%B8%AD%E7%9A%84defer-recover-panic/","excerpt":"panicpanic其实就是我们其他语言中的throw exception recoverrecover其实就是其他语言的try catch","text":"panicpanic其实就是我们其他语言中的throw exception recoverrecover其实就是其他语言的try catch 注意recover如果想起作用的话， 必须在defered函数中使用。在正常函数执行过程中，调用recover没有任何作用, 他会返回nil。如这样：fmt.Println(recover()) 。如果当前的goroutine panic了，那么recover将会捕获这个panic的值，并且让程序正常执行下去。不会让程序crash。 总结总结先执行return再执行defer如果触发多个panic，后触发的Panic会覆盖前面的Panicdefer-recover必须写在panic前面，因为发生panic后将不会执行位于panic后面的代码，如果在Panic之前有的defer代码将会按序执行如果当前函数触发了panic之后没有进行defer-recover，此时这个panic(会带着自己的异常去找对应的defer-recover)将会传回到上一级，如果上一级的defer链也没有对应的defer-recover将会一直返回到main，造成整个程序crash。如果不想影响函数的主流程，需要在对应的函数panic前面加上defer-recover协程遇到panic之后，将会遍历本协程的defer链表，并执行对应的defer，执行defer过程中，遇到recover就停止panic，返回recover处继续执行，如果没有遇到recover，遍历完本协程的defer链表，(将会沿着调用链返回上一级继续执行上一级的defer链表直到异常捕获或到main之后crash)或者如果没有上一级就会抛出错误信息， defer defer会在return之后执行，因此可能会对return的值进行修改 defer会按照先入后出的顺序进行执行 具体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport &quot;fmt&quot;/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/13 9:08 下午 * @Desc: */func a() &#123; i := 0 defer fmt.Println(i) i++ return&#125;func b() &#123; for i := 0; i &lt; 4; i++ &#123; defer fmt.Println(i) &#125;&#125;func f() (result int) &#123; defer func() &#123; result++ &#125;() return 0&#125;func g() (r int) &#123; t := 5 defer func() &#123; fmt.Println(&quot;t:&quot;, t) t = t + 5 &#125;() return t&#125;func h() (r int) &#123; defer func(r int) &#123; r = r + 5 &#125;(r) return 1&#125;func d(result int) &#123; result = 0 func() &#123; result++ &#125;() return&#125;func e() (r int) &#123; t := 5 r = t func() &#123; t = t + 5 &#125;() return&#125;func k() (r int) &#123; r = 1 func(r int) &#123; r = r + 5 &#125;(r) return&#125;func main() &#123; a() fmt.Println(&quot;-------------------------&quot;) b() fmt.Println(&quot;-------------------------&quot;) fmt.Println(f()) fmt.Println(&quot;-------------------------&quot;) fmt.Println(g()) fmt.Println(&quot;-------------------------&quot;) fmt.Println(h()) fmt.Println(&quot;-------------------------&quot;) d(2) fmt.Println(&quot;-------------------------&quot;) fmt.Println(e()) fmt.Println(&quot;-------------------------&quot;) fmt.Println(k()) fmt.Println(&quot;-------------------------&quot;)&#125;执行结果：123456789101112131415161718190-------------------------3210-------------------------1-------------------------t: 55-------------------------1--------------------------------------------------5-------------------------1------------------------- 参考文章列表 5.4 panic 和 recover Dive into stack and defer/panic/recover in go Go官方 Golang 入门系列（十四）defer, panic和recover用法 理解Defer、Panic和Recover Go面试：从一道判断题来谈panic和defer的调用机制和执行顺序","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"defer","slug":"defer","permalink":"http://www.sivan.tech/tags/defer/"},{"name":"panic","slug":"panic","permalink":"http://www.sivan.tech/tags/panic/"},{"name":"recover","slug":"recover","permalink":"http://www.sivan.tech/tags/recover/"}],"author":"yirufeng"},{"title":"golang中的iota","slug":"golang中的iota","date":"2020-10-13T20:50:33.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/13/golang中的iota/","link":"","permalink":"http://www.sivan.tech/2020/10/13/golang%E4%B8%AD%E7%9A%84iota/","excerpt":"经常有面试官甩出个const以及iota的面试题 如下便是国内某公司的面试题： 回答输出结果 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/13 6:06 下午 * @Desc: *///第一个const来自于面试题const ( i = 7 j k)const ( a = 7 b c = 3 m = 1 &lt;&lt; iota n o)func main() &#123; fmt.Println(a, b, c) fmt.Println(i, j, k, m, n, o)&#125; 总结进行几点总结不同 const 定义块互不干扰：即我们在推算这些常量值的时候只需要看当前的 const ( ) 之内的内容，不用关心之前或之后是否也用常量定义语句所有注释行和空行全部忽略：注意：_ 并不是一个空行，它是一个省略了标识符也省略了表达式的常量定义，这一点你需要清楚，不要大意。没有表达式的常量定义复用上一行的表达式：例如如下的代码，j中没有写表达式，那么j是复用上一行表达式的即j = iota，但此时iota的值会为21234const ( i = iota j)从第一行开始，iota 从 0 逐行加一：也就是说赋值表达式里无论是否引用了 iota，也无论引用了多少次，iota 的都会从常量定义块的第一行（注意这里不计空行和注释）开始计数，从 0 开始，逐行加一，例如上面代码1234567891011121314const ( i = 7 //iota = 1 j //iota = 2 k //iota = 3)const ( a = 7 //iota = 1 b //iota = 2 c = 3 //iota = 3 m = 1 &lt;&lt; iota //iota = 4 n //iota = 5 o //iota = 6)替换所有 iota：直接将表达式中的iota全部替换为我们上一步写出的值即可","text":"经常有面试官甩出个const以及iota的面试题 如下便是国内某公司的面试题： 回答输出结果 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/13 6:06 下午 * @Desc: *///第一个const来自于面试题const ( i = 7 j k)const ( a = 7 b c = 3 m = 1 &lt;&lt; iota n o)func main() &#123; fmt.Println(a, b, c) fmt.Println(i, j, k, m, n, o)&#125; 总结进行几点总结不同 const 定义块互不干扰：即我们在推算这些常量值的时候只需要看当前的 const ( ) 之内的内容，不用关心之前或之后是否也用常量定义语句所有注释行和空行全部忽略：注意：_ 并不是一个空行，它是一个省略了标识符也省略了表达式的常量定义，这一点你需要清楚，不要大意。没有表达式的常量定义复用上一行的表达式：例如如下的代码，j中没有写表达式，那么j是复用上一行表达式的即j = iota，但此时iota的值会为21234const ( i = iota j)从第一行开始，iota 从 0 逐行加一：也就是说赋值表达式里无论是否引用了 iota，也无论引用了多少次，iota 的都会从常量定义块的第一行（注意这里不计空行和注释）开始计数，从 0 开始，逐行加一，例如上面代码1234567891011121314const ( i = 7 //iota = 1 j //iota = 2 k //iota = 3)const ( a = 7 //iota = 1 b //iota = 2 c = 3 //iota = 3 m = 1 &lt;&lt; iota //iota = 4 n //iota = 5 o //iota = 6)替换所有 iota：直接将表达式中的iota全部替换为我们上一步写出的值即可 拓展阅读彻底搞懂 golang 里的 iota","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"iota","slug":"iota","permalink":"http://www.sivan.tech/tags/iota/"}],"author":"yirufeng"},{"title":"BFPRT算法-Golang","slug":"BFPRT算法-Golang","date":"2020-10-12T11:02:42.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/12/BFPRT算法-Golang/","link":"","permalink":"http://www.sivan.tech/2020/10/12/BFPRT%E7%AE%97%E6%B3%95-Golang/","excerpt":"这个BFPRT算法找逻辑Bug找了两天 注意点： 在找中位数的时候对传入的数组进行排序，这里使用直接插入排序，因为元素个数最多为5，插排常数项极低 注意：这里不是nums[j] &gt; nums[i]而是for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j--，因为后面会对nums[i]造成修改 找中位数数组的中位数medianOfMedians返回的是最终的中位数的值，我们使用这个值进行Partition，自己这里还一直将其当做返回的索引用，导致越界 BFPRT函数调用自己的时候，参数一定要对应，自己在写的时候直接将k传入了start","text":"这个BFPRT算法找逻辑Bug找了两天 注意点： 在找中位数的时候对传入的数组进行排序，这里使用直接插入排序，因为元素个数最多为5，插排常数项极低 注意：这里不是nums[j] &gt; nums[i]而是for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j--，因为后面会对nums[i]造成修改 找中位数数组的中位数medianOfMedians返回的是最终的中位数的值，我们使用这个值进行Partition，自己这里还一直将其当做返回的索引用，导致越界 BFPRT函数调用自己的时候，参数一定要对应，自己在写的时候直接将k传入了start 具体流程：其实BFPRT算法与我们之前的快排唯一的区别就在于选择划分元素，之后的partition过程与我们的荷兰国旗划分是一样的。 应用场景：无序数组中找到第K小或第K大的数，也可以找到前K大或前K小的数，因为快速排序的partition长期期望时间复杂度为O(N)，而BFPRT算法的时间复杂度稳定在O(N) 具体流程 将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，时间复杂度：O(1)组内排序，并将所有数组的中位数组成一个新数组，时间复杂度：O(N)获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)，时间复杂度：O(N)之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归，时间复杂度：O(7/10 * n) 如何求前k大或者前k小呢？这里我们的BFPRT算法返回的是第k小的数，但是如果我们想要返回前k小或者前k大的数，我们需要再对数据进行一次遍历，找到比该数小的，如果不够，再加入该数，直到找到k个为止进行返回，同理前k大的数可以转换为长度-k小的，求出之后按照上述思路求得我们最终的前k大的数即可 具体实现 以BFPRT获取第K小的元素为例，例如：直接调用BFPRT(nums, 0, len(nums)-1, 1)找的就是第1小的数也就是最小的数 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;math&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/12 9:08 上午 * @Desc: BFPRT算法步骤：1. 将数组按照5个元素分成一组，最后一组不足5个元素的自成一组，2. 组内排序，并将所有数组的中位数组成一个新数组3. 获得新数组的中位数，使用这个中位数进行partition(partition与我们荷兰国旗问题保持一致)4. 之后判断我们要的第k小或者第k大是否在对应区间内，如果在的话就直接返回，否则选择一侧继续递归*/func min(a, b int) int &#123; if a &gt; b &#123; return b &#125; return a&#125;//采用类似于荷兰国旗问题的划分思路，划分为小于等于与大于三个区间func partition(nums []int, start int, end int, target int) (int, int) &#123; //l, r分别表示小于target已经有序的区域和大于target已经有序的区域 l, r := start-1, end+1 cur := start for cur &lt; r &#123; if nums[cur] &gt; target &#123; nums[r-1], nums[cur] = nums[cur], nums[r-1] r-- &#125; else if nums[cur] &lt; target &#123; nums[cur], nums[l+1] = nums[l+1], nums[cur] l++ cur++ &#125; else if nums[cur] == target &#123; cur++ &#125; &#125; return l + 1, r - 1&#125;//获取传入数组nums在start-&gt;end之间的中位数，包括两个边界func getMedianOfNums(nums []int, start int, end int) int &#123; //对nums[start:end]进行直接插入排序 var temp, j int for i := start + 1; i &lt;= end; i++ &#123; temp = nums[i] //注意点1：nums[j] &gt; temp for j = i - 1; j &gt;= start &amp;&amp; nums[j] &gt; temp; j-- &#123; nums[j+1] = nums[j] &#125; nums[j+1] = temp &#125; return nums[start+(end-start)&gt;&gt;1]&#125;//选取中位数数组的中位数并进行返回func medianOfMedians(nums []int, start int, end int) int &#123; //首先将传入的数组有效区间内的元素每5个划分为1组，不足5个的不划分 //注意点2：是float64(end - start + 1)不是float64(len(nums)) medianNums := make([]int, int(math.Ceil(float64(end-start+1)/5.0))) //找到每个数组的中位数，添加到我们的中位数数组中 for i := 0; i &lt; len(medianNums); i++ &#123; val := getMedianOfNums(nums, start+i*5, min(start+i*5+4, end)) medianNums[i] = val &#125; //返回中位数数组的中位数 return getMedianOfNums(medianNums, 0, len(medianNums)-1)&#125;//最后一个参数k表示要第k小的数，所以我们返回第k小的数，其中k从1开始func BFPRT(nums []int, start int, end int, k int) int &#123; //递归结束条件 if start == end &#123; return nums[start] &#125; //获取nums每5个一组后划分的中位数数组的中位数 //之后根据pivot进行partition //注意点3：这里是medianOfMedians(nums, start, end)而不是nums[medianOfMedians(nums, start, end)] //因为我们medianOfMedians(nums, start, end)返回的就是划分值 l, r := partition(nums, start, end, medianOfMedians(nums, start, end)) //判断k是否在划分后的两个索引 if k &gt;= l &amp;&amp; k &lt;= r &#123; return nums[l] &#125; else if k &lt; l &#123; return BFPRT(nums, start, l-1, k) &#125; else &#123; return BFPRT(nums, r+1, end, k) &#125;&#125; 总结：按照沈剑老师的总结： TopK，不难；其思路优化过程，不简单： 全局排序，O(n*lg(n)) 局部排序，只排序TopK个数，O(n*k) 堆，TopK个数也不排序了，O(n*lg(k)) 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n)) 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n) TopK的另一个解法：随机选择+partition 本文讲解的bfprt，时间复杂度长期稳定在O(N) References 参考","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"BFPRT","slug":"算法/BFPRT","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/BFPRT/"}],"tags":[{"name":"BFPRT","slug":"BFPRT","permalink":"http://www.sivan.tech/tags/BFPRT/"},{"name":"topK","slug":"topK","permalink":"http://www.sivan.tech/tags/topK/"},{"name":"找第几大或第几小","slug":"找第几大或第几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E7%AC%AC%E5%87%A0%E5%A4%A7%E6%88%96%E7%AC%AC%E5%87%A0%E5%B0%8F/"},{"name":"找前几大或前几小","slug":"找前几大或前几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E5%89%8D%E5%87%A0%E5%A4%A7%E6%88%96%E5%89%8D%E5%87%A0%E5%B0%8F/"}],"author":"yirufeng"},{"title":"golang中命令行参数的使用","slug":"golang中命令行参数的使用","date":"2020-10-06T19:16:43.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/06/golang中命令行参数的使用/","link":"","permalink":"http://www.sivan.tech/2020/10/06/golang%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"使用os.Args获取输入的命令行参数os.Args获取输入的命令行参数os.Args本质上是一个切片，会将命令行的内容全部读取，只是将我们输入的内容按照空格进行分割，其中第1个是执行的程序的全路径名称，后面的为我们执行的时候命令行上的其他参数 具体实现 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;os&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/6 6:00 下午 * @Desc: os.Args练习本质上是一个切片，会将命令行的内容全部读取，只是将我们输入的内容按照空格进行分割，其中第1个是程序执行的名称，后面的为我们执行的时候命令行上的其他参数 */func main() &#123; fmt.Println(len(os.Args)) fmt.Println(os.Args)&#125; 使用flag包来解析命令行参数具体步骤StringVar，IntVar，BoolVar需要传入4个参数第1个参数为接收值的变量的地址第2个参数为我们使用命令行中的-后面紧跟的字符作为key第3个参数为默认值第4个参数为参数说明（命令设置错误时的说明）使用flag包解析命令行参数最后一定要记得flag.Parse()之后，我们上面的设置的解析参数才会生效 到时候执行如下代码的时候，我们需要先使用go build指令进行编译，编译之后运行可执行文件的时候后面还得加上参数，这里我们应该加上./demo -h 10.26.166.14 -p 3309 -o false 如果不指定参数的时候我们将会使用程序中设置的默认值来读取","text":"使用os.Args获取输入的命令行参数os.Args获取输入的命令行参数os.Args本质上是一个切片，会将命令行的内容全部读取，只是将我们输入的内容按照空格进行分割，其中第1个是执行的程序的全路径名称，后面的为我们执行的时候命令行上的其他参数 具体实现 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;os&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/6 6:00 下午 * @Desc: os.Args练习本质上是一个切片，会将命令行的内容全部读取，只是将我们输入的内容按照空格进行分割，其中第1个是程序执行的名称，后面的为我们执行的时候命令行上的其他参数 */func main() &#123; fmt.Println(len(os.Args)) fmt.Println(os.Args)&#125; 使用flag包来解析命令行参数具体步骤StringVar，IntVar，BoolVar需要传入4个参数第1个参数为接收值的变量的地址第2个参数为我们使用命令行中的-后面紧跟的字符作为key第3个参数为默认值第4个参数为参数说明（命令设置错误时的说明）使用flag包解析命令行参数最后一定要记得flag.Parse()之后，我们上面的设置的解析参数才会生效 到时候执行如下代码的时候，我们需要先使用go build指令进行编译，编译之后运行可执行文件的时候后面还得加上参数，这里我们应该加上./demo -h 10.26.166.14 -p 3309 -o false 如果不指定参数的时候我们将会使用程序中设置的默认值来读取 具体实现 123456789101112131415161718192021222324252627282930package mainimport ( &quot;flag&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/6 6:10 下午 * @Desc: flag 包的使用 */func main() &#123; var host string var port int var isopen bool //第1个参数为我们从命令行中获取对应的值之后要赋值给具体哪个变量，第2个为命令行输入参数对应的key，第3个为默认值，第4个为执行错误的说明 flag.StringVar(&amp;host, &quot;h&quot;, &quot;127.0.0.1&quot;, &quot;the ip address of your machine&quot;) flag.IntVar(&amp;port, &quot;p&quot;, 3306, &quot;the port of application&quot;) flag.BoolVar(&amp;isopen, &quot;o&quot;, false, &quot;please check if database is open&quot;) //前面设置了之后，最后一定要加上这一句话才会解析我们命令行中的参数 flag.Parse() fmt.Println(&quot;打印我们获取到的变量的内容：&quot;, host, port, isopen)&#125;","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"flag","slug":"flag","permalink":"http://www.sivan.tech/tags/flag/"}],"author":"yirufeng"},{"title":"golang中关于文件的操作","slug":"golang中关于文件的操作","date":"2020-10-06T19:15:30.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/06/golang中关于文件的操作/","link":"","permalink":"http://www.sivan.tech/2020/10/06/golang%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"终端读写操作note info 默认主题色，适合中性的信息 终端读写相关的文件句柄常量os.Stdin 标准输入os.Stdout 标准输出os.Stderr 标准错误以上3个都是以文件的形式存在","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"文件","slug":"文件","permalink":"http://www.sivan.tech/tags/%E6%96%87%E4%BB%B6/"}],"author":"yirufeng"},{"title":"golang中的错误处理","slug":"Golang中的错误处理","date":"2020-10-05T20:46:39.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/05/Golang中的错误处理/","link":"","permalink":"http://www.sivan.tech/2020/10/05/Golang%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","excerpt":"自定义错误因为error是一个接口，因此我们可以自定义一个error实际开发中我们要判断错误的类型，直接进行类型断言（也可以通过switch进行类型断言分支） 三部曲自定义一个错误 自定义一个错误结构体实现我们的Error方法返回错误的时候直接返回一个&amp;我们自己的错误 注意：我们最常用的就是errors.New(字符串)","text":"自定义错误因为error是一个接口，因此我们可以自定义一个error实际开发中我们要判断错误的类型，直接进行类型断言（也可以通过switch进行类型断言分支） 三部曲自定义一个错误 自定义一个错误结构体实现我们的Error方法返回错误的时候直接返回一个&amp;我们自己的错误 注意：我们最常用的就是errors.New(字符串) 具体实现 主要代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/5 12:10 下午 * @Desc: 错误处理，3部曲，自己已经罗列在下方了背景：因为error是一个interface，因此我们可以自定义错误，并进行返回另外一种返回错误的方法，比较常用：`return errors.New(&quot;这是一个简单的错误&quot;)`*///自定义一个错误//1. 自定义一个错误结构体type FileError struct &#123; Path string //记录文件所在路径 Err string //记录文件名 OpType string //记录对文件的什么操作&#125;//2. 实现Error方法func (f *FileError) Error() string &#123; return fmt.Sprintf(&quot;%s %s %s&quot;, f.Path, f.Err, f.OpType)&#125;//3. 返回的时候直接返回我们错误结构体的引用func fail() error &#123; //另外一种返回错误的方法，比较常用 //return errors.New(&quot;这是一个简单的错误&quot;) return &amp;FileError&#123; Path: &quot;./&quot;, Err: &quot;无法打开文件&quot;, OpType: &quot;read&quot;, &#125;&#125;func main() &#123; err := fail() if err != nil &#123; fmt.Println(err) &#125; fmt.Println()&#125;","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"错误","slug":"go/错误","permalink":"http://www.sivan.tech/categories/go/%E9%94%99%E8%AF%AF/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"错误","slug":"错误","permalink":"http://www.sivan.tech/tags/%E9%94%99%E8%AF%AF/"},{"name":"error","slug":"error","permalink":"http://www.sivan.tech/tags/error/"}],"author":"yirufeng"},{"title":"golang的序列化","slug":"Golang的序列化","date":"2020-10-05T20:46:31.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/10/05/Golang的序列化/","link":"","permalink":"http://www.sivan.tech/2020/10/05/Golang%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"Go中使用encoding/json中的Marshal以及Unmarshal对数据进行序列化和反序列化json中的key永远为字符串，Golang中一般我们键都为string，value为interface，之后拿到interface采用反射来判断类型，序列化的时候首字母必须大写，不然访问不到如果希望序列化之后结构体的key有其他别名或者首字母小写，可以加上一个tag 具体的序列化 map序列化之后，Key为json中的key,value也是json中的value结构体序列化之后，如果有tag，那么key就是对应的tag 注意：使用Unmarshal()的时候，第2个参数，直接传声明的变量进去即可，因为Golang会自动帮我们分配内存和赋值例如传入一个只声明的map或结构体","text":"Go中使用encoding/json中的Marshal以及Unmarshal对数据进行序列化和反序列化json中的key永远为字符串，Golang中一般我们键都为string，value为interface，之后拿到interface采用反射来判断类型，序列化的时候首字母必须大写，不然访问不到如果希望序列化之后结构体的key有其他别名或者首字母小写，可以加上一个tag 具体的序列化 map序列化之后，Key为json中的key,value也是json中的value结构体序列化之后，如果有tag，那么key就是对应的tag 注意：使用Unmarshal()的时候，第2个参数，直接传声明的变量进去即可，因为Golang会自动帮我们分配内存和赋值例如传入一个只声明的map或结构体 具体实现 主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/5 11:49 上午 * @Desc: 序列化数据与数据的反序列化 */type Book struct &#123; Id string `json:&quot;book_id&quot;` Title string `json:&quot;book_name&quot;` Press string `json:&quot;book_press&quot;`&#125;type Student struct &#123; Name string Age int Gender bool ClassInfo map[int][]string //学生所属的班级信息&#125;func MarshalMap() ([]byte, error) &#123; mymap := make(map[int]string) mymap[110] = &quot;警察&quot; mymap[120] = &quot;救护&quot; data, err := json.Marshal(mymap) if err != nil &#123; fmt.Println(&quot;序列化结构体失败----------------------&quot;) return nil, err &#125; return data, nil&#125;func MarshalTagStruct() ([]byte, error) &#123; book := &amp;Book&#123; Id: &quot;12333&quot;, Title: &quot;鲁滨孙漂流记&quot;, Press: &quot;电子信息出版社&quot;, &#125; data, err := json.Marshal(book) if err != nil &#123; fmt.Println(&quot;序列化结构体失败----------------------&quot;) return nil, err &#125; fmt.Println(string(data)) return data, err&#125;func MarshalUnTagStruct() ([]byte, error) &#123; classInfo := make(map[int][]string) classInfo[1501] = []string&#123;&quot;理论&quot;, &quot;时间&quot;&#125; //定义一个学生 stu := &amp;Student&#123; Name: &quot;yirufeng&quot;, Age: 22, Gender: true, ClassInfo: classInfo, &#125; data, err := json.Marshal(stu) if err != nil &#123; fmt.Println(&quot;序列化结构体失败----------------------&quot;) return nil, err &#125; fmt.Println(string(data)) return data, nil&#125;func MarshalInt() &#123; num := 10000 data, err := json.Marshal(num) if err != nil &#123; fmt.Println(&quot;序列化int失败----------------------&quot;) return &#125; fmt.Println(string(data))&#125;func MarshalSlice() &#123; name := []string&#123;&quot;231321&quot;, &quot;3213&quot;, &quot;412&quot;&#125; data, err := json.Marshal(name) if err != nil &#123; fmt.Println(&quot;序列化切片失败----------------------&quot;) return &#125; fmt.Println(string(data))&#125;func UnmarshalMap(content []byte) &#123; stuMap := make(map[int]string) err := json.Unmarshal(content, &amp;stuMap) if err != nil &#123; fmt.Println(&quot;反序列化map失败----------------------&quot;, err) return &#125; fmt.Println(&quot;反序列化map成功-----------&quot;) fmt.Println(stuMap)&#125;func UnmarshalStruct(data interface&#123;&#125;) &#123; var ret Student err := json.Unmarshal(data.([]byte), &amp;ret) if err != nil &#123; fmt.Println(&quot;反序列化结构体失败----------------------&quot;, err) return &#125; fmt.Println(&quot;反序列化结构体成功-----------&quot;) fmt.Println(ret)&#125;func main() &#123; MarshalInt() MarshalSlice() MarshalTagStruct() data, err := MarshalMap() if err != nil &#123; fmt.Println(&quot;序列化map失败----------------------&quot;) return &#125; UnmarshalMap(data) data2, err := MarshalUnTagStruct() if err != nil &#123; fmt.Println(&quot;序列化结构体失败----------------------&quot;) return &#125; UnmarshalStruct(data2)&#125;","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"json","slug":"go/json","permalink":"http://www.sivan.tech/categories/go/json/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"序列化","slug":"序列化","permalink":"http://www.sivan.tech/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"yirufeng"},{"title":"爬取豆瓣Top250电影","slug":"爬取豆瓣Top250电影","date":"2020-10-01T11:01:37.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/10/01/爬取豆瓣Top250电影/","link":"","permalink":"http://www.sivan.tech/2020/10/01/%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3Top250%E7%94%B5%E5%BD%B1/","excerpt":"前言 十一无聊，想着看几部电影来happy一下，不知道有什么精彩电影，于是就爬取一下豆瓣的Top250 项目已经开源到了网站 实现步骤 爬取页面内容(伪装一个user-agent)获取页面内容后使用正则表达式提取自己想要的内容(正则表达式编写)将自己提取到的内容存放到数据库中(go的数据持久化)","text":"前言 十一无聊，想着看几部电影来happy一下，不知道有什么精彩电影，于是就爬取一下豆瓣的Top250 项目已经开源到了网站 实现步骤 爬取页面内容(伪装一个user-agent)获取页面内容后使用正则表达式提取自己想要的内容(正则表达式编写)将自己提取到的内容存放到数据库中(go的数据持久化) 具体实现 主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package mainimport ( &quot;fmt&quot; &quot;go-crawl-douban/db&quot; &quot;go-crawl-douban/model&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;regexp&quot; &quot;strconv&quot; &quot;strings&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/29 8:54 下午 * @Desc: 爬取豆瓣电影Top250数据 *//*页面规则： https://movie.douban.com/top250?start=0&amp;filter=start表示从多少开始显示当前页面，爬取一下电影信息：电影名导演时间国家分类评分多少人评价每个电影下面的最经典的一句话*/const ( UserAgent = &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36&quot; //每个电影对应的信息解析器 contentRegex = `&lt;div class=&quot;hd&quot;&gt;[^&lt;]*&lt;a[^&gt;]*&gt;[^&lt;]*&lt;span[^&gt;]*&gt;([^&lt;]*)&lt;/span&gt;[^&lt;]*(&lt;span[^&gt;]*&gt;[^&lt;]*&lt;/span&gt;)?[^&lt;]*&lt;span[^&gt;]*&gt;[^&lt;]*&lt;/span&gt;[^&lt;]*&lt;/a&gt;[^&lt;]*(&lt;span[^&gt;]*&gt;[^&lt;]*&lt;/span&gt;)?[^&lt;]*&lt;/div&gt;[^&lt;]*&lt;div[^&gt;]*&gt;[^&lt;]*&lt;p[^&gt;]*&gt;([^&lt;]*)&lt;br&gt;([^&lt;]*)&lt;/p&gt;[^&lt;]*&lt;div[^&gt;]*&gt;[^&lt;]*&lt;span[^&gt;]*&gt;&lt;/span&gt;[^&lt;]*&lt;span[^&gt;]*&gt;([^&lt;]*)&lt;/span&gt;[^&lt;]*&lt;span[^&gt;]*&gt;&lt;/span&gt;[^&lt;]*&lt;span&gt;([^人]*)人评价&lt;/span&gt;[^&lt;]*&lt;/div&gt;[^&lt;]*(&lt;p[^&gt;]*&gt;[^&lt;]*&lt;span[^&gt;]*&gt;([^&lt;]*)&lt;/span&gt;[^&lt;]*&lt;/p&gt;)?[^&lt;]*&lt;/div&gt;` //提取导演名字 directorRegex = `导演: ([^a-zA-Z]*)`)//获取第几页对应的页面URLfunc UrlConfig(page int) string &#123; return fmt.Sprintf(&quot;https://movie.douban.com/top250?start=%d&amp;filter=&quot;, (page-1)*25)&#125;func contentParser(moviesList *[]model.Movie) &#123; client := http.Client&#123;&#125; regMovieContent := regexp.MustCompile(contentRegex) for i := 1; i &lt;= 10; i++ &#123; fmt.Println(&quot;请求的url为：&quot;, UrlConfig(i)) //模拟一个新的http请求 req, _ := http.NewRequest(&quot;GET&quot;, UrlConfig(i), nil) //给请求添加伪装的请求头部 req.Header.Add(&quot;User-Agent&quot;, UserAgent) //发起请求 resp, _ := client.Do(req) //打印一下爬取页面的状态码 fmt.Printf(&quot;--------------------------------请求第%d页，状态码：%d--------------------------------\\n&quot;, i, resp.StatusCode) //读取页面爬取的数据 body, _ := ioutil.ReadAll(resp.Body) //fmt.Println(string(body)) //使用正则匹配进行匹配 retMovie := regMovieContent.FindAllStringSubmatch(string(body), -1) for _, v := range retMovie &#123; //v[0]为匹配到的全部信息 //v[1]为中文名字，v[2]为电影的别名或英文名字,v[3]为电影是否可以播放 //v[4]为导演主演信息 //v[5]为时间+国家+分类 //v[6]为评分 //v[7]为多少人评价 //v[8]为分组捕获的一句话的p标签 //v[9]为对应的一句话 //director, star := getDirectorAndStar(v[4]) time, country, category := getMovieOthers(v[5]) //给电影结构体赋值 tempMovie := model.Movie&#123;&#125; tempMovie.Name = v[1] tempMovie.Category = category tempMovie.Country = country tempMovie.Quote = v[9] tempMovie.Rating = v[6] tempMovie.Time = time tempMovie.People, _ = strconv.Atoi(v[7]) *moviesList = append(*moviesList, tempMovie) &#125; //fmt.Printf(&quot;--------------------------------第%d页抓取到：%d条--------------------------------\\n&quot;, i, len(ret)) &#125; fmt.Printf(&quot;--------------------------------爬取成功，共爬取到信息：%d条--------------------------------\\n&quot;, len(*moviesList))&#125;//获取电影的导演以及主演名字//TODO：提取电影的导演以及主演名字func getDirectorAndStar(content string) (director string, star string) &#123; //reg := regexp.MustCompile(directorRegex) //fmt.Println(content) //ret := reg.FindAllStringSubmatch(strings.Trim(content, &quot; &quot;), -1) // //ret2 := strings.Split(strings.Trim(ret[0][0], &quot; &quot;), &quot; &quot;) //fmt.Println(len(ret)) //fmt.Println(ret2) return&#125;//得到电影的时间，国家以及分类func getMovieOthers(content string) (time string, country string, category string) &#123; ret := strings.Split(strings.Trim(content, &quot; &quot;), &quot;&amp;nbsp;/&amp;nbsp;&quot;) time, country, category = ret[0], ret[1], ret[2] time = time[len(time)-4:] return&#125;func main() &#123; moviesList := []model.Movie&#123;&#125; contentParser(&amp;moviesList) for index, movie := range moviesList &#123; opType := db.AddMovieData(movie) if opType &#123; fmt.Printf(&quot;插入第%d条数据成功\\n&quot;, index+1) &#125; else &#123; fmt.Printf(&quot;插入第%d条数据失败\\n&quot;, index+1) &#125; &#125;&#125; 数据持久化相关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package db/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/10/1 10:01 上午 * @Desc: 关于将电影插入mysql的操作 */import ( &quot;database/sql&quot; &quot;fmt&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;go-crawl-douban/config&quot; &quot;go-crawl-douban/model&quot;)var conn *sql.DBfunc init() &#123; dataSourceName := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s&quot;, config.MysqlUsername, config.MysqlPwd, config.MysqlHost, config.MysqlPort, config.MysqlDatabase) conn, _ = sql.Open(&quot;mysql&quot;, dataSourceName) if conn.Ping() != nil &#123; fmt.Println(&quot;---------------------------初始化mysql连接失败---------------------------&quot;) return &#125; fmt.Println(&quot;---------------------------初始化mysql连接成功---------------------------&quot;)&#125;//向电影表中添加电影数据，如果添加成功就返回true，否则返回falsefunc AddMovieData(movie model.Movie) bool &#123; sqlstr := &quot;insert into movie(name, time, country, category, rating, people, quote) values(?, ?, ?, ?, ?, ?, ?)&quot; stmt, err := conn.Prepare(sqlstr) if err != nil &#123; fmt.Println(&quot;---------------------------插入电影数据预编译失败，请稍后再试---------------------------&quot;, err) return false &#125; ret, err := stmt.Exec(movie.Name, movie.Time, movie.Country, movie.Category, movie.Rating, movie.People, movie.Quote) fmt.Println(err) if num, err := ret.RowsAffected(); num &gt; 0 &amp;&amp; nil == err &#123; fmt.Println(&quot;---------------------------插入成功---------------------------&quot;) return true &#125; fmt.Println(err) return false&#125;","categories":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"爬虫","slug":"go/爬虫","permalink":"http://www.sivan.tech/categories/go/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.sivan.tech/tags/%E7%88%AC%E8%99%AB/"}],"author":"yirufeng"},{"title":"固定长度的数组实现栈","slug":"固定长度的数组实现栈","date":"2020-09-26T20:43:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/26/固定长度的数组实现栈/","link":"","permalink":"http://www.sivan.tech/2020/09/26/%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/","excerpt":"题目描述使用一个固定长度大小的数组实现栈 思路 思路：使用一个index进行指向当前可以插入元素的位置 使用一个index指向下次栈中加入元素的位置如果要弹出元素，需要判断index是否大于1，如果大于弹出index-1位置的元素，index减去1，否则不可以弹出。如果要加入元素，直接加入到index指向的位置，之后index++","text":"题目描述使用一个固定长度大小的数组实现栈 思路 思路：使用一个index进行指向当前可以插入元素的位置 使用一个index指向下次栈中加入元素的位置如果要弹出元素，需要判断index是否大于1，如果大于弹出index-1位置的元素，index减去1，否则不可以弹出。如果要加入元素，直接加入到index指向的位置，之后index++ 具体实现 实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type Stack struct &#123; data []int cap int size int&#125;func (s *Stack) Push(num int) &#123; //如果栈满 if s.size == s.cap &#123; return &#125; s.data = append(s.data, num) s.size++&#125;func (s *Stack) Peek() int &#123; return s.data[s.size-1]&#125;func (s *Stack) IsEmpty() bool &#123; if s.size == 0 &#123; return true &#125; return false&#125;func (s *Stack) Pop() int &#123; if s.IsEmpty() &#123; return -1 &#125; val := s.data[s.size-1] s.data = s.data[:s.size-1] s.size-- return val&#125;func main() &#123; s := Stack&#123; data: []int&#123;&#125;, cap: 3, &#125; s.Push(123) s.Push(134) s.Push(132) s.Push(145) fmt.Println(s.Peek()) fmt.Println(s.Pop())&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.sivan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://www.sivan.tech/tags/%E6%A0%88/"}],"author":"yirufeng"},{"title":"固定长度的数组实现队列","slug":"固定长度的数组实现队列","date":"2020-09-26T20:42:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/26/固定长度的数组实现队列/","link":"","permalink":"http://www.sivan.tech/2020/09/26/%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"题目描述使用一个固定长度大小的数组实现队列 思路 思路：使用start指向队头，end指向队尾的下一个位置 我们加了一个标志位empty区分start等于end的两种情况，一种是队列中没有元素，另外一种是队列元素满。如果要弹出元素，需要判断end是否等于start，如果empty为真且start等于end，说明不可以弹出，否则可以弹出元素。如果要加入元素，直接加入到end指向的位置，之后end需要判断是否处于最后一个位置，如果是则跳转到数组第1个位置，否则end++。同时判断是否满元素来更新empty","text":"题目描述使用一个固定长度大小的数组实现队列 思路 思路：使用start指向队头，end指向队尾的下一个位置 我们加了一个标志位empty区分start等于end的两种情况，一种是队列中没有元素，另外一种是队列元素满。如果要弹出元素，需要判断end是否等于start，如果empty为真且start等于end，说明不可以弹出，否则可以弹出元素。如果要加入元素，直接加入到end指向的位置，之后end需要判断是否处于最后一个位置，如果是则跳转到数组第1个位置，否则end++。同时判断是否满元素来更新empty 具体实现 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package mainimport ( &quot;fmt&quot; &quot;log&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/26 7:41 下午 * @Desc: 固定长度的数组实现队列 *//*固定长度的数组实现队列因为Golang数组长度是确定的，所以这里我们使用一个长度为5的数组作为演示 */type Queue struct &#123; data [5]int start, end int //指向队头位置,end指向下一个可以插入数据元素的位置 empty bool //加了一个标志位来区分是满了还是没有元素&#125;//队列加入元素func (q *Queue) Push(x int) &#123; //说明队列满了 if q.start == q.end &amp;&amp; !q.empty &#123; log.Println(&quot;加入元素------------&gt;无法加入，队列满了&quot;) return &#125; q.data[q.end] = x if q.end == 4 &#123; q.end = 0 //从0开始 &#125; else &#123; q.end++ &#125; if q.start == q.end &#123; q.empty = false &#125;&#125;//队列弹出队头func (q *Queue) Poll() int &#123; //说明队列空 if q.start == q.end &amp;&amp; q.empty &#123; log.Println(&quot;弹出队头------------&gt;没有队头，队列为空&quot;) return -1 &#125; val := q.data[q.start] q.start++ if q.start == q.end &#123; q.empty = true &#125; return val&#125;//队列查看队头func (q *Queue) Peek() int &#123; //没有队头 //说明队列空 if q.start == q.end &amp;&amp; q.empty &#123; log.Println(&quot;查看队头------------&gt;没有队头，队列为空&quot;) return -1 &#125; return q.data[q.start]&#125;func main() &#123; q := &amp;Queue&#123; start: 0, end: 0, empty: true, &#125; q.Push(1) q.Push(2) q.Push(3) q.Push(4) q.Push(5) q.Push(6) fmt.Println(q.data) fmt.Println(q.Poll()) fmt.Println(q.Poll())&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.sivan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"http://www.sivan.tech/tags/%E9%98%9F%E5%88%97/"}],"author":"yirufeng"},{"title":"不基于比较的排序找到数组排序后的最大差值","slug":"不基于找到数组排序后的最大差值","date":"2020-09-26T20:38:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/26/不基于找到数组排序后的最大差值/","link":"","permalink":"http://www.sivan.tech/2020/09/26/%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","excerpt":"题目描述给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 注意不基于比较哦 思路 思路：桶排序 假设数组长度为n，准备n+1个桶遍历该数组，将最小值放入到第1个位置，将最大值放入到最后一个位置将剩下的数等分成等分成n-1份依次放入剩下对应范围的桶中，最后这n+1个桶中至少有一个空桶，说明桶内的数值差不是最大差值，我们去桶间找最大差值对于每个桶，我们都保存了每个桶的最小值和最大值，从第2个桶开始，每次计算当前桶的最小值与前一个桶(要有元素)的最大值的差，过程中我们动态更新最大差值","text":"题目描述给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序 注意不基于比较哦 思路 思路：桶排序 假设数组长度为n，准备n+1个桶遍历该数组，将最小值放入到第1个位置，将最大值放入到最后一个位置将剩下的数等分成等分成n-1份依次放入剩下对应范围的桶中，最后这n+1个桶中至少有一个空桶，说明桶内的数值差不是最大差值，我们去桶间找最大差值对于每个桶，我们都保存了每个桶的最小值和最大值，从第2个桶开始，每次计算当前桶的最小值与前一个桶(要有元素)的最大值的差，过程中我们动态更新最大差值 具体编码 实现代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func GetMaxDiff(nums []int) int &#123; maxNum := make([]int, len(nums)+1) minNum := make([]int, len(nums)+1) hasNum := make([]bool, len(nums)+1) //用来标记桶是否有值 min, max := math.MaxInt64, math.MinInt64 //整个数组的最小值和最大值 maxDiff := math.MinInt64 //最大差值 //找数组的最大值与最小值 for _, v := range nums &#123; if v &gt; max &#123; max = v &#125; if min &gt; v &#123; min = v &#125; &#125; //第一个位置放最小值，第2个位置放最大值 hasNum[0], hasNum[len(nums)] = true, true //将最大值与最小值之间等分成n(n为数组的长度)-1份，依次遍历属于哪个范围就加入哪个桶 diff := float64(max-min) / float64(len(nums)-1) for _, v := range nums &#123; indexBucket := int(math.Ceil(float64(v-min) / diff)) //如果当前桶没有值 if !hasNum[indexBucket] &#123; maxNum[indexBucket] = v minNum[indexBucket] = v &#125; else &#123; //当前桶有值且当前桶的最大值小于当前元素 则更新 if maxNum[indexBucket] &lt; v &#123; maxNum[indexBucket] = v &#125; if minNum[indexBucket] &gt; v &#123; minNum[indexBucket] = v &#125; &#125; //最后将当前桶置为true，说明已放入元素 hasNum[indexBucket] = true &#125; //这里要注意：不是两个相邻的桶之间进行比较 //遍历桶，找当前桶与上一个存放元素的桶的最大差值并返回 lastMax := min //存放上一个最大 for i := 1; i &lt; len(nums); i++ &#123; if hasNum[i] &#123; if maxDiff &lt; minNum[i]-lastMax &#123; maxDiff = minNum[i] - lastMax &#125; lastMax = maxNum[i] &#125; &#125; return maxDiff&#125;func main() &#123; nums := utils.RandArrayRange(10, 10, 99) fmt.Println(nums) fmt.Println(GetMaxDiff(nums))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"桶排序","slug":"桶排序","permalink":"http://www.sivan.tech/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"堆排序","slug":"堆排序","date":"2020-09-24T21:07:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/24/堆排序/","link":"","permalink":"http://www.sivan.tech/2020/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"堆排序基本知识 基本介绍 堆是一个完全二叉树，因此我们可以利用节点的特性去使用一个数组模拟一颗完全二叉树：下标为i的节点的左子节点的下标为i*2+1, 右子节点的下标为i*2+2下标为i的节点的父节点的下标为(i-1)/2 建立堆的时间复杂度：O(log1) + O(log2) + … + O(logN) 近似于 O(N)，因此建立堆的时间复杂度为O(N) 堆有大根堆以及小根堆，没有规定堆中左子树的根必须大于(或小于)右子树的根。 堆排序的两个基本步骤：(具体说明看代码注释) 建堆，循环将数组中的每个数加入堆中（每次都需要heapInsert）不断从堆的最后一个元素交换到堆的头部，然后将堆的长度减小1，再调整堆，每次都需要heapify","text":"堆排序基本知识 基本介绍 堆是一个完全二叉树，因此我们可以利用节点的特性去使用一个数组模拟一颗完全二叉树：下标为i的节点的左子节点的下标为i*2+1, 右子节点的下标为i*2+2下标为i的节点的父节点的下标为(i-1)/2 建立堆的时间复杂度：O(log1) + O(log2) + … + O(logN) 近似于 O(N)，因此建立堆的时间复杂度为O(N) 堆有大根堆以及小根堆，没有规定堆中左子树的根必须大于(或小于)右子树的根。 堆排序的两个基本步骤：(具体说明看代码注释) 建堆，循环将数组中的每个数加入堆中（每次都需要heapInsert）不断从堆的最后一个元素交换到堆的头部，然后将堆的长度减小1，再调整堆，每次都需要heapify 具体实现 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384func HeapSort(nums []int) []int &#123; heapSort(nums) return nums&#125;func heapSort(nums []int) &#123; if nums == nil || len(nums) &lt; 2 &#123; return &#125; //建立堆的过程 for i := 0; i &lt; len(nums); i++ &#123; heapInsert(nums, i) &#125; log.Println(&quot;建堆完成---------------&gt;&quot;, nums) heapSize := len(nums) //之后不断吐出元素 for heapSize &gt; 0 &#123; nums[0], nums[heapSize-1] = nums[heapSize-1], nums[0] heapSize-- heapify(nums, heapSize, 0) &#125;&#125;//用于新加入一个元素之后，向上调整堆//第2个参数表示新加入的元素的下标//这个过程的时间复杂度为O(N) = O(log1 + log2 + ... + logN) 近似等于 O(N)func heapInsert(nums []int, index int) &#123; //这里左神说了不用加循环结束条件，因为最终的结束条件就是index为0的时候 //因为-1/2也为0 for nums[(index-1)/2] &lt; nums[index] &#123; nums[index], nums[(index-1)&gt;&gt;1] = nums[(index-1)&gt;&gt;1], nums[index] index = (index - 1) &gt;&gt; 1 &#125;&#125;//左老师的写法////func heapify(nums []int, heapSize int, index int) &#123;//// left := 2*index + 1// for left &lt; heapSize &#123;// larger := left// //首先找到左右孩子中最大的// if left+1 &lt; heapSize &amp;&amp; nums[left] &lt; nums[left+1] &#123;// larger++// &#125;//// //这里要注意一下，如果使用一个变量这里可能会溢出，这里我们使用的larger经过了前面的验证// if nums[larger] &lt;= nums[index] &#123;// break// &#125;//// nums[index], nums[larger] = nums[larger], nums[index]// index = larger// left = index*2 + 1// &#125;//&#125;//用于将堆顶的元素和堆中最后一个元素交换之后，向下调整堆//第2个参数为堆的实际大小，因为nums是存放一个数组，//第3个参数表示该位置元素变动，导致该元素可能要往下沉//真正的堆是从0-&gt;heapSize-1func heapify(nums []int, heapSize int, index int) &#123; //注意循环条件 for i := index; i*2+1 &lt; heapSize; &#123; left := 2*i + 1 //如果有右并且右比左大 if left+1 &lt; heapSize &amp;&amp; nums[left+1] &gt; nums[left] &#123; left++ &#125; //与左右中较大的比较 if nums[i] &gt;= nums[left] &#123; break &#125; nums[i], nums[left] = nums[left], nums[i] i = left &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.sivan.tech/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"Golang连接mysql插入时间早8个小时","slug":"golang连接mysql时间","date":"2020-09-24T09:48:42.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/24/golang连接mysql时间/","link":"","permalink":"http://www.sivan.tech/2020/09/24/golang%E8%BF%9E%E6%8E%A5mysql%E6%97%B6%E9%97%B4/","excerpt":"问题描述使用Golang操作Mysql，插入一条记录后发现新插入的时间比当前时间早了8个小时。 使用go-sql-driver来连接mysql数据库，获取的时区默认是UTC +0的，与本地的东八区是有区别，在业务处理中会出现问题 获取mysql中的日期，是string类型，需要在代码中用time.Parse进行转化 解决方案在连接的dataSourceName中加上parseTime=True和loc=local。此处的local可以更换为具体的时区(Asia/Shanghai) 修改之前的dataSourceName 123dataBaseSource := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&quot;, MysqlUser, MysqlPassword, MysqlHost, MysqlPort, MysqlDatabase, MysqlCharset)conn, _ := sql.Open(&quot;mysql&quot;, dataBaseSource) 修改后的dataSourceName 123dataBaseSource := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&amp;loc=Local&amp;parseTime=true&quot;, MysqlUser, MysqlPassword, MysqlHost, MysqlPort, MysqlDatabase, MysqlCharset)conn, _ := sql.Open(&quot;mysql&quot;, dataBaseSource)","text":"问题描述使用Golang操作Mysql，插入一条记录后发现新插入的时间比当前时间早了8个小时。 使用go-sql-driver来连接mysql数据库，获取的时区默认是UTC +0的，与本地的东八区是有区别，在业务处理中会出现问题 获取mysql中的日期，是string类型，需要在代码中用time.Parse进行转化 解决方案在连接的dataSourceName中加上parseTime=True和loc=local。此处的local可以更换为具体的时区(Asia/Shanghai) 修改之前的dataSourceName 123dataBaseSource := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&quot;, MysqlUser, MysqlPassword, MysqlHost, MysqlPort, MysqlDatabase, MysqlCharset)conn, _ := sql.Open(&quot;mysql&quot;, dataBaseSource) 修改后的dataSourceName 123dataBaseSource := fmt.Sprintf(&quot;%s:%s@tcp(%s:%s)/%s?charset=%s&amp;loc=Local&amp;parseTime=true&quot;, MysqlUser, MysqlPassword, MysqlHost, MysqlPort, MysqlDatabase, MysqlCharset)conn, _ := sql.Open(&quot;mysql&quot;, dataBaseSource)","categories":[{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.sivan.tech/tags/Mysql/"}],"author":"yirufeng"},{"title":"（算法）统计逆序对","slug":"算法-统计逆序对","date":"2020-09-23T17:44:01.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/23/算法-统计逆序对/","link":"","permalink":"http://www.sivan.tech/2020/09/23/%E7%AE%97%E6%B3%95-%E7%BB%9F%E8%AE%A1%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"题意逆序对，如果前面的元素大于后面的元素则为一个逆序对，统计一个数组中逆序对的个数并返回 思路思路：每次遇到左半边数组的元素大于右边数组元素，说明产生逆序对 产生逆序对的个数为：(mid - 左边数组元素当前下标 + 1)。说明有这么多个元素是大于当前右边数组这个元素。 一句话总结就是：如果右半部分数组当前元素小于左半部分数组的当前元素，那么当前左半部分数组的当前元素后面的元素(包括当前元素)都是大于右半部分数组当前元素的，也就是统计左半部分数组当前元素后面元素(包括当前元素)有多少个即可。 例如：左半部分数组为1，3，4 右半部分数组为1，2，5那么如果当前左半部分数组元素为3，右半部分数组当前元素为2，此时产生的逆序对便是左半部分数组元素3右边所有的元素(包括3这个元素)","text":"题意逆序对，如果前面的元素大于后面的元素则为一个逆序对，统计一个数组中逆序对的个数并返回 思路思路：每次遇到左半边数组的元素大于右边数组元素，说明产生逆序对 产生逆序对的个数为：(mid - 左边数组元素当前下标 + 1)。说明有这么多个元素是大于当前右边数组这个元素。 一句话总结就是：如果右半部分数组当前元素小于左半部分数组的当前元素，那么当前左半部分数组的当前元素后面的元素(包括当前元素)都是大于右半部分数组当前元素的，也就是统计左半部分数组当前元素后面元素(包括当前元素)有多少个即可。 例如：左半部分数组为1，3，4 右半部分数组为1，2，5那么如果当前左半部分数组元素为3，右半部分数组当前元素为2，此时产生的逆序对便是左半部分数组元素3右边所有的元素(包括3这个元素) 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func MergeSort(nums []int) int &#123; if nums == nil || len(nums) &lt; 2 &#123; return 0 &#125; return mergeSort(nums, 0, len(nums)-1)&#125;func mergeSort(nums []int, l, r int) int &#123; //递归结束条件 if l == r &#123; return 0 &#125; //注意这个写法：可以避免越界同时使用&gt;&gt;1加速运算 mid := l + (r-l)&gt;&gt;1 //分治 return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r) //合并两部分[l,mid] [mid+1,r]&#125;func merge(nums []int, l, mid, r int) int &#123; i, j := l, mid+1 //申请一个辅助数组 help := make([]int, r-l+1) index := 0 ret := 0 //谁小填谁移谁 for i &lt;= mid &amp;&amp; j &lt;= r &#123; if nums[i] &gt; nums[j] &#123; //产生逆序对 help[index] = nums[j] ret += (mid - i + 1) j++ &#125; else &#123; help[index] = nums[i] i++ &#125; index++ &#125; //移动剩下的一部分 //注意下面两个是for循环，不是if //另外注意的是下面两个for循环有且只有一个可以被执行 for i &lt;= mid &#123; help[index] = nums[i] index++ i++ &#125; for j &lt;= r &#123; help[index] = nums[j] index++ j++ &#125; //此时help已经填充好我们排序后的数字了，我们需要将且拷贝到原数组的l-&gt;r for i := l; i &lt;= r; i++ &#123; nums[i] = help[i-l] &#125; return ret&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"http://www.sivan.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"统计逆序对","slug":"统计逆序对","permalink":"http://www.sivan.tech/tags/%E7%BB%9F%E8%AE%A1%E9%80%86%E5%BA%8F%E5%AF%B9/"}],"author":"yirufeng"},{"title":"（算法）小和问题","slug":"算法-小和问题","date":"2020-09-23T17:14:01.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/23/算法-小和问题/","link":"","permalink":"http://www.sivan.tech/2020/09/23/%E7%AE%97%E6%B3%95-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/","excerpt":"使用归并排序来对小和问题进行求解 步骤因为归并排序已经将数组分成了两个已经有序的子数组，我们要想统计小和的个数，我们就需要在merge的过程中统计小和的个数。 假设本次要merge两个子数组为num1, num2。分别为num的左右两个子数组，其中num1的下标从0到mid,num2的下标从mid+1到right 如果每次合并的时候num2中的元素num2[j]小于num1中的元素num1[i]，此时会产生小和 对于num1中的元素num1[i]，此时比它大的有num2中的第j个元素之后的所有元素(包括num2的第j个元素)。这里我们不考虑num1中比num1[i]大的元素，因为我们在生成有序num1的时候就已经考虑过了。 所以此时num2中大于num1[i]元素个数为（r-j+1），但是要统计小和，所以我们让之前统计小和的结果加上（r-j+1）* num1[i] 不断循环，知道整个数组都已经归并完成 上面第1步是合并了num的从l到j的元素，但是我们还要不断递归 几个关键点 return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r) 这里是我们统计左边半个数组内部的小和以及右边半个数组内部的小和，以及左右两个子数组合并时候产生的小和 ret += (r-j+1) * nums[i] 因为是要求小和，所以我们统计出了比num[i]小的元素个数为(r-j+1)个，最后还是要乘以nums[i]来获取nums[i]的两个数组之间的小和","text":"使用归并排序来对小和问题进行求解 步骤因为归并排序已经将数组分成了两个已经有序的子数组，我们要想统计小和的个数，我们就需要在merge的过程中统计小和的个数。 假设本次要merge两个子数组为num1, num2。分别为num的左右两个子数组，其中num1的下标从0到mid,num2的下标从mid+1到right 如果每次合并的时候num2中的元素num2[j]小于num1中的元素num1[i]，此时会产生小和 对于num1中的元素num1[i]，此时比它大的有num2中的第j个元素之后的所有元素(包括num2的第j个元素)。这里我们不考虑num1中比num1[i]大的元素，因为我们在生成有序num1的时候就已经考虑过了。 所以此时num2中大于num1[i]元素个数为（r-j+1），但是要统计小和，所以我们让之前统计小和的结果加上（r-j+1）* num1[i] 不断循环，知道整个数组都已经归并完成 上面第1步是合并了num的从l到j的元素，但是我们还要不断递归 几个关键点 return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r) 这里是我们统计左边半个数组内部的小和以及右边半个数组内部的小和，以及左右两个子数组合并时候产生的小和 ret += (r-j+1) * nums[i] 因为是要求小和，所以我们统计出了比num[i]小的元素个数为(r-j+1)个，最后还是要乘以nums[i]来获取nums[i]的两个数组之间的小和 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package mainimport ( sorts &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/23 5:03 下午 * @Desc: 计算小和的个数 */func MergeSort(nums []int) int &#123; if nums == nil || len(nums) &lt; 2 &#123; return 0 &#125; return mergeSort(nums, 0, len(nums)-1)&#125;func mergeSort(nums []int, l, r int) int &#123; //递归结束条件 if l == r &#123; return 0 &#125; //注意这个写法：可以避免越界同时使用&gt;&gt;1加速运算 mid := l + (r-l)&gt;&gt;1 //分治 return mergeSort(nums, l, mid) + mergeSort(nums, mid+1, r) + merge(nums, l, mid, r)&#125;func merge(nums []int, l, mid, r int) int &#123; i, j := l, mid+1 //申请一个辅助数组 help := make([]int, r-l+1) index := 0 ret := 0 //谁小填谁移谁 for i &lt;= mid &amp;&amp; j &lt;= r &#123; if nums[i] &gt;= nums[j] &#123; help[index] = nums[j] j++ &#125; else &#123; //此时产生小和 //计算小和的关键一步，当前比较nums[i]与nums[j]， //此时nums[i]&lt;nums[j]比nums[i]大的有nums数组中从第j个到第r个一共r-j+1 //相当于每次都在左边那个数组中的元素：找到右边数组中有多少个元素比他大，之后乘以该元素的值。 //重复如上步骤不断累加便是我们的小和 ret += (r-j+1) * nums[i] help[index] = nums[i] i++ &#125; index++ &#125; //移动剩下的一部分 //注意下面两个是for循环，不是if //另外注意的是下面两个for循环有且只有一个可以被执行 for i &lt;= mid &#123; help[index] = nums[i] index++ i++ &#125; for j &lt;= r &#123; help[index] = nums[j] index++ j++ &#125; //此时help已经填充好我们排序后的数字了，我们需要将且拷贝到原数组的l-&gt;r for i := l; i &lt;= r; i++ &#123; nums[i] = help[i-l] &#125; return ret&#125;func main() &#123; nums := sorts.RandArrayRange(6, 0, 100) fmt.Println(nums) fmt.Println(MergeSort(nums))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"归并排序","slug":"归并排序","permalink":"http://www.sivan.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"小和问题","slug":"小和问题","permalink":"http://www.sivan.tech/tags/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/"}],"author":"yirufeng"},{"title":"归并排序","slug":"归并排序","date":"2020-09-23T16:04:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/23/归并排序/","link":"","permalink":"http://www.sivan.tech/2020/09/23/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"应用场景 求小和 求逆序对的个数 几个注意点：mid := l + (r-l)&gt;&gt;1 避免数组越界 for i &lt;= mid { help[index] = nums[i] index++ i++ }，这里是一个for循环，不是if，因为是要将后面剩下的数拷贝进来 for i &lt;= mid { help[index] = nums[i] index++ i++ }，这里是一个for循环，不是if，因为是要将后面剩下的数拷贝进来","text":"应用场景 求小和 求逆序对的个数 几个注意点：mid := l + (r-l)&gt;&gt;1 避免数组越界 for i &lt;= mid { help[index] = nums[i] index++ i++ }，这里是一个for循环，不是if，因为是要将后面剩下的数拷贝进来 for i &lt;= mid { help[index] = nums[i] index++ i++ }，这里是一个for循环，不是if，因为是要将后面剩下的数拷贝进来 具体实现思路：数组减半，两部分都有序之后进行合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061func MergeSort(nums []int) &#123; //如果输入不合法并且数组中只有1个数字直接返回 if nums == nil || len(nums) &lt; 2 &#123; return &#125; mergeSort(nums, 0, len(nums)-1)&#125;func mergeSort(nums []int, l, r int) &#123; //递归结束条件 if l == r &#123; return &#125; //注意这个写法：可以避免越界同时使用&gt;&gt;1加速运算 mid := l + (r-l)&gt;&gt;1 //分治 mergeSort(nums, l, mid) mergeSort(nums, mid+1, r) //合并两部分[l,mid] [mid+1,r] merge(nums, l, mid, r)&#125;func merge(nums []int, l, mid, r int) &#123; i, j := l, mid+1 //申请一个辅助数组 help := make([]int, r-l+1) index := 0 //谁小填谁移谁 for i &lt;= mid &amp;&amp; j &lt;= r &#123; if nums[i] &gt; nums[j] &#123; help[index] = nums[j] j++ &#125; else &#123; help[index] = nums[i] i++ &#125; index++ &#125; //移动剩下的一部分 //注意下面两个是for循环，不是if //另外注意的是下面两个for循环有且只有一个可以被执行 for i &lt;= mid &#123; help[index] = nums[i] index++ i++ &#125; for j &lt;= r &#123; help[index] = nums[j] index++ j++ &#125; //此时help已经填充好我们排序后的数字了，我们需要将且拷贝到原数组的l-&gt;r for i := l; i &lt;= r; i++ &#123; nums[i] = help[i-l] &#125;&#125; 总结归并排序涉及到了我们算法中的分治思想。 &lt;&lt;大话数据结构&gt;&gt;：不断分治，最终得到一颗完全二叉树，由完全二叉树的深度得知，整个归并排序需要进行log2N次，每次都需要扫描待排序的记录，时间复杂度为O(N)，因此总时间复杂度为O(NlogN)。归并算法前后有比较，不存在跳跃，因此归并排序是一种稳定的排序算法。归并排序是一种比较占用内存但却效率高且稳定的算法。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://www.sivan.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"ubuntu18.04 安装docker","slug":"ubuntu18.04安装docker","date":"2020-09-23T08:41:19.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/23/ubuntu18.04安装docker/","link":"","permalink":"http://www.sivan.tech/2020/09/23/ubuntu18.04%E5%AE%89%E8%A3%85docker/","excerpt":"环境本操作基于如下环境： ubuntu 18.04 使用ubuntu安装docker 卸载之前的docker sudo apt-get remove docker docker-engine docker.io containerd runc 安装Docker sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common ：安装依赖包curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - ：添加 Docker 的官方 GPG 密钥sudo apt-key fingerprint 0EBFCD88 ：验证您现在是否拥有带有指纹的密钥sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; ：设置稳定版仓库 安装 Docker Engine-Community sudo apt-get update ：更新sudo apt-get install docker-ce ：安装最新的Docker-ce启动：sudo systemctl enable docker sudo systemctl start docker 测试 sudo docker run hello-world","text":"环境本操作基于如下环境： ubuntu 18.04 使用ubuntu安装docker 卸载之前的docker sudo apt-get remove docker docker-engine docker.io containerd runc 安装Docker sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common ：安装依赖包curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - ：添加 Docker 的官方 GPG 密钥sudo apt-key fingerprint 0EBFCD88 ：验证您现在是否拥有带有指纹的密钥sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; ：设置稳定版仓库 安装 Docker Engine-Community sudo apt-get update ：更新sudo apt-get install docker-ce ：安装最新的Docker-ce启动：sudo systemctl enable docker sudo systemctl start docker 测试 sudo docker run hello-world docker安装后使用遇到的问题： docker 权限问题 Got permission denied while trying to connect to the Docker daemon socket at 。。。 解决方法：通过将当前用户添加到docker用户组可以避免之后的命令使用sudo 查看步骤 sudo groupadd docker ：添加docker用户组sudo gpasswd -a $USER docker ：将登陆用户加入到docker用户组中newgrp docker ：更新用户组","categories":[{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.sivan.tech/tags/Ubuntu/"}],"author":"yirufeng"},{"title":"docker实现mysql的主从复制","slug":"docker实现mysql的主从复制","date":"2020-09-15T19:43:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/15/docker实现mysql的主从复制/","link":"","permalink":"http://www.sivan.tech/2020/09/15/docker%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/","excerpt":"通过docker中的容器隔离机制我们实现mysql的主从复制，从而避免了单点故障 主从复制部署 docker命令参考","text":"通过docker中的容器隔离机制我们实现mysql的主从复制，从而避免了单点故障 主从复制部署 docker命令参考","categories":[{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/categories/mysql/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/tags/mysql/"},{"name":"主从复制","slug":"主从复制","permalink":"http://www.sivan.tech/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"}],"author":"yirufeng"},{"title":"go中的heap实现大根堆与小根堆","slug":"go中的heap实现堆","date":"2020-09-12T09:10:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/12/go中的heap实现堆/","link":"","permalink":"http://www.sivan.tech/2020/09/12/go%E4%B8%AD%E7%9A%84heap%E5%AE%9E%E7%8E%B0%E5%A0%86/","excerpt":"小根堆 几个注意点： 因为heap需要我们实现sort接口(3个方法，Less，Swap，以及Len)我们使用Less比较的时候决定了大根堆或小根堆 push以及pop因为涉及到切片中元素个数的改变，可能进行扩容或缩容，所以要使用指针 Push以及Pop的实现就按照对切片的处理即可 之后初始化我们的堆的时候需要先建立我们自己的堆，然后使用heap.Init()初始化 后面堆要弹出或加入元素都必须使用heap.Push()以及heap.Pop()","text":"小根堆 几个注意点： 因为heap需要我们实现sort接口(3个方法，Less，Swap，以及Len)我们使用Less比较的时候决定了大根堆或小根堆 push以及pop因为涉及到切片中元素个数的改变，可能进行扩容或缩容，所以要使用指针 Push以及Pop的实现就按照对切片的处理即可 之后初始化我们的堆的时候需要先建立我们自己的堆，然后使用heap.Init()初始化 后面堆要弹出或加入元素都必须使用heap.Push()以及heap.Pop() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;container/heap&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Date: 2021/4/13 3:23 下午 * @Desc: **/type MinHeap []intfunc (h *MinHeap) Push(val interface&#123;&#125;) &#123; *h = append(*h, val.(int))&#125;func (h *MinHeap) Pop() interface&#123;&#125; &#123; val := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return val&#125;// Less 实现sort接口的三个方法func (h MinHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j]&#125;func (h MinHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func (h MinHeap) Len() int &#123; return len(h)&#125;func main() &#123; //新建一个小顶堆 h := &amp;MinHeap&#123;&#125; //初始化我们的小顶堆 heap.Init(h) //之后我们使用Push以及Pop的时候都必须使用heap包自带的方法 heap.Push(h, 99) heap.Push(h, 123) heap.Push(h, 13) heap.Push(h, 78) heap.Push(h, 900) heap.Push(h, 1314) heap.Push(h, 213) heap.Push(h, 31) for h.Len() &gt; 0 &#123; fmt.Printf(&quot;%d &quot;, heap.Pop(h)) &#125;&#125; 大根堆 同小根堆，改变Less实现方法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;container/heap&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Date: 2021/4/13 2:45 下午 * @Desc: **/type MaxHeap []intfunc (h *MaxHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *MaxHeap) Pop() interface&#123;&#125; &#123; ret := (*h)[len(*h)-1] *h = (*h)[:len(*h)-1] return ret&#125;func (h MaxHeap) Len() int &#123; return len(h)&#125;func (h MaxHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func (h MaxHeap) Less(i, j int) bool &#123; //按照升序排列 return h[i] &gt; h[j]&#125;func main() &#123; //新建一个大顶堆 h := &amp;MaxHeap&#123;&#125; //初始化为大顶堆 heap.Init(h) //之后每次插入和删除元素的时候我们都必须使用heap.Push或者 heap.Pop方法来进行元素的插入和删除 heap.Push(h, 1) heap.Push(h, 99) heap.Push(h, 33) heap.Push(h, 12) heap.Push(h, 108) for h.Len() &gt; 0 &#123; fmt.Printf(&quot;%d &quot;, heap.Pop(h)) &#125;&#125;","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"堆","slug":"堆","permalink":"http://www.sivan.tech/tags/%E5%A0%86/"}],"author":"yirufeng"},{"title":"面试问题之Top K系列","slug":"面试问题之Top K系列","date":"2020-09-12T09:10:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/12/面试问题之Top K系列/","link":"","permalink":"http://www.sivan.tech/2020/09/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E4%B9%8BTop%20K%E7%B3%BB%E5%88%97/","excerpt":"思路整理：","text":"思路整理： 如图所示 几种方法讲解 以剑指offer40题为例，求最小的k个数字 方法一： 思路：直接用最快的排序方法排好序后取前k个或者后k个元素即可 时间复杂度：O(n * logn)空间复杂度：O(1) 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func getLeastNumbers(arr []int, k int) []int &#123; return QuickSort(arr)[:k]&#125;func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int //优化1：尾递归优化 for low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) low = pivotkey + 1 &#125;&#125;func partition(nums []int, low int, high int) int &#123; //优化2：使用随机数选择划分枢轴 //设置随机数种子 rand.Seed(time.Now().UnixNano()) //选择[0,n) //rand.Intn(n) //选择划分元素 dummyIndex := rand.Intn(high-low+1) + low //将随机选择的元素放置到low位置上，以后便于在高处找到比划分元素小的时候我们可以直接让high赋值给low swap(nums, low, dummyIndex) dummyVal := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummyVal &lt;= nums[high] &#123; high-- &#125; //优化3：我们使用替换而不是交换 //高处找到小的直接赋值给low nums[low] = nums[high] for low &lt; high &amp;&amp; dummyVal &gt;= nums[low] &#123; low++ &#125; //低处找到大的直接赋值给high nums[high] = nums[low] &#125; //最后low == high nums[low] = dummyVal return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125; 方法二： 思路：冒泡排序每次都会将1个元素放置到最终位置上，我们可以冒泡k趟 时间复杂度：O(k * n)空间复杂度：O(1) 代码 123456789101112func getLeastNumbers(arr []int, k int) []int &#123; //需要冒泡k次 for i := 1; i &lt;= k; i++ &#123; //每次从倒数第2个元素开始一直到前面的第i-1个元素，例如第1趟是到第0个(因为每次是和后面的元素进行比较) for j := len(arr) - 2; j &gt;= i-1; j-- &#123; if arr[j] &gt; arr[j+1] &#123; arr[j+1], arr[j] = arr[j], arr[j+1] &#125; &#125; &#125; return arr[:k]&#125; 方法三： 思路：构建一个容量为k的堆，不断遍历数据，插入后进行调整，最后依次返回组合成我们要的结果 适合处理海量数据 时间复杂度：O(n*logk)空间复杂度：O(K) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type IntHeap []int//Heap Interface//type Interface interface &#123;// sort.Interface// Push(x interface&#123;&#125;) // 向末尾添加元素// Pop() interface&#123;&#125; // 从末尾删除元素//&#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;// Sort Interface//type Interface interface &#123;// // Len方法返回集合中的元素个数// Len() int// // Less方法报告索引i的元素是否比索引j的元素小// Less(i, j int) bool// // Swap方法交换索引i和j的两个元素// Swap(i, j int)//&#125;func (h IntHeap) Len() int &#123; return len(h)&#125;//表明是一个小顶堆func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j]&#125;func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func getLeastNumbers(arr []int, k int) []int &#123; h := &amp;IntHeap&#123;&#125; for _, val := range arr &#123; heap.Push(h, val) &#125; ret := []int&#123;&#125; for i := 0; i &lt; k; i++ &#123; ret = append(ret, heap.Pop(h).(int)) &#125; return ret&#125; 方法四： 思路：随机选择，通过减治的思想利用快速排序中的partition方法可以对我们要求的那个划分轴进行快速选择， 算法导论中提过，我们有成熟的时间复杂度为O(n)的算法来获取任意第k大的数，也就是基于partition的随机选择方法 时间复杂度：O(N)空间复杂度：O(1) 会对传入的切片进行修改 代码 1234567891011121314151617181920212223242526272829303132333435363738394041func partition(arr []int, start int, end int) int &#123; rand.Seed(time.Now().UnixNano()) index := rand.Intn(end-start+1) + start val := arr[index] arr[index], arr[start] = arr[start], arr[index] for start &lt; end &#123; for start &lt; end &amp;&amp; val &lt;= arr[end] &#123; end-- &#125; arr[start] = arr[end] for start &lt; end &amp;&amp; val &gt;= arr[start] &#123; start++ &#125; arr[end] = arr[start] &#125; arr[start] = val return start&#125;func getLeastNumbers(arr []int, k int) []int &#123; //特殊情况 if len(arr) == 0 || k &lt;= 0 &#123; return nil &#125; else if k &gt;= len(arr) &#123; return arr &#125; index := partition(arr, 0, len(arr)-1) for index != k-1 &#123; if index &gt; k-1 &#123; //说明在左边 index = partition(arr, 0, index-1) &#125; else if index &lt; k-1 &#123; index = partition(arr, index+1, len(arr)-1) &#125; &#125; //到这里说明partition划分为index就是第k个元素，直接返回即可 return arr[:k]&#125; 方法四【最优解】：BFPRT参考 参考58沈剑讲解","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"}],"author":"yirufeng"},{"title":"Mac安装Ubuntu并且通过secureCrt连接","slug":"mac安装虚拟机并连接","date":"2020-09-11T09:08:18.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/11/mac安装虚拟机并连接/","link":"","permalink":"http://www.sivan.tech/2020/09/11/mac%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E8%BF%9E%E6%8E%A5/","excerpt":"最近准备复习操作系统的知识并通过linux实践，索性就安装了一个ubuntu虚拟机吧以下将parallels Desktop简称为PD 准备工作 离线下载好的ubuntu对应版本的iso镜像 secureCrt工具 PD软件 步骤 通过PD安装下载好的ubuntu对应版本的iso镜像 安装之后ubuntu虚拟机已经帮助我们启动了，但是我们通过ifconfig查看ip之后，通过secureCrt连不上对应的ip。 解决方案：在Ubuntu终端中输入sshd，验证是否已安装该包。若未安装则通过sudo apt-get install openssh-server 之后便可以发现通过ip地址和密码在secureCrt上进行登录 参考 参考文章","text":"最近准备复习操作系统的知识并通过linux实践，索性就安装了一个ubuntu虚拟机吧以下将parallels Desktop简称为PD 准备工作 离线下载好的ubuntu对应版本的iso镜像 secureCrt工具 PD软件 步骤 通过PD安装下载好的ubuntu对应版本的iso镜像 安装之后ubuntu虚拟机已经帮助我们启动了，但是我们通过ifconfig查看ip之后，通过secureCrt连不上对应的ip。 解决方案：在Ubuntu终端中输入sshd，验证是否已安装该包。若未安装则通过sudo apt-get install openssh-server 之后便可以发现通过ip地址和密码在secureCrt上进行登录 参考 参考文章","categories":[{"name":"工具篇","slug":"工具篇","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/tags/%E5%B7%A5%E5%85%B7/"},{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/tags/tools/"}],"author":"yirufeng"},{"title":"冒泡排序以及优化","slug":"冒泡排序以及优化","date":"2020-09-10T21:10:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/10/冒泡排序以及优化/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"冒泡排序思路：从左向右每次两两比较相邻元素，如果前一个元素大于后一个元素，那么就交换这两个元素，一趟下来肯定有一个元素放到了最后的位置 12345678910111213141516func BubbleSort(nums []int) []int &#123; bubbleSort(nums) return nums&#125;func bubbleSort(nums []int) &#123; //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1; i++ &#123; for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125;","text":"冒泡排序思路：从左向右每次两两比较相邻元素，如果前一个元素大于后一个元素，那么就交换这两个元素，一趟下来肯定有一个元素放到了最后的位置 12345678910111213141516func BubbleSort(nums []int) []int &#123; bubbleSort(nums) return nums&#125;func bubbleSort(nums []int) &#123; //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1; i++ &#123; for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] &#125; &#125; &#125;&#125; 优化版本的冒泡排序思路：前面的冒泡排序在数组已经有序的时候还仍然会比较，因此我们可以通过设置一个flag，如果某一轮没有交换操作，说明当前已经有序，后面的不需要继续比较和判断了 123456789101112131415161718192021//改进版的冒泡排序：一旦某一趟不交换后面就直接退出func BubbleSortV2(nums []int) []int &#123; bubbleSortV2(nums) return nums&#125;func bubbleSortV2(nums []int) &#123; flag := true //从前往后进行交换，每次都会固定好后面的元素 for i := 0; i &lt; len(nums)-1 &amp;&amp; flag; i++ &#123; flag = false for j := 0; j &lt; len(nums)-1-i; j++ &#123; //两两比较并交换 if nums[j] &gt; nums[j+1] &#123; nums[j], nums[j+1] = nums[j+1], nums[j] flag = true &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.sivan.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"选择排序","slug":"选择排序","date":"2020-09-10T20:55:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/10/选择排序/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"选择排序思路：每次选择一个当前未排序的最小元素放到当前未排序的第一个位置上 1234567891011121314151617181920212223func SelectSort(nums []int) []int &#123; selectSort(nums) return nums&#125;func selectSort(nums []int) &#123; //存储最小元素对应的下标 var min int //进行多少趟 for i := 0; i &lt; len(nums)-1; i++ &#123; min = i //每趟从哪里开始 j := i + 1 for ; j &lt; len(nums)-1; j++ &#123; if nums[min] &gt; nums[j] &#123; min = j &#125; &#125; if min != i &#123; nums[i], nums[min] = nums[min], nums[i] &#125; &#125;&#125;","text":"选择排序思路：每次选择一个当前未排序的最小元素放到当前未排序的第一个位置上 1234567891011121314151617181920212223func SelectSort(nums []int) []int &#123; selectSort(nums) return nums&#125;func selectSort(nums []int) &#123; //存储最小元素对应的下标 var min int //进行多少趟 for i := 0; i &lt; len(nums)-1; i++ &#123; min = i //每趟从哪里开始 j := i + 1 for ; j &lt; len(nums)-1; j++ &#123; if nums[min] &gt; nums[j] &#123; min = j &#125; &#125; if min != i &#123; nums[i], nums[min] = nums[min], nums[i] &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://www.sivan.tech/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"直接插入排序以及优化","slug":"直接插入排序以及优化","date":"2020-09-10T09:20:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/10/直接插入排序以及优化/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"直接插入排序直接插入排序是简单排序中性能最好的 平均时间复杂度：O(n^n / 4)最好时间复杂度：O(n)最坏时间复杂度：O(n^n) 直接插入排序版本1思路：将每次要插入的当前元素依次与左边元素比较，如果左边元素大于当前元素则交换，直到左边元素小于等于当前元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSort(nums []int) []int &#123; insertSort(nums) return nums&#125;//思路：如果当前元素比前一个元素小就交换，一直到当前元素大于等于前一个元素func insertSort(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for j := i; j &gt;= 1 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123; nums[j], nums[j-1] = nums[j-1], nums[j] &#125; &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSort(nums))&#125;","text":"直接插入排序直接插入排序是简单排序中性能最好的 平均时间复杂度：O(n^n / 4)最好时间复杂度：O(n)最坏时间复杂度：O(n^n) 直接插入排序版本1思路：将每次要插入的当前元素依次与左边元素比较，如果左边元素大于当前元素则交换，直到左边元素小于等于当前元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSort(nums []int) []int &#123; insertSort(nums) return nums&#125;//思路：如果当前元素比前一个元素小就交换，一直到当前元素大于等于前一个元素func insertSort(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for j := i; j &gt;= 1 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123; nums[j], nums[j-1] = nums[j-1], nums[j] &#125; &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSort(nums))&#125; 直接插入排序版本2 摘自&lt;&lt;大话数据结构&gt;&gt; 思路：将前面比要插入元素大的元素挪到后面，找到插入位置之后将要插入元素插入即可，最后找到的插入位置一定是j+1而不是j因为我们判断了nums[j]小于等于我们要插入的元素 注意：此时要记得将temp放置到正确位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( &quot;log&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 9:12 上午 * @Desc: 直接插入排序 */func InsertSortV2(nums []int) []int &#123; insertSortV2(nums) return nums&#125;//大话数据结构书上的直接插入排序func insertSortV2(nums []int) &#123; //默认下标为0的已经有序，因此从下标为1的开始插入 for i := 1; i &lt; len(nums); i++ &#123; //插入条件：要排序的元素一定要小于前面的元素 if nums[i] &lt; nums[i-1] &#123; temp := nums[i] j := i-1 //什么时候结束插入：当要插入的元素的值大于等于前面的那个元素就停止插入 for ; j &gt;= 0 &amp;&amp; nums[j] &gt; temp ; j-- &#123; nums[j+1] = nums[j] &#125; //此时要记得将temp放置到正确位置 nums[j+1] = temp &#125; &#125;&#125;//写一个随机数生成器func RandArray(length int) []int &#123; nums := []int&#123;&#125; for i := 0; i &lt; length; i++ &#123; r := rand.New(rand.NewSource(time.Now().UnixNano())) nums = append(nums, r.Intn(100)) &#125; return nums&#125;func main() &#123; //设置随机数种子 rand.Seed(time.Now().UnixNano()) nums := RandArray(30) log.Println(nums) log.Println(InsertSortV2(nums))&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"直接插入排序","slug":"直接插入排序","permalink":"http://www.sivan.tech/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"快速排序以及优化","slug":"快速排序以及优化","date":"2020-09-10T08:55:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/10/快速排序以及优化/","link":"","permalink":"http://www.sivan.tech/2020/09/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","excerpt":"经典快速排序思路：选取数组中的第1个元素作为划分元素，划分为两部分，左边一部分比该元素小，右边一部分比该元素大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package quickSortV1import ( &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 7:45 上午 * @Desc: *//*快速排序第1个版本：选择第1个元素作为划分枢轴注意：切片作为参数传递的时候是一个引用*/func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int if low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) quickSort(nums, pivotkey+1, high) &#125;&#125;func partition(nums []int, low int, high int) int &#123; //选择划分元素 dummy := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummy &lt;= nums[high] &#123; high-- &#125; swap(nums, low, high) for low &lt; high &amp;&amp; dummy &gt; nums[low] &#123; low++ &#125; swap(nums, low, high) &#125; //最后low == high return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;//------------------------------for test------------------------------func main() &#123; fmt.Println(QuickSort(sort.RandArray(100)))&#125; 经典快速排序的不足虽然经典快速排序性能相对其他排序性能较高，但仍然有一定的瓶颈，例如如果是一个有序的数组。 此外快速排序可以从以下几点进行改进： 优化选取枢轴的策略 随机从low到high中选择一个下标对应的元素作为枢轴 (三数取中)从left, high 以及mid对应的下标的元素中的三个选择一个大小居中的元素 (九数取中) 优化不必要的交换：采用置换而不是交换。我们可以提前存储nums[low],之后每次在右边找到小的元素就将其赋值给nums[low]，每次在左边找到大的元素可以直接赋值给nums[high] 优化小数组的排序方案：虽然快速排序可以有很好的性能，但是在数组较小时，直接插入排序效率比快速排序效率高(直接插入排序是简单排序中性能最好的) 对快排进行尾递归优化：如果传入一个大量数据且有序的数组，快排会不断的递归，栈的深度也会越来越深，因此很容易在数据量大且数据有序的时候造成栈溢出(申请不到更多的栈空间)","text":"经典快速排序思路：选取数组中的第1个元素作为划分元素，划分为两部分，左边一部分比该元素小，右边一部分比该元素大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package quickSortV1import ( &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 7:45 上午 * @Desc: *//*快速排序第1个版本：选择第1个元素作为划分枢轴注意：切片作为参数传递的时候是一个引用*/func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int if low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) quickSort(nums, pivotkey+1, high) &#125;&#125;func partition(nums []int, low int, high int) int &#123; //选择划分元素 dummy := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummy &lt;= nums[high] &#123; high-- &#125; swap(nums, low, high) for low &lt; high &amp;&amp; dummy &gt; nums[low] &#123; low++ &#125; swap(nums, low, high) &#125; //最后low == high return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;//------------------------------for test------------------------------func main() &#123; fmt.Println(QuickSort(sort.RandArray(100)))&#125; 经典快速排序的不足虽然经典快速排序性能相对其他排序性能较高，但仍然有一定的瓶颈，例如如果是一个有序的数组。 此外快速排序可以从以下几点进行改进： 优化选取枢轴的策略 随机从low到high中选择一个下标对应的元素作为枢轴 (三数取中)从left, high 以及mid对应的下标的元素中的三个选择一个大小居中的元素 (九数取中) 优化不必要的交换：采用置换而不是交换。我们可以提前存储nums[low],之后每次在右边找到小的元素就将其赋值给nums[low]，每次在左边找到大的元素可以直接赋值给nums[high] 优化小数组的排序方案：虽然快速排序可以有很好的性能，但是在数组较小时，直接插入排序效率比快速排序效率高(直接插入排序是简单排序中性能最好的) 对快排进行尾递归优化：如果传入一个大量数据且有序的数组，快排会不断的递归，栈的深度也会越来越深，因此很容易在数据量大且数据有序的时候造成栈溢出(申请不到更多的栈空间) 优化方案1：随机选取一个元素作为枢轴1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package quickSortV2import ( &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 8:06 上午 * @Desc: 随机选取一个元素作为枢轴 */func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int if low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) quickSort(nums, pivotkey+1, high) &#125;&#125;func partition(nums []int, low int, high int) int &#123; //设置随机数种子 rand.Seed(time.Now().UnixNano()) //选择[0,n) //rand.Intn(n) //选择划分元素 dummyIndex := rand.Intn(high-low+1) + low swap(nums, low, dummyIndex) temp := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; temp &lt;= nums[high] &#123; high-- &#125; swap(nums, low, high) for low &lt; high &amp;&amp; temp &gt;= nums[low] &#123; low++ &#125; swap(nums, low, high) &#125; //最后low == high return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;func main() &#123; fmt.Println(sort.RandArray(5)) fmt.Println(QuickSort(sort.RandArray(100))) fmt.Println(QuickSort(sort.RandArray(5)))&#125; 优化方案2：进行元素替换来避免不必要的元素交换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package quickSortV3import ( &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 8:06 上午 * @Desc: 元素进行置换而不是交换，从而优化不必要的交换 每次右边有小的时将该元素放置到low位置上，因为之前low位置我们就已经使用另外一个变量保存了 每次左边有大的元素的时候直接将该元素放置到high位置上，因为此时high位置上的元素已经被放置到了low左边的元素了*/func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int if low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) quickSort(nums, pivotkey+1, high) &#125;&#125;func partition(nums []int, low int, high int) int &#123; //选择划分元素 //关键点1 dummy := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummy &lt;= nums[high] &#123; high-- &#125; //第一次遍历到这里的时候由于我们提前存了low位置的元素，所以我们可以直接将high位置的值替换过来 //关键点2 nums[low] = nums[high] for low &lt; high &amp;&amp; dummy &gt;= nums[low] &#123; low++ &#125; //关键点3 nums[high] = nums[low] &#125; //最后low == high，但此时需要将我们之前存的dummy替换到这个位置，这样数组才可以复原 //关键点4，最后记得还原 nums[low] = dummy return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;func main() &#123; fmt.Println(QuickSort(sort.RandArray(30)))&#125; 优化方案3：根据数组的大小选择最优的排序方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( &quot;InterviewQuestions/Algo/sort&quot; insertSort &quot;InterviewQuestions/templates/InsertSort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 8:06 上午 * @Desc: 根据数组的大小优化排序方案， 因为直接插入排序是简单选择排序中性能最好的排序，所以当数据长度小于一个固定值我们使用直接插入排序， *///设置元素个数到达多少的时候开始快速排序const ( lengthQuickSort = 100)func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; if len(nums) &lt;= lengthQuickSort &#123; insertSort.InsertSortV2(nums) &#125; else &#123; var pivotkey int if low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) quickSort(nums, pivotkey+1, high) &#125; &#125;&#125;func partition(nums []int, low int, high int) int &#123; dummy := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummy &lt;= nums[high] &#123; high-- &#125; swap(nums, low, high) for low &lt; high &amp;&amp; dummy &gt;= nums[low] &#123; low++ &#125; swap(nums, low, high) &#125; //最后low == high return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;func main() &#123; for i := 0; i &lt; 100; i++ &#123; &#125; fmt.Println(QuickSort(sort.RandArray(20))) fmt.Println(QuickSort(sort.RandArray(200)))&#125; 优化方案4：进行尾递归优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package quickSortV5import ( &quot;InterviewQuestions/Algo/sort&quot; &quot;fmt&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 8:06 上午 * @Desc: 尾递归进行优化 */func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; var pivotkey int // 尾递归优化关键点1： for low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) //尾递归优化关键点2： low = pivotkey + 1 &#125;&#125;func partition(nums []int, low int, high int) int &#123; //选择划分元素 dummy := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummy &lt;= nums[high] &#123; high-- &#125; swap(nums, low, high) for low &lt; high &amp;&amp; dummy &gt; nums[low] &#123; low++ &#125; swap(nums, low, high) &#125; //最后low == high return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;func main() &#123; fmt.Println(QuickSort([]int&#123;4, 3, 2, 1&#125;)) fmt.Println(QuickSort(sort.RandArray(100)))&#125; 优化方案5：最终优化的快排集成以下优化： 随机选择划分元素 尾递归优化 根据数组大小自动选择直接插入排序或快速排序 对快速排序中的元素进行替换而不是交换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package quickSortV6//package mainimport ( &quot;InterviewQuestions/Algo/sort&quot; insertSort &quot;InterviewQuestions/templates/InsertSort&quot; &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)/** * @Author: yirufeng * @Email: yirufeng@foxmail.com * @Date: 2020/9/10 8:06 上午 * @Desc: 快速排序的终极版本 随机选择划分元素 + 尾递归优化 + 根据自己定义的大小自动选择插入排序或(使用替换而不是交换的带尾递归优化的随机快速排序)*///优化4：设置一个边界用来标志什么时候使用快速排序什么时候使用直接插入排序//设置元素个数到达多少的时候开始快速排序const ( lengthQuickSort = 100)func QuickSort(nums []int) []int &#123; quickSort(nums, 0, len(nums)-1) return nums&#125;func quickSort(nums []int, low int, high int) &#123; if len(nums) &lt;= lengthQuickSort &#123; insertSort.InsertSortV2(nums) &#125; else &#123; var pivotkey int //优化1：尾递归优化 for low &lt; high &#123; //pivotkey 为枢轴防止的最终下标 pivotkey = partition(nums, low, high) quickSort(nums, low, pivotkey-1) low = pivotkey + 1 &#125; &#125;&#125;func partition(nums []int, low int, high int) int &#123; //优化2：使用随机数选择划分枢轴 //设置随机数种子 rand.Seed(time.Now().UnixNano()) //选择[0,n) //rand.Intn(n) //选择划分元素 dummyIndex := rand.Intn(high-low+1) + low //将随机选择的元素放置到low位置上，以后便于在高处找到比划分元素小的时候我们可以直接让high赋值给low swap(nums, low, dummyIndex) dummyVal := nums[low] for low &lt; high &#123; for low &lt; high &amp;&amp; dummyVal &lt;= nums[high] &#123; high-- &#125; //优化3：我们使用替换而不是交换 //高处找到小的直接赋值给low nums[low] = nums[high] for low &lt; high &amp;&amp; dummyVal &gt;= nums[low] &#123; low++ &#125; //低处找到大的直接赋值给high nums[high] = nums[low] &#125; //最后low == high nums[low] = dummyVal return low&#125;func swap(nums []int, i int, j int) &#123; nums[i], nums[j] = nums[j], nums[i]&#125;func main() &#123; fmt.Println(QuickSort([]int&#123;4, 3, 2, 1&#125;)) fmt.Println(QuickSort(sort.RandArray(20))) fmt.Println(QuickSort(sort.RandArray(200)))&#125; 【左神代码优化】优化方案6：每次选中划分元素后，划分成小于区域，等于区域，大于区域思路：每次选择最后一个元素作为元素之后，使用该元素划分为3个区域：小于该元素的区域，等于该元素的区域，大于该元素的区域。之后我们只需要不断在小于与大于该元素的区域循环该过程即可。 经典快排每次只搞定一个元素，但是采用了类似于荷兰国旗问题加速之后，我们就每次搞定了等于该元素值的所有元素 荷兰国旗问题：最终将数组划分为三部分，小于该元素的区域，等于该元素的区域，大于该元素的区域。 步骤： 如果当前遍历到的元素大于目标元素，就交换到大于区域 如果当前遍历到的元素小于目标元素，就交换到小于区域 如果当前遍历到的元素等于目标元素，当前索引向右移动 经典快排1234567891011121314151617181920212223242526272829303132333435363738func QuickSort(nums []int) &#123; quickSort(nums, 0, len(nums)-1)&#125;func quickSort(nums []int, l, r int) &#123; if l &lt; r &#123; //如果这里加上一步：将随机选中的一个元素与最后一个元素交换就是我们的随机快排 l1, r1 := partition(nums, l, r) quickSort(nums, l, l1-1) quickSort(nums, r1+1, len(nums)-1) &#125;&#125;//使用nums[R]作为划分func partition(nums []int, L, R int) (int, int) &#123; //最开始没有小于等于范围没有数字， lessIndex := L - 1 largerIndex := R num := nums[R] cur := L for cur &lt; largerIndex &#123; if nums[cur] &lt; num &#123; nums[lessIndex+1], nums[cur] = nums[cur], nums[lessIndex+1] lessIndex++ cur++ &#125; else if nums[cur] &gt; num &#123; nums[largerIndex-1], nums[cur] = nums[cur], nums[largerIndex-1] largerIndex-- &#125; else if nums[cur] == num &#123; cur++ &#125; &#125; //因为我们最后一个是没有排序的，所以大于的索引位置处与最后一个位置的元素交换即可 nums[largerIndex], nums[R] = nums[R], nums[largerIndex] return lessIndex + 1, largerIndex - 1&#125; 随机快排只是比经典快排多了一行代码：index := rand.Intn(r-l+1) + l进行元素的随机选取 1234567891011121314151617181920212223242526272829303132333435363738func QuickSort(nums []int) &#123; quickSort(nums, 0, len(nums)-1)&#125;func quickSort(nums []int, l, r int) &#123; if l &lt; r &#123; //如果这里加上一步：将随机选中的一个元素与最后一个元素交换就是我们的随机快排 index := rand.Intn(r-l+1) + l nums[index], nums[r] = nums[r], nums[index] l1, r1 := partition(nums, l, r) quickSort(nums, l, l1-1) quickSort(nums, r1+1, len(nums)-1) &#125;&#125;//使用nums[R]作为划分func partition(nums []int, L, R int) (int, int) &#123; //最开始没有小于等于范围没有数字， lessIndex := L - 1 largerIndex := R num := nums[R] cur := L for cur &lt; largerIndex &#123; if nums[cur] &lt; num &#123; nums[lessIndex+1], nums[cur] = nums[cur], nums[lessIndex+1] lessIndex++ cur++ &#125; else if nums[cur] &gt; num &#123; nums[largerIndex-1], nums[cur] = nums[cur], nums[largerIndex-1] largerIndex-- &#125; else if nums[cur] == num &#123; cur++ &#125; &#125; //因为我们最后一个是没有排序的，所以大于的索引位置处与最后一个位置的元素交换即可 nums[largerIndex], nums[R] = nums[R], nums[largerIndex] return lessIndex + 1, largerIndex - 1&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://www.sivan.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"author":"yirufeng"},{"title":"内存泄漏与内存溢出","slug":"内存泄漏与内存溢出","date":"2020-09-08T08:55:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/08/内存泄漏与内存溢出/","link":"","permalink":"http://www.sivan.tech/2020/09/08/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/","excerpt":"","text":"内存泄漏与内存溢出：","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"面试/OS","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/OS/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/tags/OS/"}],"author":"yirufeng"},{"title":"-----拓展","slug":"求职","date":"2020-09-07T19:20:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/07/求职/","link":"","permalink":"http://www.sivan.tech/2020/09/07/%E6%B1%82%E8%81%8C/","excerpt":"","text":"","categories":[{"name":"岗位","slug":"岗位","permalink":"http://www.sivan.tech/categories/%E5%B2%97%E4%BD%8D/"}],"tags":[{"name":"岗位","slug":"岗位","permalink":"http://www.sivan.tech/tags/%E5%B2%97%E4%BD%8D/"}],"author":"yirufeng"},{"title":"golang刷回溯遇到的坑","slug":"golang刷回溯遇到的坑","date":"2020-09-06T18:55:42.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/06/golang刷回溯遇到的坑/","link":"","permalink":"http://www.sivan.tech/2020/09/06/golang%E5%88%B7%E5%9B%9E%E6%BA%AF%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","excerpt":"","text":"情况说明今天在做LeetCode-46题，DFS深搜写完，最后结果愣是不对，中途调试发现每次满足结束递归条件时得到的结果都是对的，但是后面一有满足条件就会造成最终的结果不对。 下面是46题的错误代码，中途调试打印cur可以正确打印，但是打印ret每次都会改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func permute(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; used, cur, res := make([]bool, len(nums)), []int&#123;&#125;, [][]int&#123;&#125; generatePermutation(&amp;nums, &amp;res, &amp;used, cur) return res&#125;func generatePermutation(nums *[]int, res *[][]int, used *[]bool, cur []int) &#123; if len(*nums) == len(cur) &#123; //just for test fmt.Printf(&quot;添加元素------&gt;&quot;) for _, val := range cur &#123; fmt.Printf(&quot;%v\\t&quot;, val) &#125; fmt.Println(cur) temp := make([]int, len(*nums)) copy(temp, cur) *res = append(*res, temp) //fmt.Println(res) &#125; //添加正确之后的对比 //if len(*nums) == len(cur) &#123; // ans := make([]int, len(cur)) // copy(ans, cur) // *res = append(*res, ans) // return //&#125; for i := 0; i &lt; len(*nums); i++ &#123; //如果当前值没有使用 if !(*used)[i] &#123; (*used)[i] = true cur = append(cur, (*nums)[i]) //进行递归 generatePermutation(nums, res, used, cur) //到这里说明之前的已经遍历完了 (*used)[i] = false cur = cur[:len(cur)-1] &#125; &#125;&#125; 原因：golang中二维切片中，第1个维度都是直接引用你加入结果时的那个切片(回溯中大多都是满足结束条件我们就加入，因此长度都一致的)，因此一旦这个切片后面修改，这个引用的结果也会改变，从而造成中间结果正确，最终结果错误。 修改以后遇到能够正确输出的情况一定要先将结果copy出来放入最终我们要的结果列表中 正确代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func permute(nums []int) [][]int &#123; if len(nums) == 0 &#123; return nil &#125; used, cur, res := make([]bool, len(nums)), []int&#123;&#125;, [][]int&#123;&#125; generatePermutation(&amp;nums, &amp;res, &amp;used, cur) return res&#125;func generatePermutation(nums *[]int, res *[][]int, used *[]bool, cur []int) &#123; //just for test //if len(*nums) == len(cur) &#123; // fmt.Printf(&quot;添加元素------&gt;&quot;) // for _, val := range cur &#123; // fmt.Printf(&quot;%v\\t&quot;, val) // &#125; // fmt.Println(cur) // temp := make([]int, len(*nums)) // copy(temp, cur) // *res = append(*res, temp) // //fmt.Println(res) //&#125; //添加正确之后的对比 if len(*nums) == len(cur) &#123; temp := make([]int, len(cur)) copy(temp, cur) *res = append(*res, temp) return &#125; for i := 0; i &lt; len(*nums); i++ &#123; //如果当前值没有使用 if !(*used)[i] &#123; (*used)[i] = true cur = append(cur, (*nums)[i]) //进行递归 generatePermutation(nums, res, used, cur) //到这里说明之前的已经遍历完了 (*used)[i] = false cur = cur[:len(cur)-1] &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"回溯","slug":"LeetCode/回溯","permalink":"http://www.sivan.tech/categories/LeetCode/%E5%9B%9E%E6%BA%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"}],"author":"yirufeng"},{"title":"前缀树","slug":"前缀树","date":"2020-09-04T18:48:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/04/前缀树/","link":"","permalink":"http://www.sivan.tech/2020/09/04/%E5%89%8D%E7%BC%80%E6%A0%91/","excerpt":"","text":"前缀树的结构： 结点的话本身不存储任何单词，它只存它要去到下一个路径上面这个路径代表的字符。 基本性质 结点本身不存储完整的单词。 从根节点到某一结点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点路径代表的字符都不相同。 走过的边就形成了单词 前缀树中的单词可以存储额外的信息，例如频次，后续的话我们就可以给用户做相应的推荐， 因为每个节点后面都有26个可能的字母出现，因此最多有26个分支 空间相对消耗比较大，但是查询的次数就是单词的长度 核心思想：空间换时间，同时可以利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 前缀树的实现：假设只有26个英文字母忽略其他的字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263type Trie struct &#123; endOfWord bool children [26]*Trie&#125;/** Initialize your data structure here. */func Constructor() Trie &#123; return Trie&#123;&#125; //这里系统会帮助我们提前创建好endOfWord以及children&#125;/** Inserts a word into the trie. */func (this *Trie) Insert(word string) &#123; cur := this for _, val := range word &#123; if cur.children[val-&#x27;a&#x27;] != nil &#123; cur = cur.children[val-&#x27;a&#x27;] &#125; else &#123; cur.children[val-&#x27;a&#x27;] = &amp;Trie&#123;&#125; cur = cur.children[val-&#x27;a&#x27;] &#125; &#125; cur.endOfWord = true&#125;/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool &#123; cur := this for _, val := range word &#123; if cur.children[val-&#x27;a&#x27;] != nil &#123; cur = cur.children[val-&#x27;a&#x27;] &#125; else &#123; return false &#125; &#125; return cur.endOfWord&#125;/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool &#123; cur := this for _, val := range prefix &#123; if cur.children[val-&#x27;a&#x27;] != nil &#123; cur = cur.children[val-&#x27;a&#x27;] &#125; else &#123; return false &#125; &#125; return true&#125;/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */","categories":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前缀树","slug":"前缀树","permalink":"http://www.sivan.tech/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"}],"author":"yirufeng"},{"title":"单工通信，半双工通信，双工通信","slug":"单工双工半双工","date":"2020-09-04T18:48:00.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/04/单工双工半双工/","link":"","permalink":"http://www.sivan.tech/2020/09/04/%E5%8D%95%E5%B7%A5%E5%8F%8C%E5%B7%A5%E5%8D%8A%E5%8F%8C%E5%B7%A5/","excerpt":"","text":"1. 单工通信（simplex）只有一个信道不可改变方向 单工通信只支持信号在一个方向上传输（正向或反向），任何时候不能改变信号的传输方向。为保证正确传送数据信号，接收端要对接收的数据进行校验，若校验出错，则通过监控信道发送请求重发的信号。 应用：此种方式适用于数据收集系统，如气象数据的收集、电话费的集中计算等。例如计算机和打印机之间的通信是单工模式，因为只有计算机向打印机传输数据，而没有相反方向的数据传输。还有在某些通信信道中，如单工无线发送等。 2. 半双工通信（half-duplex）有一个信道可以改变方向，同一时刻只允许信号在一个信道上单向传输 半双工通信允许信号在两个方向上传输，但某一时刻只允许信号在一个信道上单向传输。因此，半双工通信实际上是一种可切换方向的单工通信。 应用：此种方式适用于问讯、检索、科学计算等数据通信系统； 传统的对讲机使用的就是半双工通信方式。由于对讲机传送及接收使用相同的频率，不允许同时进行。因此一方讲完后，需设法告知另一方讲话结束（例如讲完后加上’OVER’），另一方才知道可以开始讲话。 3. 全双工（full-duplex）双通道，双向，也就是两个不同方向的单工 全双工通信允许数据同时在两个方向上传输，即有两个信道，因此允许同时进行双向传输。 全双工通信是两个单工通信方式的结合，要求收发双方都有独立的接收和发送能力。全双工通信效率高，控制简单，但造价高。 应用场景：计算机之间的通信是全双工方式。一般的电话、手机也是全双工的系统,因为在讲话时可以听到对方的声音。","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"面试/计算机网络","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.sivan.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"yirufeng"},{"title":"描述输入url到页面呈现的整个过程","slug":"输入url到页面展示发生了什么","date":"2020-09-04T18:48:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/04/输入url到页面展示发生了什么/","link":"","permalink":"http://www.sivan.tech/2020/09/04/%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"大致过程客户端获取URL - &gt; DNS解析 - &gt; TCP连接 - &gt;发送HTTP请求 - &gt;服务器处理请求 - &gt;返回报文 - &gt;浏览器解析渲染页面 - &gt; TCP断开连接 详细文字讲解客户端： （应用层开始）获取URL，通过负责域名解析的DNS服务获取网址的IP地址，根据HTT协议生成HTTP请求报文（应用层结束） （传输层开始）根据TCP协议连接从客户端到服务端（通过三次握手）客户端给服务端发送一个带SYN（同步）标志的数据包给客户端，然后客户端接收到信息再给客户端回传一个带有SYN / ACK（确认）标志的数据包以示传达确认信息，客户求最后端的再传送一个带ACK标志的数据包，代表“握手”结束，连接成功.TCP协议在把请求报文按序号分割成多个报文段（传输层结束） （网络层开始）根据IP协议（传输数据），ARP协议（获取MAC地址），OSPF协议（选择最优路径），搜索服务器地址，一边中转一边传输数据（网络层结束） （数据链路层开始）到达后通过数据链路层，物理层负责0,1比特流与物理设备电压高低，光的闪灭之间的互换。数据链路层负责将0,1序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过MAC来唯一标识的（MAC，物理地址，一个中主机会有一个MAC地址）。 （数据链路层结束） 服务端：通过数据链路层 - &gt;通过网络层 - &gt;再通过传输层（根据TCP协议接收请求报文并重组报文段） - &gt;再通过应用层（通过HTTP协议对请求的内容进行处理） - &gt;再通过应用层 - &gt;传输层 - &gt;网络层 - &gt;数据链路层 - &gt;到达客户端 客户端：通过数据链路层 - &gt;网络层 - &gt;传输层（根据TCP协议接收响应报文并重组） - &gt;应用层（HTTP协议对响应进行处理） - &gt;浏览器渲染页面 - &gt;断开连接协议四次挥手） 四次挥手 主动方发送标志位：（ACK + FIN）+（发送序号= 200 +确认序号= 500）第一次挥手 被动方接收后发送标志位：ACK +（发送序号=主动方确认序号500 +确认序号=主动方发送序号+1201）第二次挥手 标志位：（ACK + FIN）+（发送序号=主动方确认序号+1 501）第三次挥手 主动方接收后发送标志位：（ACK）+（发送序号=被动方的确认序号201 +确认序号=被动方的发生序号+1502） 参考图解考拉前端大神解答参考2参考3","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"面试/计算机网络","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.sivan.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"yirufeng"},{"title":"https面试题","slug":"https","date":"2020-09-03T18:23:42.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/09/03/https/","link":"","permalink":"http://www.sivan.tech/2020/09/03/https/","excerpt":"","text":"https中ssl的握手过程，为什么不一致用非对称加密？https中ssl的握手过程为什么不一直用非对称加密？ 使用非对称密钥用于传入对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率 非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。 非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘钥必须使用非对称加密算法 涉及到的知识点：对称密钥加密：加密和解密使用同一密钥 非对称密钥加密：有一个私有密钥和公有密钥，有两个作用：加密和签名 1. 加密：发送方使用公有密钥将消息进行加密，之后发送给接收方，接收方使用私有密钥进行解密 2. 签名：因为私有密钥无法被其他人获取，通信发送方使用私有密钥进行签名，之后发送给接收方，接收方使用公有密钥解密验证签名是否正确。 对称密钥加密：运算效率高，但是不安全 非对称密钥：可以安全的传输对称密钥，但是运算效率低 Https采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后用对称密钥加密进行通信保证通信过程的效率","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"面试/计算机网络","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.sivan.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"yirufeng"},{"title":"并发，并行，异步，同步，长连接，短连接，阻塞，非阻塞","slug":"并发，并行，异步，同步，长连接，短连接，阻塞，非阻塞","date":"2020-09-02T19:23:42.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/09/02/并发，并行，异步，同步，长连接，短连接，阻塞，非阻塞/","link":"","permalink":"http://www.sivan.tech/2020/09/02/%E5%B9%B6%E5%8F%91%EF%BC%8C%E5%B9%B6%E8%A1%8C%EF%BC%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/","excerpt":"","text":"同步和异步区别同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。 阻塞和非阻塞阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。 非阻塞请求，A调用B，A不用一直等着B的返回，先去忙别的事情了。 区别阻塞和非阻最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。 长连接和短连接长连接过程：建立连接——数据传输…（保持连接）…数据传输——关闭连接 传送消息之前建立连接后将不会再关闭。 好处：频繁发送消息可以节省大量的建立连接的成本缺点：服务器可以接收的连接数量有限，当超过一定数量，服务端会崩溃 短连接过程：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接 每次发送消息之前建立连接，发送消息之后关闭连接 好处：存在的连接都是有效的连接，及时关闭连接缺点：如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽 参考参考文章","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/tags/OS/"}],"author":"yirufeng"},{"title":"老男孩git实战视频笔记","slug":"老男孩git实战笔记","date":"2020-06-10T10:43:59.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/06/10/老男孩git实战笔记/","link":"","permalink":"http://www.sivan.tech/2020/06/10/%E8%80%81%E7%94%B7%E5%AD%A9git%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本笔记来自视频观看后的总结 老师自己总结全文参考 git使用参考网站 廖雪峰git教程 本课参考自己下载的对应视频教材的 git实战课堂笔记 01 git 是什么git 是什么 分布式 版本控制 软件 版本管理发展的历史： 多文件管理，只是不同的文件命名，电脑上有多个文件 本地版本管理系统：电脑上只显示一个文件，会将其他版本下的文件隐藏起来， 集中式版本控制： 类似于百度网盘，将所有的版本都存在中央服务器，最有代表性的软件就是SVN。 缺点：如果计算机连不上中央服务器，或者服务器挂掉，那么将会文件同步不到服务器上。 分布式版本控制： 对于集中式的版本而言，所有的版本信息都存在服务器上，而每个具体的计算机都只有一个版本，或者一个文件，而没有历史版本。而对于分布式，每个计算机都存在着所有版本信息，因此中心服务器挂掉之后，不会影响每个计算机存在的各自的版本，我们之后推上去到中心服务器即可。 注意：如果本地计算机写了一个新功能，首先会提交到本地的版本信息库中，然后再从自己的版本信息库中同步到远程服务器的中心。而集中式要想推只能推一个，但是分布式中心挂掉，不影响本地推代码到本地版本库中，最后推到远程即可。 02 为什么要做版本控制………..写好的功能可以回到上一个版本，很方便，不用来回删除代码或加上代码 03 安装git 装上之后，我们可以在电脑上进行版本控制了，但是还是只是局限在本地。没有办法放到服务器(仓库)上，github或gitlab就属于服务器。 git安装参考 04 东北热创业初期一个人开发一个东北热平台，期间使用版本控制开发 2.1 第一阶段：单枪匹马开始干如果想让git 帮助我们进行版本控制(其实就是帮助我们管理文件或文件夹)，需要进行如下几步： 进入要管理的文件夹 初始化：git init (相当于做了标记，提名谁是老大管理我们要管理文件夹下的这些文件以及文件夹) 检测当前文件夹下的文件的状态：git status 管理文件或文件夹 检测之后采用 git add 文件名 管理文件。 按照正常流程，这一步还是要加上的，加上个人信息的配置(邮箱，用户名)，这样提交的时候就有了个人信息。。【仅需执行如下命令一次即可】 12git config --global user.email &quot;&quot;git config --global user.name &quot;&quot; 生成版本：git commit -m &#39;版本的描述信息&#39; 注意：git add . 其中.代表当前文件夹下没有被管理进去的所有文件 通过git log 查看之前git commit 提交的所有记录 注意git中三种文件状态的变化： 红色：git 未被管理的文件或修改后未被管理的文件 红色-&gt;绿色：git add 文件名/. 绿色：git 管理起来的文件，但是没有还没有生成版本。执行git commit -m &#39;版本信息&#39;会帮助我们生成版本 生成版本 05git commit 之前需要配置信息，查看04即可 06 git 三大区域工作区：当我们执行git init 之后，写代码的时候正在操作的文件夹，文件夹里面的文件里面有两种状态(已管理的文件，新文件或修改的文件)。git会自动检测文件是否是新文件，或者原来已管理的文件又修改则自动变成修改的文件。为什么会自动检测：因为我们执行了git init 暂存区：可以理解为暂时临时先放在这里。如果文件提交到暂存区，不想要我们可以回滚到工作区。 通过git add 将文件从工作区提交到暂存区 版本库：通过git commit 将暂存区的文件提交到版本库中 因为我们知道工作区和版本区是有必要的，为什么需要暂存区呢？ 暂存区我们可以理解为缓冲区，就是可以理解为我们冲动的时候想要做的事，但是事后又不想要。所以暂存区可以理解为给你冷静的时间，让你可以回去也可以继续。 07 回滚通过git log 看到所有版本的记录 通过git reset --hard 版本号来回滚到指定版本号的记录 有时我们遇到如下几种情况： 版本迭代：v1-&gt;v2-&gt;v3-&gt;v4-&gt;v5 但是我们从v5回滚到了v3之后，又想回滚到v4。此时通过git log 看不到v4的提交记录，但是通过git reflog可以看到 如果我们想回到v4，那么执行git reset --hard 版本号 版本号可以通过git reflog命令看到。也就是回滚到版本后面的状态需要通过git reflog查看版本号 2.2 第二阶段：拓展新功能12git addgit commit -m &#39;&#39; 2.3 第三阶段：约饭世界12git addgit commit -m &#39;&#39; 遇到有关部门查处，我们要进行回滚，回滚到之前的版本 12git log 查看之前的回滚记录git reset --hard 版本号 约饭功能可以继续上线，回滚的不是原来的状态，而是回滚到原来状态之后的版本，通过git log是看不到记录的，需要通过git reflog 12git refloggit reset --hard 版本号 08 git 命令小结2.4 总结1234567git initgit addgit commitgit loggit refloggit reset --hard 版本号 各个区域来回切换： 比如我们在项目文件夹下修改了index.html 但是没有add和commit，那么修改完之后使用如下命令就可以回到修改前的状态 git checkout -- index.html 比如我们在项目文件夹下修改了index.html 但是只是git add，那么修改完之后使用如下命令就可以回到修改前的状态 git reset HEAD index.html 09 分支前面讲的例子中，我们在第一个版本开发了东北热（共100个文件），之后第二个版本添加了短视频的功能(只是在东北热的基础上修改了10个文件，并且增加了20个文件) 问题：git 在第二个版本发布时，保存了哪些文件？ 版本2只保存了修改的文件(是修改文件的全部哦，而不是只修改的部分)，没有修改的那90个文件还都在版本1中，版本2中并没有保存，另外需要注意的是版本2有一个指针指向版本1。当我们获取版本2的文件的时候，版本2利用指针拉取版本1的文件，首先从版本1中拉取没有改变的文件，之后从再从版本2中加载修改的文件。 10 紧急修复线上bug的思路默认主干线的分支名字叫做master，在master上可以分其他分支，名字自己定义。修改完之后合并到master 2.5 第四阶段 开发一个商城在开发商城的时候，如果线上的约饭功能遇到了紧急bug，那么如何处理呢？ 此时可以新建一个分支开发商城，当我们遇到紧急bug的时候直接回到原始的没有开发商城之前，在此基础上新建一个分支来修复bug，修复完成后再上线。此时切换到我们开发商城的那个分支继续开发，不会耽搁我们开发商城以及修改Bug。 11 基于分支修复线上bug的具体过程git branch 目前所处在的分支 git branch 分支名 创建分支 git checkout 分支名 切换到指定的分支， 当我们基于目前的代码创建一个分支之后，在该分支上开发不影响master分支。 c1 -&gt; c2 -&gt; c3(master) 此时我们开发商城功能，因此新建一个分支 12345678910111213141516171819202122232425262728git branch devgit checkout dev开发过程中此时遇到了线上的紧急Bug修复git add .git commit .切换到master分支下新建bug分支git checkout mastergit branch buggit checkout bug修复完成，git add .git commit -m &#39;&#39;此时需要合并分支git checkout master git merge bug 相当于站在master分支中，将bug分支拉过来bug完全修复完成,此时应该删掉bug分支git branch -d bug此时可以切换到dev分支继续开发我们的商城，但是原来是基于c3开发的，那个时候bug还没有修复，所以我们先不要管继续开发我们的商城。开发完毕之后git checkout devgit statusgit add .git commit -m &#39;&#39;此时合并新功能到master分支git checkout mastergit merge dev 此时会报错，冲突。为什么会产生冲突呢？因为我们此时线上的版本是修改了bug，而dev分支新建的时候线上的bug还没有修复，会有不一样的地方，因此会产生冲突，此时git不知道如何处理，就会冲突，会在冲突文件中展示各个分支的冲突。我们需要手动解决冲突，解决完之后执行如下代码git statusgit add .git commit -m &#39;&#39; 何时会冲突：如果我们新建的分支基于c3，但是合并该分支到master的时候，master此时不是c3那个版本就会冲突。如果没有冲突则会自动合并。 12 命令总结和工作流 查看分支 1git branch 创建分支 1git branch 分支名称 切换分支 12git checkout 分支名称git checkout -b 创建并切换分支 分支合并(可能产生冲突，找到冲突的文件快速修改即可，后面还会介绍一个软件来修改冲突)，注意：要合并到那里就要切换到哪里，之后再合并分支，比如我想合并dev，那么首先就要git checkout master 切换分支再合并 1git merge 要合并的分支 删除分支 1git branch -d 分支名称 git使用的工作流：以后使用git的时候，我们至少有两个分支master以及dev,我们要在dev分支上进行开发 13 github使用步骤： 创建github账号 创建仓库 本地仓库推送到github 大公司都在用Gitlab 因为只需要一个搭建服务器的钱，并且代码不会泄露 14 基于github做代码托管git remote add origin https://github.com/WuPeiqi/dbhot.git 相当于给后面的网址起了一个别名叫origin 之后我们可以使用git push -u origin master 将我们本地编写的master分支内容推送上去，其他分支内容不会推送哦。 因此可以使用git push -u origin 分支名 将分支推送上去 当我们来到公司之后： git clone 网址 直接克隆代码到本地，此时虽然git branch显示只有一个分支，但是其实所有分支都克隆下来了，我们可以直接使用git checkotu 分支名进行切换 2.6 第5阶段：进军三里屯 给远程仓库起别名 git remote add origin 网址 其中origin可以修改成任意字符串 向远程提交推送代码 git push -u origin 分支名称 推送我们想要推送的分支到远程仓库 公司里面拉代码，克隆远程仓库代码。此时不仅仅会拉下来master分支，会克隆下来所有分支 git clone 远程仓库地址 当我们git clone的时候内部已经自动实现了git remote add origin 远程仓库地址命令 15 奔波于沙河和三里屯之间前面我们已经在公司克隆下了代码，但是我们在dev分支开发时基于之前的master，而现在master已经更新了好几次，所以继续在在dev分支开发新功能的时候要确保dev分支是基于最新的master。也就是我们之前的dev分支功能已经合并到master中了，且dev分支的代码还是基于以前的master，代码比较老，如果新开发一些功能，我们肯定要基于目前的master，因为master是运行的最新稳定版，所以我们要在dev分支git merge master 注意只执行一次哦 1234567891011121314151617181920212223dev分支下执行： git merge master公司第一天代码开发完成以后 git add . git commit -m &#39;公司第一天开发的代码&#39; git push origin dev回到家之后 git branch git checkout dev 更新家里的代码：从远端仓库拉下来进行更新 git pull origin dev 从远程的dev分支拉代码更新 继续编写代码 git add . git commit -m &#39;&#39; git push origin dev来到公司 git branch git checkout dev git pull origin dev 要确保在dev分支下哦 git push -u origin master 其中-u指定了以后提交的默认分支，之后我们git push命令提交的时候会按照上次的-u指定的分支提交 16 约妹子忘推送代码了故事情节：被妹子约饭，在公司写代码之后git commit 命令执行完没有git push，回到家git pull origin dev无法更新代码，没办法只好继续在之前的文件下开发，之后git push origin dev到远程，第二天去到公司git pull origin dev代码时出现conflict，此时所有代码都拉取下来了，只是需要我们手动修改冲突的文件(冲突的文件和之前git merge冲突文件一样)即可(类似于之前我们git merge出现的冲突的解决方式)，解决完冲突之后直接git add git commit git push到远程即可。 1234git pull origin dev 拉取远程仓库代码并合并到本地的dev分支这一句等同于如下两个命令git fetch origin dev 将远程代码拉到版本库中git merge origin&#x2F;dev 将版本库中的远程拉下来的origin&#x2F;dev合并到工作区中 git fetch origin 分支名称 会自动从远程仓库将问价拉取到版本库中，此时为了区分从远程仓库拿下来，git会自动在我们拉取到版本库的文件中的分支名称前面加上一个前缀 origin/。 因此我们后面讲版本库中的文件同步到工作区的时候使用git merge origin/分支名 17 (rebase是面试重点)rebase应用场景一：将之前的多条commit记录合并工作中应用git rebase可以让我们的提交记录变得很简洁，rebase译为变基的意思。 应用场景：公司里面老板给了一个大任务，需要一周时间完成，因为我们每天都会有提交记录，所以到最后的时候我们会有很多commit 记录，但是这些都是无用的，因为老板想要最开始的代码以及最后开发完时的一条commit记录，所以我们可以通过rebase将我们多个提交记录整合成一个提交记录 git rebase -i 命令进行修改，有两种形式： git rebase -i 版本号 会合并我们目前所在的版本与版本号之间的版本，两边都包括 git rebase -i HEAD~3 从当前记录开始找最近的3条记录合并，包括当前记录 执行命令后进入如下界面： 此时v4会合并到上一个版本v3 而v3前面我们也是s因此我们将v3再合并到v2中 修改完成之后会进入如下界面： 因为我们合并了几条提交记录，因此也需要修改几条提交记录合并之后的提交记录。修改为如下内容： 18 (rebase是面试重点)rebase应用场景二：将之前我们分支的记录合并到主分支上也就是归成一条分支上的记录git log --graph 以图形化的形式在命令行中展现git的提交记录 git log --graph --pretty=format:&quot;%h %s&quot; 其中%h代表提交记录的hash值，%s代表我们commit的信息 切换到dev git rebase master 切换回master分支，直接git merge dev即可 12345678910111213141516首先确保master以及dev都保持一致，之后执行如下几条命令，使得master以及dev分支下有自己的新提交记录，git checkout mastertouch master_1.pygit add master_1.py .git commit -m &#39;master_1&#39;git checkout devtouch dev_1.pygit add dev_1.pygit commit -m &#39;dev_1&#39;下面开始本课堂的内容git checkout devgit rebase masterls 会发现已经有了 master_1.py文件git checkout mastergit merge devgit log --graph 此时提交记录就变成了一条线，如果这种情况下我们使用git merge命令将会产生分叉 19 (rebase是面试重点)rebase应用场景三其实在前面的约妹子忘记push代码到远程的这个场景中，如果我们使用merge命令合并家里写的代码以及公司写的代码就会产生分叉。如何不产生分叉呢？ 12345678910111213141516git checkout dev第一天下午公司代码开发完git add .git commit -m &#39;&#39;约妹子吃饭回到家git pull origin dev继续开发git add .git commit -m &#39;&#39;git push origin dev第二天到达公司，按照以往的逻辑会执行如下代码：git pull origin dev然后接着开发就行，但是我们这里如果使用git pull将会产生分叉，那么不产生分叉如何操作呢？我们到达公司之后，进行如下操作：git fetch # git rebase origin&#x2F;dev 解决办法： 第二天到达公司不执行以往的git pull origin dev命令，而是替换为如下命令： git fetch origin dev 接着版本库中有一个远程的origin/dev分支 git rebase origin/dev 因为我们要把远程拉下来放到版本库中的dev分支回到工作区中 注意事项：如果git rebase命令之后有冲突此时就会中断rebase，此时不要紧张，我们手动解决冲突，然后(按照提示)重新git add，之后执行git rebase --continue命令即可 rebase遇到冲突提示如下： 20 使用beyond compare软件快速解决冲突解决冲突的软件：beyond compare ，mac 和 windows都有 以后我们git中使用compare解决冲突，需要双方进行连接，创建关系之后以后我们合并文件的时候直接可以使用命令启动compare帮我们解决冲突 查看安装路径：之后点击安装命令行工具，返回如下结果 git config --local –local指的是当前配置只在当前项目中有效 21 命令总结 22 多人协同开发之gitflow工作流思路假设又招2个人，并且东北热目前只有有一个上线的版本(v1)。 面试题：公司如何做多人协同开发？ 每个人有一个分支，在自己的分支下写代码，是从dev分支下拆除下来的。 当我们每个人自己的功能完成之后想要合并的时候需要老大进行review，只有通过之后才可以合并进去。在小公司里面，代码review通过之后会合并到Master里面，但是大公司比较谨慎，往往会将代码review通过的代码合并到release分支，做测试工作，测试通过之后才上线，如果测试不通过需要修改Bug。 当我们分配到一个新功能的时候大多情况下以功能命名分支比较多见，当分支开发完成合并上线之后就可以删除了 下图是一个完整的gitflow工作流： 不正规的团队会忽略release以及code review 23 多人协同开发之创建初始项目和版本 创建初始项目并同步到远程仓库： 如果想要多人协同开发，需要在github的项目上邀请别人，项目的settings-&gt;collaborators-&gt;写上用户的昵称 这种方式只适合于个人不适合于公司 (适合于公司)公司中会新建一个组织，然后在组织中创建项目。 创建版本： 这里我们新建一个项目并且初始化一个最基本的版本，在公司中我们会基于tag做版本管理 不要使用hash值做版本管理 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：参考 1234git tag -a v1 -m &quot;第一版&quot; 本地生成版本git loggit push origin --tags 推送版本到github 24 多人协同开发之邀请成员首先在邀请成员之前我们首先要建立一个dev分支，因为其他成员来了都是在dev分支下进行开发 1234git branchgit checkout -b devgit branchgit push origin dev 此时小弟开始做事，但是首先小弟要注册github账号并且拉小弟进入。github与gitlab都是一样的。 25 多人协同开发之邀请小弟开发默认情况下成员拥有所有项目的只读权限，只有负责对应项目的人才有写的权限。 对于组织可以设置权限，同时对于项目我们也可以设置权限 当我们进入公司之后，需要clone代码到本地，然后切换到dev分支，之后在dev分支下新建我们自己的分支 123git clone ...git checkout devgit checkout -b 你自己的分支名称 注意：新建分支默认是基于当前分支新建 26 多人协同开发之代码review面试题：你们公司做不做review？谁来做呢？如何做呢？ 做，一般是小组长来做，通过github上的pull request（也叫merge request）来做 首先要进行配置： 如何通知老大code review呢？发起一个Pull request 老大如何做code review呢？ 方式1：网站上直接code review 方式2：命令行拉取代码到本地进行review 27 多人协同开发之测试上线做完了代码review，leader或者测试团队首先会在dev分支下创建一个release分支 123456789101112git branchgit checkout devgit checkout -b releasegit push origin release进行测试，期间不允许修改dev中的代码没有问题则合并到master中或者pull request到master中都可以，取决于leader之后合并到master以及dev中(因为可能修改Bug)此时可以删除release分支，是否删除取决于测试以及leader然后本地切换到master分支从远程拉取代码 git pull origin master有时需要加上标签，git tag -a v2 -m &#39;第二版 增加斗地主功能&#39;git push --tags 注意：release没问题的时候合并到master采用pull request 以及 merge都可以，取决于leader，但是当我们自己开发功能的分支合并到dev中必须pull request 28 给开源项目贡献代码面试题：想要找个牛逼的框架贡献代码如何做？？ fork源代码：将别人源代码拷贝到自己仓库 自己仓库修改代码 给源代码作者提交修复bug的申请，申请pull request 29 配置文件存放3个位置12345678git config --local user.name &#39;&#39;git config --local user.email &#39;&#39;git config --system user.name &#39;&#39;git config --system user.email &#39;&#39;git config --global user.name &#39;&#39;git config --global user.email &#39;&#39; 第一个配置文件(项目配置文件，对应--local, 表示只在当前项目生效)：本地项目的 .git目录下的config 第二个配置文件(全局配置文件，对应--global)：存放在~/.gitconfig 优先级：首先在本项目的.git/config中查找，没有的话就去~/.gitconfig 第三个配置文件：(系统配置文件，对应--system)：存放在 /etc/.gitconfig。需要有root权限 30 git 免密登录 31 gitignore忽略文件github上官方提供了一个仓库用来存储各个语言的gitignore文件 官方 一定要严格注意一些敏感数据文件我们需要加入到gitignore中 32 github做任务管理 Issue：任务管理系统，也可以将他人提出的bug安排给员工 Wiki：对项目的介绍文档以及使用安装等","categories":[{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"工具/git","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7/git/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"}],"author":"yirufeng"},{"title":"Python 中的while循环","slug":"Python-中的while循环","date":"2020-06-08T09:20:05.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/06/08/Python-中的while循环/","link":"","permalink":"http://www.sivan.tech/2020/06/08/Python-%E4%B8%AD%E7%9A%84while%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"while python除了正常的while 循环，还可以在while循环后带上一个else分支，那么执行流程是怎么样的呢？ 话不多说，上来三段代码： # while 循环如果被打断，则不执行else def func(): count = 1 while count &lt; 5: print(count) count += 1 return else: print(666) if name == ‘main‘: func() 1234打印结果：&#96;&#96;&#96;shell1 count = 1 while count &lt; 5: print(count) count += 1 else: print(&quot;last&quot;) 1234567891011打印结果：&#96;&#96;&#96;shell1234last count = 1 while count &lt; 5: print(count) count += 1 break else: print(&quot;last&quot;) 12345打印结果：&#96;&#96;&#96;shell1 分析原因：python执行while 循环，当while循环条件不满足将会执行else语句，但是如果在while循环执行的过程中遇到了break 或者 return 语句 将不会执行else分支","categories":[{"name":"python","slug":"python","permalink":"http://www.sivan.tech/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.sivan.tech/tags/python/"}],"author":"yirufeng"},{"title":"职业-入职前做的事","slug":"职业-入职前做的事","date":"2020-06-05T19:22:19.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/06/05/职业-入职前做的事/","link":"","permalink":"http://www.sivan.tech/2020/06/05/%E8%81%8C%E4%B8%9A-%E5%85%A5%E8%81%8C%E5%89%8D%E5%81%9A%E7%9A%84%E4%BA%8B/","excerpt":"","text":"入职前做的事第一部分 hr带你到工位，认识同事 部门主管来和你打招呼，同时让你熟悉东西 / 告诉你先熟悉什么(1周时间) 公司给你发： 电脑：笔记本(mac 居多，我们选mac) / 台式机 企业邮箱：给一个账号以及初始密码（需要修改初始密码） 钉钉：账号和密码 Vpn：账号和密码，因为回家办公需要连接企业内网 Gitlab：账号和密码 码云 / github 企业版 神道 / jira：项目管理，项目开发进度追踪管理 （工作任务没有完成，会影响绩效） 第二部分2.1 下载代码如果git clone 时遇到git中fatal: Authentication failed的问题，需要删除凭证管理器 解决方式： 删除系统中已经存在的凭证： 123windows电脑：凭据管理，找到账户进行删除Mac电脑：打开钥匙串 -&gt; 删除 [参考](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Mr-Rshare&#x2F;p&#x2F;10734260.html) 在url中写入账户名和密码 git clone https://用户名:密码@github.com/...... ssh 方式 123在自己本地生成一对公钥和私钥，然后将公钥拷贝到github或者码云上之后拷贝项目便可以采用ssh的方式， 在项目仓库那里克隆的时候 有一个ssh选项 git clone git@gitee.com:wupeiqi/s22pro.git 2.2 创建虚拟环境建议项目拷贝之后，为项目创建虚拟环境，在虚拟环境中跑代码 在自己电脑上安装virtualenv pip3 install virtualenv 创建虚拟环境 12进入到自己想要创建环境的目录virtualenv 环境名 进入虚拟环境 1win: 进入 到虚拟环境目录下的Scripts目录，执行activate 退出虚拟环境 win: deactivate 安装软件 1pip install ... 另外一种创建虚拟环境(pycharm自带创建虚拟环境)的方式： 2.3 初始化环境已经有了公司的项目代码以及我们自己搭建的虚拟环境，但是并没有安装项目依赖 1pip3 install -r requirements.txt 如果遇到有些包电脑装不上，一般情况下是系统导致的：例如有些包在Linux下才能使用 因为我们以后的程序运行在linux上，自己可以搭建一个虚拟机 如果是win，自己则百度解决 2.4 数据库设置数据非常重要，所以一般在开发的时候，不会让我们连接正式的数据库 正式库 1234host: 1.1.1.1port: xxxuser: 222pwd: 2 测试库 1234host: 1.1.1.1port: xxxuser: 222pwd: 2 我们在环境以及依赖搭建完成之后，运行代码前需要修改一点进行数据库连接的配置 如果老板没有明确说是正式库还是测试库，最好还是明确一下，以免删掉数据造成不必要的麻烦 2.5 看代码​ 如何看代码：看代码的时候不要企图全部看完。有时我们只需要看完一个文件就可以做了。因为老板希望功能尽快做出来，所以我们只要做出就可以了。 找程序入口 url __main__ 12if &#x27;__name__&#x27; == &#x27;__main__&#x27;: pass 最开始看的时候看注释 + 变量名 + 函数名，大概了解是干嘛的， 调用关系 + 返回值 至少看10个请求 不要一头扎入代码（知道干嘛即可，而不是一头扎进去好好研究） 总的来说就是知道执行流程和调用关系即可。 公司一般会给一周或者一个月(说明公司重视代码质量)的时间看代码 2.6 运行程序在公司的项目中，如果要运行程序，一定要找到谁是主文件，去运行它 找主文件，一般会放在下列文件中 123根目录：app.py &#x2F; manage.py &#x2F; start.pyscripts文件夹：app.py &#x2F; manage.py &#x2F; start.pybin文件夹：app.py &#x2F; manage.py &#x2F; start.py 运行起来： 12python 主文件名python 主文件名 参数 公司中问老板切忌只问业务相关的问题，技术问题自己google解决 如果运行不起来，就不要搞了，别浪费时间，要适可而止，实在运行不起来就去看代码。 建议：先看代码，最后再运行 第三部分看了一段时间后，老板会给你安排一些新任务 开会聊需求和功能 老板会和你要一个项目排期，注意：排期排到这里不意味着你这个时间点提交就可以了，而是你把项目开发完，一定要在这个时间之前把项目开发好。 项目开发分几种情况：一个人开发和协同开发完全不一样 自己个人开发 和其他人协同开发 3.1 一个人开发 从公司把最新的代码拉下来 1git pull master master分支保存写完的代码，如果正在开发需要使用dev分支 至少有两个分支 master / dev 1234567如何创建分支： git branch 分支名查看所有分支： git branch切换分支： git checkout 分支名 在公司当日开发了一部分，电脑在公司，回到家用另一台电脑继续开发，那么我们需要在公司提交到远程 12345678910111213141516171819202122232425262728# 公司开发git statusgit add .git commit -m &#39;开发直播间的功能开发到一半&#39;git push origin dev# 回家之后git pull origin dev在家进行开发git add .git commit -m &#39;在家开发完所有功能&#39;git push origin dev# 第二天到公司git pull origin dev公司开发完git add .git commit -m &#39;开发完&#39;git push origin dev# 开发完毕git checkout master合并dev的功能到mastergit merge dev # 将dev分支拉到我们所在的分支，当前我们在master分支接下来上线，运维会从master分支下代码而不是其他分支# 上线运维会去git中拉代码并作部署处理 有的公司对git commit 后面的提交说明有很严格的格式要求，有固定格式 3.2 一个人开发可能会遇到的问题合并的时候，可能会产生冲突 手动解决冲突： 还可以依赖工具解决冲突，本质上也是手动的 作业 看视频，主演看奔波于沙河和三里屯 git rebase 面试问到过， git rebase干嘛的 变基 git log git reflog git reset 就业安排 知识点复习：四套面试题 补充知识点讲解 简历指导 投简历 今日内容可以在简历上写上：了解drf研究过jwt(json web token)的内部实现原理 jwt1json web token 一般用于用户认证（前后端分离&#x2F;微信小程序&#x2F;app开发）,说白了就是用户登录 我们在后端写了基于restful规范的接口，用户要登录，发送一个用户名密码给后端，认证成功需要发一个标识(生成一个session弄一个随机字符串存里面)，在前后端分离中我们生成随机字符串发送给前端，用户访问需要带着token过来，服务端需要校验token","categories":[{"name":"入职","slug":"入职","permalink":"http://www.sivan.tech/categories/%E5%85%A5%E8%81%8C/"}],"tags":[{"name":"入职","slug":"入职","permalink":"http://www.sivan.tech/tags/%E5%85%A5%E8%81%8C/"}],"author":"yirufeng"},{"title":"(LeetCode系列)242字母易位词","slug":"LeetCode系列-242字母易位词","date":"2020-06-05T16:24:35.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/06/05/LeetCode系列-242字母易位词/","link":"","permalink":"http://www.sivan.tech/2020/06/05/LeetCode%E7%B3%BB%E5%88%97-242%E5%AD%97%E6%AF%8D%E6%98%93%E4%BD%8D%E8%AF%8D/","excerpt":"","text":"字母易位词，指的是两个单词只是字母的排列顺序不同，换言之就是字母的种类数以及字母出现的次数都一致 我们重点只需要验证 字母出现的次数以及字母的种类数是否一致 排序 sorted() 不会改变传入可迭代对象的顺序，而是返回一个排好序的可迭代对象 12def isAnagram(self, s: str, t: str) -&gt; bool: return sorted(s) == sorted(t) 哈希表两种方案： 使用两个哈希表 最后比较 只使用一个哈希表，对第一个单词进行计数，之后对第2个单词计数的时候判断是否最后可以为0 或者中间如果有值小于0则退出 12345678def isAnagram(self, s: str, t: str) -&gt; bool: s_map, t_map = &#123;&#125;, &#123;&#125; for char_s in s: s_map[char_s] = s_map.get(char_s, 0) + 1 for char_t in t: t_map[char_t] = t_map.get(char_t, 0) + 1 return t_map == s_map 123456789def isAnagram(self, s: str, t: str) -&gt; bool: hashmap = &#123;&#125; for char_s in s: hashmap[char_s] = hashmap.get(char_s, 0) + 1 for char_t in t: hashmap[char_t] = hashmap.get(char_t, 0) - 1 if hashmap[char_t] &lt; 0: return False return True 12345678910def isAnagram(self, s: str, t: str) -&gt; bool: hashmap = &#123;&#125; for char_s in s: hashmap[char_s] = hashmap.get(char_s, 0) + 1 for char_t in t: hashmap[char_t] = hashmap.get(char_t, 0) - 1 for value in hashmap.values(): if value != 0: return False return True 直接计数并返回 使用collections模块的Counter() collections.Counter*类统计列表元素出现次数。定义 Counter(计数器)是对字典的补充,用于追踪值的出现次数 12def isAnagram(self, s: str, t: str) -&gt; bool: return collections.Counter(s) == collections.Counter(t) 总结：了解字母异位词的概念：字母易位词，指的是两个单词只是字母的排列顺序不同，换言之就是字母的种类数以及字母出现的次数都一致 使用sorted() sorted() 不会改变传入可迭代对象的顺序，而是返回一个排好序的可迭代对象 使用collections.Counter()类统计列表元素出现次数。定义 Counter(计数器)是对字典的补充,用于追踪值的出现次数 不仅仅可以使用两个哈希表最后比较，还可以使用1个哈希表，判断是否有小于0的元素或者最后是否所有值都等于0","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"}],"author":"yirufeng"},{"title":"(LeetCode系列)7整数反转","slug":"LeetCode系列-7整数反转","date":"2020-06-05T15:18:20.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/06/05/LeetCode系列-7整数反转/","link":"","permalink":"http://www.sivan.tech/2020/06/05/LeetCode%E7%B3%BB%E5%88%97-7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"题意仔细审题，两个关键点 32位有符号整数，需要考虑负数如何处理 题中给的注意，考虑是否溢出 解法一：逆序累加我们将负数乘以-1，与正数统一处理，之后计算反转的结果之后再确认是否需要乘以-1 报错的代码 123456# 第一次提交：报错，错误测试用例，输入的内容经过反转之后超出了32位有符号整数的边界 def reverse(self, x: int) -&gt; int: num, ret = x if x &gt;= 0 else (-1) * x, 0 while num: ret, num = ret * 10 + num % 10, num // 10 return ret if x &gt;= 0 else (-1) * ret 考虑边界情况之后的代码 123456789101112131415# 第二次提交：考虑边界情况，因此特意判断是否超出有符号整数的边界 # 执行用时:36ms, 在所有Python3提交中击败了93.94 %的用户 # 内存消耗:13.6MB, 在所有Python3提交中击败了6.67 % 的用户 def reverse(self, x: int) -&gt; int: # 正负数全部按照正数处理 num, ret &#x3D; x if x &gt;&#x3D; 0 else (-1) * x, 0 while num: ret, num &#x3D; ret * 10 + num % 10, num &#x2F;&#x2F; 10 # 判断是否溢出 if x &gt;&#x3D; 0 and ret &gt; 2147483647: return 0 # 这里我们计算负数,但是我们最开始是将负数按照正数处理，所以反转之后的结果是正数，因为我们到最后才乘以-1 elif x &lt; 0 and ret &gt; 2147483648: return 0 return ret if x &gt;&#x3D; 0 else (-1) * ret 解法二：字符串反转12执行用时:48ms, 在所有Python3提交中击败了43.66 %的用户内存消耗:13.7MB, 在所有Python3提交中击败了6.67 % 的用户 1234def reverse(self, x: int) -&gt; int: num = x if x &gt;= 0 else (-1 * x) num = int(str(num)[::-1]) if x &gt;= 0 else -1 * int(str(num)[::-1]) return 0 if num &gt; 2147483647 or num &lt; -2147483648 else num Java 解法 以及 注意事项 和边界情况的考虑 参考 参考 总结记忆：2^31-1=2147483647,-2^31=-2147483648 python中 取摸 取整除 需要注意 和java不一样 python 中 -1%10 = 9 ， -1//10=-1java 中 -1%10 = 1 ， -1//10=0","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"}],"author":"yirufeng"},{"title":"(LeetCode系列)刷题记","slug":"LeetCode系列-2两数相加-md copy","date":"2020-06-05T11:08:18.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/06/05/LeetCode系列-2两数相加-md copy/","link":"","permalink":"http://www.sivan.tech/2020/06/05/LeetCode%E7%B3%BB%E5%88%97-2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-md%20copy/","excerpt":"","text":"两数相加思路： 分别求出两个链表都有数字时各个数字的和， 如果产生进位，将进位记录在计算下一位的时候加上 如果没有产生进位，移动到下一位 如果有链表为空，那么直接计算剩余链表的数字 与 进位的和 直到最后两个链表都为空，但是还有进位，此时我们还要再给进位分配一个链表的节点 求公共链表之后单独求不为空的链表的解法123456789101112131415def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummy_node = head = ListNode(0) addOne = 0 while l1 and l2: sum = l1.val + l2.val + addOne head.next = ListNode(sum % 10) addOne, head, l1, l2 = sum // 10, head.next, l1.next, l2.next l3 = l1 if l1 else l2 while l3: sum = l3.val + addOne head.next = ListNode(sum % 10) addOne, head, l3 = sum // 10, head.next, l3.next # 如果遍历完但是最后还有一个进位 head.next = ListNode(addOne) if addOne else None return dummy_node.next 原始的解法123456789101112131415161718192021222324class Solution: # 最开始的写法：超时 def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 设置一个dummy node用来表示链表的哨兵头 dummy_node = ListNode(0) head = dummy_node addOne = 0 # 用来表示进位 # 循环结束条件 while l1 or l2 or addOne: # 判断l1或l2是否为0 val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 sum = val1 + val2 + addOne head.next = ListNode(sum % 10) addOne = 1 if sum &gt;= 10 else 0 # 移动的时候也需要判断是否为空 # if l1.next: if l1: # 这里不能判断l1.next,因为我们的大循环下面的l1可能为空 l1 = l1.next # if l2.next: if l2: l2 = l2.next head = head.next return dummy_node.next 原始解法(改进) 改进: 使用三元运算符比单纯的if或者if-else效率高 12345678910111213141516def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 设置一个dummy node用来表示链表的哨兵头 head = dummy_node = ListNode(0) addOne = 0 # 用来表示进位 # 循环结束条件 while l1 or l2 or addOne: # 判断l1或l2是否为0 sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + addOne head.next = ListNode(sum % 10) head = head.next addOne = sum // 10 # 移动的时候也需要判断是否为空 l1 = l1.next if l1 else None l2 = l2.next if l2 else None return dummy_node.next 递归123456789101112131415def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: head = dummy_node = ListNode(0) def AddNum(l1: ListNode, l2: ListNode, extra: int, head: ListNode) -&gt; None: # 递归结束条件 if not l1 and not l2 and not extra: return sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + extra head.next = ListNode(sum % 10) head, l1, l2, extra = head.next, (l1.next if l1 else None), (l2.next if l2 else None), sum // 10 AddNum(l1, l2, extra, head) AddNum(l1, l2, 0, head) return dummy_node.next","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"}],"author":"yirufeng"},{"title":"vscode 快速搭建Python以及Django,Flask开发环境","slug":"vscode-快速搭建Python以及Django-Flask开发环境","date":"2020-06-04T09:22:19.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/06/04/vscode-快速搭建Python以及Django-Flask开发环境/","link":"","permalink":"http://www.sivan.tech/2020/06/04/vscode-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAPython%E4%BB%A5%E5%8F%8ADjango-Flask%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"快速搭建python 开发环境安装扩展(汉化扩展-&gt;python) Command + shift + p进行快速设置 Alt + shift + f 自动按照pep8规范进行格式化代码，如果没有安装，将会提示进行安装 control + shift + ~ 快速新建一个终端 创建虚拟环境 配置python解释器路径的三种方式： 使用command + shift + p vscode 左下角选择运行环境 直接在项目文件夹下的.vscode中的settings.json文件中进行配置 创建Django或者Flask开发环境 创建虚拟环境 python -m venv .venv 在虚拟环境下安装 pip install django/flask 注意：编写html文件的时候，生成的html文件没有任何内容，我们可以输入!，选中智能提示之后将会给我们生成一个html5的模板文件 Mac 下的 vs code快捷键mac linux windows 参考pythonNav","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"vs code","slug":"vs-code","permalink":"http://www.sivan.tech/tags/vs-code/"}],"author":"yirufeng"},{"title":"微信小程序开发","slug":"微信小程序开发","date":"2020-06-02T11:27:29.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/06/02/微信小程序开发/","link":"","permalink":"http://www.sivan.tech/2020/06/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/","excerpt":"","text":"参考","categories":[{"name":"python","slug":"python","permalink":"http://www.sivan.tech/categories/python/"},{"name":"pip","slug":"python/pip","permalink":"http://www.sivan.tech/categories/python/pip/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://www.sivan.tech/tags/pip/"}],"author":"yirufeng"},{"title":"pip临时使用国内源安装模块","slug":"pip临时使用国内源安装模块","date":"2020-05-31T11:27:29.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/31/pip临时使用国内源安装模块/","link":"","permalink":"http://www.sivan.tech/2020/05/31/pip%E4%B8%B4%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E6%BA%90%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97/","excerpt":"","text":"参考","categories":[{"name":"python","slug":"python","permalink":"http://www.sivan.tech/categories/python/"},{"name":"pip","slug":"python/pip","permalink":"http://www.sivan.tech/categories/python/pip/"}],"tags":[{"name":"pip","slug":"pip","permalink":"http://www.sivan.tech/tags/pip/"}],"author":"yirufeng"},{"title":"Mac下Pycharm的快捷键大全","slug":"Mac下Pycharm的快捷键大全","date":"2020-05-28T10:51:04.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/28/Mac下Pycharm的快捷键大全/","link":"","permalink":"http://www.sivan.tech/2020/05/28/Mac%E4%B8%8BPycharm%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"参考","categories":[{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/categories/Tools/"}],"tags":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://www.sivan.tech/tags/Pycharm/"},{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"}],"author":"yirufeng"},{"title":"(LeetCode系列)118杨辉三角","slug":"LeetCode系列-118杨辉三角","date":"2020-05-26T15:16:14.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/26/LeetCode系列-118杨辉三角/","link":"","permalink":"http://www.sivan.tech/2020/05/26/LeetCode%E7%B3%BB%E5%88%97-118%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","excerpt":"","text":"解法解法一(自己的解法，蛮力求解，找关系)发现每一行如果大于2个元素两边都用1填充，并且其他位置的元素的关系式如下： ele[i][j] = ele[i-1][j-1] + ele[i-1][j] ele[i][j] = 1 当且仅当j=0或j=i时 12345678910111213141516class Solution: def generate(self, numRows: int): # 规律第i行有i个元素 li = [] for i in range(numRows): li_li = [] # 从1开始到第i+1结束 for j in range(0, i+1): print(i, j) if j == 0 or j == i: li_li.append(1) else: # 递推公式 li_li.append(li[i-1][j-1] + li[i-1][j]) li.append(li_li) return li 解法二：(LeetCode他人解法)观察一下规律，发现当前一行只比上一行多了一个元素，最最关键的一点：本行元素等于上一行元素往后错一位再逐个相加：参考 12345678class Solution: def generate(self, numRows: int) -&gt; List[List[int]]: if numRows == 0: return [] res = [[1]] while len(res) &lt; numRows: newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])] res.append(newRow) return res 解法三：官方解法参考 官方使用了None 进行占位，之后再具体对None改为具体的值 1234567891011121314151617class Solution: def generate(self, num_rows): triangle = [] for row_num in range(num_rows): # The first and last row elements are always 1. row = [None for _ in range(row_num+1)] row[0], row[-1] = 1, 1 # Each triangle element is equal to the sum of the elements # above-and-to-the-left and above-and-to-the-right. for j in range(1, len(row)-1): row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j] triangle.append(row) return triangle","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"dp","slug":"LeetCode/dp","permalink":"http://www.sivan.tech/categories/LeetCode/dp/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"dp","slug":"dp","permalink":"http://www.sivan.tech/tags/dp/"}],"author":"yirufeng"},{"title":"(LeetCode系列)191位1的个数","slug":"LeetCode系列-191位1的个数","date":"2020-05-26T14:24:19.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/26/LeetCode系列-191位1的个数/","link":"","permalink":"http://www.sivan.tech/2020/05/26/LeetCode%E7%B3%BB%E5%88%97-191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"解决方法方法一：一位一位判断 我们对输入的数字从最后一位开始，每次和1进行与运算，之后每次左移1位 为什么每次不右移1位呢？ 因为如果对于有符号整数，每次右移我们前面会填充符号位(正数填0负数填1)因此对于后面的计数会有影响，而左移对于有符号整数都只是在右边填充0 区分逻辑右移，逻辑左移与算数右移，算数左移： 逻辑左移=算数左移，右边统一添0 逻辑右移，左边统一添0 算数右移，左边添加的数和符号有关 这里有一个前提条件，假定编译器指定Int为32位 12345678910class Solution: # 方法一：前提条件。假设我们的无符号整数是32位 def hammingWeight(self, n: int) -&gt; int: num = 1 count = 0 for i in range(32): # 是否为32取决于编译器的类型 if num &amp; n: count += 1 num &lt;&lt;= 1 return count 时间复杂度：o(二进制的位数) 空间复杂度：o(1) 方法二：使用n &amp; (n-1) 直接判断最后1个1，从而每次进行计数时间复杂度：o(1的个数) 空间复杂度：o(1) 12345678class Solution: # 方法二： def hammingWeight(self, n: int) -&gt; int: count = 0 while n: n = n &amp; (n - 1) count += 1 return count 方法三：使用python自带的内置函数两个预备知识： bin(n) 以字符串的形式返回n的二进制表达 count() 用于统计字符串里某个字符出现的次数 1234567class Solution: # 方法三： def hammingWeight(self, n: int) -&gt; int: # bin(n) 以字符串的形式返回n的二进制表达 # count() 用于统计字符串里某个字符出现的次数 return bin(n).count(&#x27;1&#x27;)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"位运算","slug":"LeetCode/位运算","permalink":"http://www.sivan.tech/categories/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"http://www.sivan.tech/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"author":"yirufeng"},{"title":"(LeetCode系列)136只出现一次的数字","slug":"LeetCode系列-136只出现一次的数字","date":"2020-05-26T12:29:22.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/26/LeetCode系列-136只出现一次的数字/","link":"","permalink":"http://www.sivan.tech/2020/05/26/LeetCode%E7%B3%BB%E5%88%97-136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"","text":"解法解法一：暴力每次遍历一个数与后面的数进行比较，如果相等，则此次遍历break，开始遍历下一个数字。 时间复杂度：o(n^2) 空间复杂度：o(n) 解法二：排序时间复杂度：o(nlog2n) 空间复杂度：o(1) 解法三：使用hash表统计出现的次数时间复杂度：o(n) 空间复杂度：o(n) 解法四：使用集合统计出现一次的数字 定义一个新的集合，遍历题中给的数组，第一次出现的数字加入集合，遍历到某个数字时，若已经存在集合中则从集合中移除，最终剩余的便是只出现一次的数字，返回即可 时间复杂度：o(n) 空间复杂度：o(n) 解法五：使用集合(利用集合不可以存储重复元素)使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。 时间复杂度：o(n) 空间复杂度：o(n) 解法六：使用异或运算为什么会想到异或运算，因为题目中给了条件，只有一个数字出现了一次，其他数字出现了两次，联想到了异或的性质：a^b^a = a^a^b = 0^b = b 因为题目中其他数字都出现了两次，所以根据异或的交换律和结合律，两两相同的元素在交换后结合到一起边产生多个0。而剩下的只出现1次的数字再与前面的0异或便得到了自己，也就是只出现一次的数字。举例如下： 一个数组为[1, 3, 4, 3, 6, 1, 6] 首先所有数字进行异或：1 ^ 3 ^ 4 ^ 3 ^ 6 ^ 1 ^ 6 ——(应用交换律以及结合律)—–&gt; (1 ^ 1) ^ (3 ^ 3) ^ (6 ^ 6) ^ 4 ——-&gt; 0 ^ 0 ^ 0 ^ 4 ——-&gt; 4 时间复杂度：o(n) 空间复杂度：o(1) 参考关于异或的性质：请参考","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"位运算","slug":"LeetCode/位运算","permalink":"http://www.sivan.tech/categories/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"位运算","slug":"位运算","permalink":"http://www.sivan.tech/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}],"author":"yirufeng"},{"title":"(Redis学习-安装篇)Mac下安装redis","slug":"Mac下安装redis","date":"2020-05-22T10:31:26.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/22/Mac下安装redis/","link":"","permalink":"http://www.sivan.tech/2020/05/22/Mac%E4%B8%8B%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"参考 redis-server 是服务端启动程序redis-cli 是客户端启动程序","categories":[{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/tags/redis/"}],"author":"yirufeng"},{"title":"(Maven学习-3)解决Maven下载速度过慢","slug":"解决Maven下载速度过慢","date":"2020-05-21T11:18:42.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2020/05/21/解决Maven下载速度过慢/","link":"","permalink":"http://www.sivan.tech/2020/05/21/%E8%A7%A3%E5%86%B3Maven%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2/","excerpt":"","text":"进入到maven的安装目录 /usr/local/maven/apache-maven-3.6.3/ 修改conf目录下的settings.xml配置文件，mirrors修改为如下内容(使用阿里云的maven镜像) 1234567891011121314151617181920&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;","categories":[{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/tags/maven/"}],"author":"yirufeng"},{"title":"(Maven学习-2)Mac下Idea配置maven","slug":"Mac下Idea配置maven","date":"2020-05-21T10:54:47.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/21/Mac下Idea配置maven/","link":"","permalink":"http://www.sivan.tech/2020/05/21/Mac%E4%B8%8BIdea%E9%85%8D%E7%BD%AEmaven/","excerpt":"","text":"参考","categories":[{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/tags/maven/"},{"name":"Idea","slug":"Idea","permalink":"http://www.sivan.tech/tags/Idea/"}],"author":"yirufeng"},{"title":"(Maven学习-1)Mac下安装并配置Maven","slug":"Mac下安装并配置Maven","date":"2020-05-21T10:43:59.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2020/05/21/Mac下安装并配置Maven/","link":"","permalink":"http://www.sivan.tech/2020/05/21/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEMaven/","excerpt":"","text":"参考","categories":[{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/categories/maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://www.sivan.tech/tags/Maven/"}],"author":"yirufeng"},{"title":"hexo环境搭建","slug":"hexo博客环境搭建","date":"2019-03-21T21:17:42.000Z","updated":"2021-05-30T02:42:45.752Z","comments":true,"path":"2019/03/21/hexo博客环境搭建/","link":"","permalink":"http://www.sivan.tech/2019/03/21/hexo%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"本环境基于mac 注意：如果不想使用nvm进行多node版本的管理，直接可以使用去[官网]下载LTS版本，安装后从第四步开始执行 第一步：安装nvm 执行curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 或 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 注意：注意后面的v0.33.8这是nvm的版本号，最新版本查看 安装完成后关闭终端，然后键入nvm看一下是否有输出，如果command not found请查看 补充：nvm常用命令介绍 123456● nvm install stable 安装最新稳定版 node● nvm install &lt;version&gt; 安装指定版本，如：安装v4.4.0，nvm install v4.4.0● nvm uninstall &lt;version&gt; 删除已安装的指定版本，语法与install类似● nvm use &lt;version&gt; 切换使用指定的版本node● nvm ls 列出所有安装的版本● nvm alias default &lt;version&gt; 如： nvm alias default v11.1.0 第二步：卸载原来的hexo 删除原来的hexo：npm uninstall -g hexo-cli 第三步：安装node 由于hexo必须要用npm安装，hexo安装的版本取决于node的版本 使用nvm选择我们的node版本，如果对应版本没有安装，首先使用nvm安装对应版本的node。nvm install &lt;version&gt; 切换到对应的node版本：npm use &lt;version&gt; 第四步：安装hexo 安装hexo： npm install -g hexo-cli 参考：https://www.imczw.com/post/tech/hexo5-next8-updated.html","categories":[{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/tags/hexo/"}],"author":"yirufeng"},{"title":"计算机网络面试题整理","slug":"计算机网络面试题整理","date":"2018-09-19T10:32:00.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2018/09/19/计算机网络面试题整理/","link":"","permalink":"http://www.sivan.tech/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","excerpt":"","text":"操作系统协程，线程，进程，以及区别 操作系统为了跟踪每个进程的活动状态，维护了一个进程表。进程表的内部列出了每个进程的状态以及每个进程使用的资源等。 进程：正在执行程序的一个实例，是资源分配的基本单位。（进程控制块（process control block）描述进程的基本信息和运行状态，所谓的创建和撤销进程，都是指对PCB的操作）线程：进程中的单条流向，是程序独立调度的基本单位。 区别： （拥有资源）一个进程可以有多个线程，由于线程不拥有资源，这几个线程共享进程内的资源。 （资源开销）创建和撤销线程比进程开销小很多，因为创建线程仅仅需要堆栈空间以及程序计数器就可以了而创建进程需要分配地址空间，数据资源等，开销比较大。 （调度）由于线程是独立调度的基本单位，同一进程中线程的切换不会引起进程的切换，但是两个不同进程中的线程切换会引起进程切换。 （通信）线程可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。 进程之间如何通信进程间通信：(Inter process communication)几种方式： 消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程中间提供全双工通信连接 管道：用于两个相关进程间通信，是一种半双工的通信方式，只能在父子进程中使用，如果需要全双工，需要另外的一个管道。 先进先出队列：两个不相关的进程之间的通信，是一种全双工的通信方式。同时不需要父子进程关系。 套接字：与其他通信方式不同，可以用于不同机器之间的进程通信。 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问 共享内存：使用所有进程的内存来建立连接，不过需要同步进程（信号量）来保护访问。是最快的IPC方式。 直接通信：进程间只存在一条连接，因此要明确双方的命名。 间接通信：通信双方不会直接建立连接，通过一个中介，进程可以在中介放置和删除消息以此达到进程通信 消息传递：消息传递是进程间实现通信和同步等待的机制。消息直接由发送方传递给接收方。 内核态线程和用户态线程的区别如何切换 上下文切换的细节 进程和线程的区别 了解虚拟内存吗？什么是虚拟内存？为什么要有虚拟内存？ 线程的上下文切换 用户态和内核态 计算机网络 udp tcp 以及区别： UDP(User Datagram Protocol) TCP(Transmission Control Protocol) 无连接 面向连接 支持一对一，一对多，多对一，多对多通信 因为双方需要提前建立连接，因此只能一对一进行通信(全双工：双方随时都可以发送和接收数据) 面向报文段(对应用层发送的报文段直接添加首部并传送到IP) 面向字节流 不保证可靠交付：尽最大努力交付，不使用流量控制和拥塞控制 可靠传输，使用确认序号，滑动窗口，流量控制以及拥塞控制等来实现可靠传输 首部只有8字节 首部最小有20自己，最大有60字节s 输入url发生了什么 或者 用户在浏览器输入网址后到呈现页面的详细步骤 4次 http和https的区别 Http传输信息是明文传输，而使用Https在tcp和http之间加入了SSL/TLS安全协议，使得报文可以加密传输 http建立连接相对简单，只需要tcp3次连接即可，而https除了tcp建立连接的3次过程还需要SSL/TKS的握手过程 http端口号是80，而https端口号是443 https协议需要向CA申请数字证书，来保证服务器身份是可信的。 三次握手四次挥手，拥塞控制 arp协议 计网转发分组的详细过程 tcp访问一个主机如果主机端口不存在返回什么信息 我说应该是time out吧 网络的整个协议栈 一个tcp程序的具体步骤 说说你所知道的网络定时器的机制 问了网络的协议栈 为什么要分层 网络连接的各层的状态 说一下URL的格式，越详细越好 http的请求方法有哪些 get与post的区别 get方法是从服务器获取资源，而post则是向URI指定的资源提交数据，数据就存放在报文的body里面 get方法是安全和幂等的，而post方法不是安全和幂等的。(安全是指请求方法不会破坏服务器上的资源，幂等是指多次执行相同的操作结果都是相同的。因为post方法每次新增或提交数据的操作都会修改服务器上的资源，所以是不安全的，且多次提交之后就会新建多个资源，所以不是幂等的) HTTP 请求的报文格式 TIME_WAIT？有什么方法可以避免 TIME_WAIT？TIME_WAIT 是主动断开连接的一方还是被动断开的一方？","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"面试/计算机网络","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.sivan.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"yirufeng"},{"title":"操作系统高频面试","slug":"操作系统高频面试","date":"2018-09-02T19:23:42.000Z","updated":"2021-05-30T02:42:45.756Z","comments":true,"path":"2018/09/02/操作系统高频面试/","link":"","permalink":"http://www.sivan.tech/2018/09/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95/","excerpt":"","text":"进程与线程区别 进程是资源分配的基本单位，线程是独立运行和独立调度的基本单位(CPU上真正运行的是线程) 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源 线程的调度与切换比进程快很多 并发与并行 并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。 并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。 注意点：并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』 一个让人更加容易理解的例子： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 CPU密集型（CPU-bound）与 IO密集型（I/O bound）CPU密集型（CPU-bound）CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。 在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。 CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。 IO密集型（I/O bound）IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。 I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。 计算密集型任务需要大量的计算，虽然多任务也可以完成计算密集型任务，但是任务越多花在任务切换时间越多，CPU执行任务的效率越低，所以要高效利用CPU，采用多进程开发。 IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率（原因就是因为计算不是短板，IO是短板，所以提高IO才会显著提升性能）。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 总结：CPU密集型任务使用多进程，IO密集型任务使用多线程 阻塞与非阻塞 阻塞是指调用线程或者进程被操作系统挂起。 非阻塞是指调用线程或者进程不会被操作系统挂起。 同步与异步同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。看下图 参考","categories":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"面试/OS","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/OS/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/tags/OS/"}],"author":"yirufeng"}],"categories":[{"name":"demo","slug":"demo","permalink":"http://www.sivan.tech/categories/demo/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/categories/LeetCode/"},{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"环境搭建","slug":"微服务/环境搭建","permalink":"http://www.sivan.tech/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"汇总","slug":"汇总","permalink":"http://www.sivan.tech/categories/%E6%B1%87%E6%80%BB/"},{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/categories/tools/"},{"name":"中间件","slug":"中间件","permalink":"http://www.sivan.tech/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/categories/mysql/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/categories/docker/"},{"name":"CI/CD","slug":"CI-CD","permalink":"http://www.sivan.tech/categories/CI-CD/"},{"name":"go","slug":"go","permalink":"http://www.sivan.tech/categories/go/"},{"name":"linux","slug":"linux","permalink":"http://www.sivan.tech/categories/linux/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/categories/Linux/"},{"name":"网络","slug":"Linux/网络","permalink":"http://www.sivan.tech/categories/Linux/%E7%BD%91%E7%BB%9C/"},{"name":"架构","slug":"架构","permalink":"http://www.sivan.tech/categories/%E6%9E%B6%E6%9E%84/"},{"name":"学习路线","slug":"架构/学习路线","permalink":"http://www.sivan.tech/categories/%E6%9E%B6%E6%9E%84/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"基本数据结构","slug":"go/基本数据结构","permalink":"http://www.sivan.tech/categories/go/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/categories/redis/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/categories/OS/"},{"name":"树","slug":"算法/树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"},{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7/"},{"name":"逃逸分析","slug":"go/逃逸分析","permalink":"http://www.sivan.tech/categories/go/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"name":"旅行","slug":"旅行","permalink":"http://www.sivan.tech/categories/%E6%97%85%E8%A1%8C/"},{"name":"golang","slug":"golang","permalink":"http://www.sivan.tech/categories/golang/"},{"name":"jwt","slug":"jwt","permalink":"http://www.sivan.tech/categories/jwt/"},{"name":"go","slug":"jwt/go","permalink":"http://www.sivan.tech/categories/jwt/go/"},{"name":"二分","slug":"算法/二分","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"LeetCode/算法","permalink":"http://www.sivan.tech/categories/LeetCode/%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"算法/面试","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/"},{"name":"二叉树","slug":"算法/面试/二叉树","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"面试/算法","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/"},{"name":"nginx","slug":"nginx","permalink":"http://www.sivan.tech/categories/nginx/"},{"name":"BFPRT","slug":"算法/BFPRT","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/BFPRT/"},{"name":"错误","slug":"go/错误","permalink":"http://www.sivan.tech/categories/go/%E9%94%99%E8%AF%AF/"},{"name":"json","slug":"go/json","permalink":"http://www.sivan.tech/categories/go/json/"},{"name":"爬虫","slug":"go/爬虫","permalink":"http://www.sivan.tech/categories/go/%E7%88%AC%E8%99%AB/"},{"name":"数据结构","slug":"算法/数据结构","permalink":"http://www.sivan.tech/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/categories/Golang/"},{"name":"工具篇","slug":"工具篇","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/"},{"name":"OS","slug":"面试/OS","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/OS/"},{"name":"岗位","slug":"岗位","permalink":"http://www.sivan.tech/categories/%E5%B2%97%E4%BD%8D/"},{"name":"回溯","slug":"LeetCode/回溯","permalink":"http://www.sivan.tech/categories/LeetCode/%E5%9B%9E%E6%BA%AF/"},{"name":"计算机网络","slug":"面试/计算机网络","permalink":"http://www.sivan.tech/categories/%E9%9D%A2%E8%AF%95/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"git","slug":"工具/git","permalink":"http://www.sivan.tech/categories/%E5%B7%A5%E5%85%B7/git/"},{"name":"python","slug":"python","permalink":"http://www.sivan.tech/categories/python/"},{"name":"入职","slug":"入职","permalink":"http://www.sivan.tech/categories/%E5%85%A5%E8%81%8C/"},{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/categories/Tools/"},{"name":"pip","slug":"python/pip","permalink":"http://www.sivan.tech/categories/python/pip/"},{"name":"dp","slug":"LeetCode/dp","permalink":"http://www.sivan.tech/categories/LeetCode/dp/"},{"name":"位运算","slug":"LeetCode/位运算","permalink":"http://www.sivan.tech/categories/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/categories/maven/"},{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/categories/hexo/"}],"tags":[{"name":"demo","slug":"demo","permalink":"http://www.sivan.tech/tags/demo/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://www.sivan.tech/tags/LeetCode/"},{"name":"go","slug":"go","permalink":"http://www.sivan.tech/tags/go/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www.sivan.tech/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"微服务","slug":"微服务","permalink":"http://www.sivan.tech/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"算法","slug":"算法","permalink":"http://www.sivan.tech/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://www.sivan.tech/tags/%E6%8E%92%E5%BA%8F/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://www.sivan.tech/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"堆排序","slug":"堆排序","permalink":"http://www.sivan.tech/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","permalink":"http://www.sivan.tech/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","permalink":"http://www.sivan.tech/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"选择排序","slug":"选择排序","permalink":"http://www.sivan.tech/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"name":"直接插入排序","slug":"直接插入排序","permalink":"http://www.sivan.tech/tags/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"大牛","slug":"大牛","permalink":"http://www.sivan.tech/tags/%E5%A4%A7%E7%89%9B/"},{"name":"阅读清单","slug":"阅读清单","permalink":"http://www.sivan.tech/tags/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"},{"name":"tools","slug":"tools","permalink":"http://www.sivan.tech/tags/tools/"},{"name":"parallel desktop","slug":"parallel-desktop","permalink":"http://www.sivan.tech/tags/parallel-desktop/"},{"name":"redis","slug":"redis","permalink":"http://www.sivan.tech/tags/redis/"},{"name":"架构","slug":"架构","permalink":"http://www.sivan.tech/tags/%E6%9E%B6%E6%9E%84/"},{"name":"nginx","slug":"nginx","permalink":"http://www.sivan.tech/tags/nginx/"},{"name":"中间件","slug":"中间件","permalink":"http://www.sivan.tech/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"memcached","slug":"memcached","permalink":"http://www.sivan.tech/tags/memcached/"},{"name":"mysql","slug":"mysql","permalink":"http://www.sivan.tech/tags/mysql/"},{"name":"极客时间","slug":"极客时间","permalink":"http://www.sivan.tech/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"},{"name":"Tools","slug":"Tools","permalink":"http://www.sivan.tech/tags/Tools/"},{"name":"Centos","slug":"Centos","permalink":"http://www.sivan.tech/tags/Centos/"},{"name":"docker","slug":"docker","permalink":"http://www.sivan.tech/tags/docker/"},{"name":"Linux","slug":"Linux","permalink":"http://www.sivan.tech/tags/Linux/"},{"name":"gitlab","slug":"gitlab","permalink":"http://www.sivan.tech/tags/gitlab/"},{"name":"框架","slug":"框架","permalink":"http://www.sivan.tech/tags/%E6%A1%86%E6%9E%B6/"},{"name":"orm","slug":"orm","permalink":"http://www.sivan.tech/tags/orm/"},{"name":"linux","slug":"linux","permalink":"http://www.sivan.tech/tags/linux/"},{"name":"服务器","slug":"服务器","permalink":"http://www.sivan.tech/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://www.sivan.tech/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"},{"name":"面试","slug":"面试","permalink":"http://www.sivan.tech/tags/%E9%9D%A2%E8%AF%95/"},{"name":"IO","slug":"IO","permalink":"http://www.sivan.tech/tags/IO/"},{"name":"多路复用","slug":"多路复用","permalink":"http://www.sivan.tech/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"},{"name":"学习路线","slug":"学习路线","permalink":"http://www.sivan.tech/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"go的基本数据结构","slug":"go的基本数据结构","permalink":"http://www.sivan.tech/tags/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"OS","slug":"OS","permalink":"http://www.sivan.tech/tags/OS/"},{"name":"树","slug":"树","permalink":"http://www.sivan.tech/tags/%E6%A0%91/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://www.sivan.tech/tags/Algorithms/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"AVL树","slug":"AVL树","permalink":"http://www.sivan.tech/tags/AVL%E6%A0%91/"},{"name":"B树","slug":"B树","permalink":"http://www.sivan.tech/tags/B%E6%A0%91/"},{"name":"B+树","slug":"B-树","permalink":"http://www.sivan.tech/tags/B-%E6%A0%91/"},{"name":"调试","slug":"调试","permalink":"http://www.sivan.tech/tags/%E8%B0%83%E8%AF%95/"},{"name":"工具","slug":"工具","permalink":"http://www.sivan.tech/tags/%E5%B7%A5%E5%85%B7/"},{"name":"逃逸分析","slug":"逃逸分析","permalink":"http://www.sivan.tech/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"},{"name":"旅行","slug":"旅行","permalink":"http://www.sivan.tech/tags/%E6%97%85%E8%A1%8C/"},{"name":"杂记","slug":"杂记","permalink":"http://www.sivan.tech/tags/%E6%9D%82%E8%AE%B0/"},{"name":"跨域问题","slug":"跨域问题","permalink":"http://www.sivan.tech/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"name":"CORS","slug":"CORS","permalink":"http://www.sivan.tech/tags/CORS/"},{"name":"jwt","slug":"jwt","permalink":"http://www.sivan.tech/tags/jwt/"},{"name":"jwt-gos","slug":"jwt-gos","permalink":"http://www.sivan.tech/tags/jwt-gos/"},{"name":"二分","slug":"二分","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%88%86/"},{"name":"矩阵","slug":"矩阵","permalink":"http://www.sivan.tech/tags/%E7%9F%A9%E9%98%B5/"},{"name":"二叉树","slug":"二叉树","permalink":"http://www.sivan.tech/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"刷题","slug":"刷题","permalink":"http://www.sivan.tech/tags/%E5%88%B7%E9%A2%98/"},{"name":"Golang","slug":"Golang","permalink":"http://www.sivan.tech/tags/Golang/"},{"name":"DP","slug":"DP","permalink":"http://www.sivan.tech/tags/DP/"},{"name":"树形DP","slug":"树形DP","permalink":"http://www.sivan.tech/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://www.sivan.tech/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"部署","slug":"部署","permalink":"http://www.sivan.tech/tags/%E9%83%A8%E7%BD%B2/"},{"name":"云服务器","slug":"云服务器","permalink":"http://www.sivan.tech/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"defer","slug":"defer","permalink":"http://www.sivan.tech/tags/defer/"},{"name":"panic","slug":"panic","permalink":"http://www.sivan.tech/tags/panic/"},{"name":"recover","slug":"recover","permalink":"http://www.sivan.tech/tags/recover/"},{"name":"iota","slug":"iota","permalink":"http://www.sivan.tech/tags/iota/"},{"name":"BFPRT","slug":"BFPRT","permalink":"http://www.sivan.tech/tags/BFPRT/"},{"name":"topK","slug":"topK","permalink":"http://www.sivan.tech/tags/topK/"},{"name":"找第几大或第几小","slug":"找第几大或第几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E7%AC%AC%E5%87%A0%E5%A4%A7%E6%88%96%E7%AC%AC%E5%87%A0%E5%B0%8F/"},{"name":"找前几大或前几小","slug":"找前几大或前几小","permalink":"http://www.sivan.tech/tags/%E6%89%BE%E5%89%8D%E5%87%A0%E5%A4%A7%E6%88%96%E5%89%8D%E5%87%A0%E5%B0%8F/"},{"name":"flag","slug":"flag","permalink":"http://www.sivan.tech/tags/flag/"},{"name":"文件","slug":"文件","permalink":"http://www.sivan.tech/tags/%E6%96%87%E4%BB%B6/"},{"name":"错误","slug":"错误","permalink":"http://www.sivan.tech/tags/%E9%94%99%E8%AF%AF/"},{"name":"error","slug":"error","permalink":"http://www.sivan.tech/tags/error/"},{"name":"序列化","slug":"序列化","permalink":"http://www.sivan.tech/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.sivan.tech/tags/%E7%88%AC%E8%99%AB/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.sivan.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"http://www.sivan.tech/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"http://www.sivan.tech/tags/%E9%98%9F%E5%88%97/"},{"name":"桶排序","slug":"桶排序","permalink":"http://www.sivan.tech/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.sivan.tech/tags/Mysql/"},{"name":"统计逆序对","slug":"统计逆序对","permalink":"http://www.sivan.tech/tags/%E7%BB%9F%E8%AE%A1%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"小和问题","slug":"小和问题","permalink":"http://www.sivan.tech/tags/%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://www.sivan.tech/tags/Ubuntu/"},{"name":"主从复制","slug":"主从复制","permalink":"http://www.sivan.tech/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"},{"name":"堆","slug":"堆","permalink":"http://www.sivan.tech/tags/%E5%A0%86/"},{"name":"岗位","slug":"岗位","permalink":"http://www.sivan.tech/tags/%E5%B2%97%E4%BD%8D/"},{"name":"前缀树","slug":"前缀树","permalink":"http://www.sivan.tech/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.sivan.tech/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"python","slug":"python","permalink":"http://www.sivan.tech/tags/python/"},{"name":"入职","slug":"入职","permalink":"http://www.sivan.tech/tags/%E5%85%A5%E8%81%8C/"},{"name":"vs code","slug":"vs-code","permalink":"http://www.sivan.tech/tags/vs-code/"},{"name":"pip","slug":"pip","permalink":"http://www.sivan.tech/tags/pip/"},{"name":"Pycharm","slug":"Pycharm","permalink":"http://www.sivan.tech/tags/Pycharm/"},{"name":"dp","slug":"dp","permalink":"http://www.sivan.tech/tags/dp/"},{"name":"位运算","slug":"位运算","permalink":"http://www.sivan.tech/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"maven","slug":"maven","permalink":"http://www.sivan.tech/tags/maven/"},{"name":"Idea","slug":"Idea","permalink":"http://www.sivan.tech/tags/Idea/"},{"name":"Maven","slug":"Maven","permalink":"http://www.sivan.tech/tags/Maven/"},{"name":"hexo","slug":"hexo","permalink":"http://www.sivan.tech/tags/hexo/"}]}